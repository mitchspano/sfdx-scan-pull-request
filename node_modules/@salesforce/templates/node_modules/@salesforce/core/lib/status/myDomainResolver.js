"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MyDomainResolver = void 0;
const dns_1 = require("dns");
const url_1 = require("url");
const util_1 = require("util");
const ts_types_1 = require("@salesforce/ts-types");
const kit_1 = require("@salesforce/kit");
const logger_1 = require("../logger");
const sfdcUrl_1 = require("../util/sfdcUrl");
const pollingClient_1 = require("./pollingClient");
// Timeout for DNS lookup polling defaults to 3 seconds and should always be at least 3 seconds
const DNS_TIMEOUT = Math.max(3, new kit_1.Env().getNumber('SFDX_DNS_TIMEOUT', 3));
// Retry frequency for DNS lookup polling defaults to 1 second and should be at least 1 second
const DNS_RETRY_FREQ = Math.max(1, new kit_1.Env().getNumber('SFDX_DNS_RETRY_FREQUENCY', 1));
/**
 * A class used to resolve MyDomains. After a ScratchOrg is created it's host name my not be propagated to the
 * Salesforce DNS service. This service is not exclusive to Salesforce My Domain URL and could be used for any hostname.
 *
 * ```
 * (async () => {
 *  const options: MyDomainResolver.Options = {
 *      url: new URL('http://mydomain.salesforce.com'),
 *      timeout: Duration.minutes(5),
 *      frequency: Duration.seconds(10)
 *  };
 *  const resolver: MyDomainResolver = await MyDomainResolver.create(options);
 *  const ipAddress: AnyJson = await resolver.resolve();
 *  console.log(`Successfully resolved host: ${options.url} to address: ${ipAddress}`);
 * })();
 * ```
 */
class MyDomainResolver extends kit_1.AsyncOptionalCreatable {
    /**
     * Constructor
     * **Do not directly construct instances of this class -- use {@link MyDomainResolver.create} instead.**
     *
     * @param options The options for the class instance
     */
    constructor(options) {
        super(options);
        this.options = options || { url: MyDomainResolver.DEFAULT_DOMAIN };
    }
    /**
     * Method that performs the dns lookup of the host. If the lookup fails the internal polling client will try again
     * given the optional interval. Returns the resolved ip address.
     *
     * If SFDX_DISABLE_DNS_CHECK environment variable is set to true, it will immediately return the host without
     * executing the dns loookup.
     */
    async resolve() {
        if (new kit_1.Env().getBoolean('SFDX_DISABLE_DNS_CHECK', false)) {
            this.logger.debug('SFDX_DISABLE_DNS_CHECK set to true. Skipping DNS check...');
            return this.options.url.host;
        }
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        const pollingOptions = {
            async poll() {
                const { host } = self.options.url;
                let dnsResult;
                try {
                    self.logger.debug(`Attempting to resolve url: ${host}`);
                    if (new sfdcUrl_1.SfdcUrl(self.options.url).isLocalUrl()) {
                        return {
                            completed: true,
                            payload: '127.0.0.1',
                        };
                    }
                    dnsResult = await util_1.promisify(dns_1.lookup)(host);
                    self.logger.debug(`Successfully resolved host: ${host} result: ${JSON.stringify(dnsResult)}`);
                    return {
                        completed: true,
                        payload: dnsResult.address,
                    };
                }
                catch (e) {
                    self.logger.debug(`An error occurred trying to resolve: ${host}`);
                    self.logger.debug(`Error: ${e.message}`);
                    self.logger.debug('Re-trying dns lookup again....');
                    return {
                        completed: false,
                    };
                }
            },
            timeout: this.options.timeout || kit_1.Duration.seconds(DNS_TIMEOUT),
            frequency: this.options.frequency || kit_1.Duration.seconds(DNS_RETRY_FREQ),
            timeoutErrorName: 'MyDomainResolverTimeoutError',
        };
        const client = await pollingClient_1.PollingClient.create(pollingOptions);
        return ts_types_1.ensureString(await client.subscribe());
    }
    async getCnames() {
        try {
            await this.resolve();
            return await util_1.promisify(dns_1.resolveCname)(this.options.url.host);
        }
        catch (e) {
            this.logger.debug(`An error occurred trying to resolve: ${this.options.url.host}`);
            this.logger.debug(`Error: ${e.message}`);
            return [];
        }
    }
    /**
     * Used to initialize asynchronous components.
     */
    async init() {
        this.logger = await logger_1.Logger.child('MyDomainResolver');
    }
}
exports.MyDomainResolver = MyDomainResolver;
MyDomainResolver.DEFAULT_DOMAIN = new url_1.URL('https://login.salesforce.com');
//# sourceMappingURL=myDomainResolver.js.map