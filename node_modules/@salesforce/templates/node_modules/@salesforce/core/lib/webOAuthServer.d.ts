/// <reference types="node" />
import * as http from 'http';
import { AsyncCreatable } from '@salesforce/kit';
import { OAuth2Options } from 'jsforce';
import { AuthInfo } from './authInfo';
/**
 * Handles the creation of a web server for web based login flows.
 *
 * Usage:
 * ```
 * const oauthConfig = {
 *   loginUrl: this.flags.instanceurl,
 *   clientId: this.flags.clientid,
 * };
 *
 * const oauthServer = await WebOAuthServer.create({ oauthConfig });
 * await oauthServer.start();
 * await open(oauthServer.getAuthorizationUrl(), { wait: false });
 * const authInfo = await oauthServer.authorizeAndSave();
 * ```
 */
export declare class WebOAuthServer extends AsyncCreatable<WebOAuthServer.Options> {
    static DEFAULT_PORT: number;
    private authUrl;
    private logger;
    private webServer;
    private oauth2;
    private oauthConfig;
    constructor(options: WebOAuthServer.Options);
    /**
     * Returns the configured oauthLocalPort or the WebOAuthServer.DEFAULT_PORT
     *
     * @returns {Promise<number>}
     */
    static determineOauthPort(): Promise<number>;
    /**
     * Returns the authorization url that's used for the login flow
     *
     * @returns {string}
     */
    getAuthorizationUrl(): string;
    /**
     * Executes the oauth request and creates a new AuthInfo when successful
     *
     * @returns {Promise<AuthInfo>}
     */
    authorizeAndSave(): Promise<AuthInfo>;
    /**
     * Starts the web server
     */
    start(): Promise<void>;
    protected init(): Promise<void>;
    /**
     * Executes the oauth request
     *
     * @returns {Promise<AuthInfo>}
     */
    private executeOauthRequest;
    /**
     * Parses the auth code from the request url
     *
     * @param response the http response
     * @param request the http request
     * @returns {Nullable<string>}
     */
    private parseAuthCodeFromRequest;
    /**
     * Closes the request
     *
     * @param request the http request
     */
    private closeRequest;
    /**
     * Validates that the state param in the auth url matches the state
     * param in the http request
     *
     * @param request the http request
     */
    private validateState;
}
export declare namespace WebOAuthServer {
    interface Options {
        oauthConfig: OAuth2Options;
    }
    type Request = http.IncomingMessage & {
        query: {
            code: string;
            state: string;
        };
    };
}
/**
 * Handles the actions specific to the http server
 */
export declare class WebServer extends AsyncCreatable<WebServer.Options> {
    static DEFAULT_CLIENT_SOCKET_TIMEOUT: number;
    server: http.Server;
    port: number;
    host: string;
    private logger;
    private sockets;
    constructor(options: WebServer.Options);
    /**
     * Starts the http server after checking that the port is open
     */
    start(): Promise<void>;
    /**
     * Closes the http server and all open sockets
     */
    close(): void;
    /**
     * sends a response error.
     *
     * @param statusCode he statusCode for the response.
     * @param message the message for the http body.
     * @param response the response to write the error to.
     */
    sendError(status: number, message: string, response: http.ServerResponse): void;
    /**
     * sends a response redirect.
     *
     * @param statusCode the statusCode for the response.
     * @param url the url to redirect to.
     * @param response the response to write the redirect to.
     */
    doRedirect(status: number, url: string, response: http.ServerResponse): void;
    /**
     * sends a response to the browser reporting an error.
     *
     * @param error the error
     * @param response the response to write the redirect to.
     */
    reportError(error: Error, response: http.ServerResponse): void;
    protected init(): Promise<void>;
    /**
     * Make sure we can't open a socket on the localhost/host port. It's important because we don't want to send
     * auth tokens to a random strange port listener. We want to make sure we can startup our server first.
     *
     * @private
     */
    private checkOsPort;
    /**
     * check and get the socket timeout form what was set in process.env.SFDX_HTTP_SOCKET_TIMEOUT
     *
     * @returns {number} - represents the socket timeout in ms
     * @private
     */
    private getSocketTimeout;
}
declare namespace WebServer {
    interface Options {
        port?: number;
        host?: string;
    }
}
export {};
