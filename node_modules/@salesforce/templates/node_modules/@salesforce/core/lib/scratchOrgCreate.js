"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.scratchOrgCreate = exports.DEFAULT_STREAM_TIMEOUT_MINUTES = void 0;
// third
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
// Local
const org_1 = require("./org");
const logger_1 = require("./logger");
const messages_1 = require("./messages");
const sfdxError_1 = require("./sfdxError");
const connection_1 = require("./connection");
const sfdxProject_1 = require("./sfdxProject");
const configAggregator_1 = require("./config/configAggregator");
const scratchOrgInfoApi_1 = require("./scratchOrgInfoApi");
const scratchOrgSettingsGenerator_1 = require("./scratchOrgSettingsGenerator");
const scratchOrgInfoGenerator_1 = require("./scratchOrgInfoGenerator");
messages_1.Messages.importMessagesDirectory(__dirname);
const messages = messages_1.Messages.loadMessages('@salesforce/core', 'scratchOrgCreate');
exports.DEFAULT_STREAM_TIMEOUT_MINUTES = 6;
const validateDuration = (durationDays) => {
    const min = 1;
    const max = 30;
    if (Number.isInteger(durationDays)) {
        if (durationDays < min) {
            throw new sfdxError_1.SfdxError(`Expected 'durationDays' greater than or equal to ${min} but received ${durationDays}`, 'BoundsError');
        }
        if (durationDays > max) {
            throw new sfdxError_1.SfdxError(`Expected 'durationDays' less than or equal to ${max} but received ${durationDays}`, 'BoundsError');
        }
        return;
    }
    throw new sfdxError_1.SfdxError("Expected 'durationDays' to be an integer number", 'TypeError');
};
const validateRetry = (retry) => {
    if (Number.isInteger(retry)) {
        return;
    }
    throw new sfdxError_1.SfdxError("Expected 'retry' to be an integer number", 'TypeError');
};
const validateWait = (wait) => {
    const min = 2;
    if (wait.minutes < min) {
        throw new sfdxError_1.SfdxError(`Expected 'wait' greater than or equal to ${min} but received ${wait}`, 'BoundsError');
    }
};
const scratchOrgCreate = async (options) => {
    var _a;
    const logger = await logger_1.Logger.child('scratchOrgCreate');
    logger.debug('scratchOrgCreate');
    const { hubOrg, connectedAppConsumerKey, durationDays = 1, nonamespace, noancestors, wait = kit_1.Duration.minutes(exports.DEFAULT_STREAM_TIMEOUT_MINUTES), retry = 0, apiversion, definitionjson, definitionfile, orgConfig, clientSecret = undefined, } = options;
    validateDuration(durationDays);
    validateRetry(retry);
    validateWait(wait);
    const { scratchOrgInfoPayload, ignoreAncestorIds, warnings } = await scratchOrgInfoGenerator_1.getScratchOrgInfoPayload({
        definitionjson,
        definitionfile,
        connectedAppConsumerKey,
        durationDays,
        nonamespace,
        noancestors,
        orgConfig,
    });
    const scratchOrgInfo = await scratchOrgInfoGenerator_1.generateScratchOrgInfo({
        hubOrg,
        scratchOrgInfoPayload,
        nonamespace,
        ignoreAncestorIds,
    });
    // gets the scratch org settings (will use in both signup paths AND to deploy the settings)
    const settingsGenerator = new scratchOrgSettingsGenerator_1.default();
    await settingsGenerator.extract(scratchOrgInfo);
    logger.debug(`the scratch org def file has settings: ${settingsGenerator.hasSettings()}`);
    // creates the scratch org info in the devhub
    const scratchOrgInfoRequestResult = await scratchOrgInfoApi_1.requestScratchOrgCreation(hubOrg, scratchOrgInfo, settingsGenerator);
    const scratchOrgInfoId = ts_types_1.ensureString(ts_types_1.getString(scratchOrgInfoRequestResult, 'id'));
    logger.debug(`scratch org has recordId ${scratchOrgInfoId}`);
    const scratchOrgInfoResult = await scratchOrgInfoApi_1.pollForScratchOrgInfo(hubOrg, scratchOrgInfoId, wait);
    const signupTargetLoginUrlConfig = await getSignupTargetLoginUrl();
    const scratchOrgAuthInfo = await scratchOrgInfoApi_1.authorizeScratchOrg({
        scratchOrgInfoComplete: scratchOrgInfoResult,
        hubOrg,
        clientSecret,
        signupTargetLoginUrlConfig,
        retry: retry || 0,
    });
    // we'll need this scratch org connection later;
    const connection = await connection_1.Connection.create({ authInfo: scratchOrgAuthInfo });
    const scratchOrg = await org_1.Org.create({ connection }); // scartchOrg should come from command
    const username = scratchOrg.getUsername();
    logger.debug(`scratch org username ${username}`);
    const configAggregator = new configAggregator_1.ConfigAggregator();
    const authInfo = await scratchOrgInfoApi_1.deploySettingsAndResolveUrl(scratchOrgAuthInfo, (_a = apiversion !== null && apiversion !== void 0 ? apiversion : configAggregator.getPropertyValue('apiVersion')) !== null && _a !== void 0 ? _a : (await scratchOrg.retrieveMaxApiVersion()), settingsGenerator, scratchOrg);
    logger.trace('Settings deployed to org');
    /** updating the revision num to zero during org:creation if source members are created during org:create.This only happens for some specific scratch org definition file.*/
    await updateRevisionCounterToZero(scratchOrg);
    return {
        username,
        scratchOrgInfo: scratchOrgInfoResult,
        authInfo,
        authFields: authInfo === null || authInfo === void 0 ? void 0 : authInfo.getFields(),
        warnings,
    };
};
exports.scratchOrgCreate = scratchOrgCreate;
const getSignupTargetLoginUrl = async () => {
    try {
        const project = await sfdxProject_1.SfdxProject.resolve();
        const projectJson = await project.resolveProjectConfig();
        return projectJson.signupTargetLoginUrl;
    }
    catch {
        // a project isn't required for org:create
    }
};
const updateRevisionCounterToZero = async (scratchOrg) => {
    const conn = scratchOrg.getConnection();
    const queryResult = await conn.tooling.sobject('SourceMember').find({ RevisionCounter: { $gt: 0 } }, ['Id']);
    try {
        await conn.tooling
            .sobject('SourceMember')
            .update(queryResult.map((record) => ({ Id: record.Id, RevisionCounter: 0 })));
    }
    catch (err) {
        const message = messages.getMessage('SourceStatusResetFailure', [scratchOrg.getOrgId(), scratchOrg.getUsername()]);
        throw new sfdxError_1.SfdxError(message, 'SourceStatusResetFailure');
    }
};
//# sourceMappingURL=scratchOrgCreate.js.map