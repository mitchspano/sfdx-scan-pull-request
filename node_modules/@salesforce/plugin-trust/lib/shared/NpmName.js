"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NpmName = void 0;
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
/**
 * String representing the parsed components of an NpmName
 *
 * @example
 * const f: NpmName = NpmName.parse('@salesforce/jj@foo');
 * console.log(f.tag === 'foo')
 */
class NpmName {
    /**
     * Private ctor. Use static parse method.
     */
    constructor() {
        this.tag = NpmName.DEFAULT_TAG;
    }
    /**
     * Parse an NPM package name into {scope, name, tag}. The tag is 'latest' by default and can be any semver string.
     *
     * @param {string} npmName - The npm name to parse.
     * @return {NpmName} - An object with the parsed components.
     */
    static parse(npmName) {
        if (!npmName || npmName.length < 1) {
            const err = new core_1.SfError('The npm name is missing or invalid.', 'MissingOrInvalidNpmName');
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore override readonly .name field
            err.name = 'MissingOrInvalidNpmName';
            throw err;
        }
        const returnNpmName = new NpmName();
        const components = npmName.split('@');
        // salesforce/jj
        if (components.length === 1) {
            NpmName.setNameAndScope(components[0], returnNpmName);
        }
        else {
            // salesforce/jj@tag
            if (components[0].includes('/')) {
                NpmName.setNameAndScope(components[0], returnNpmName);
            }
            else {
                // @salesforce/jj@tag
                if (components[1].includes('/')) {
                    NpmName.setNameAndScope(components[1], returnNpmName);
                }
                else {
                    // Allow something like salesforcedx/pre-release
                    NpmName.setNameAndScope(components[0], returnNpmName);
                    returnNpmName.tag = components[1];
                }
            }
        }
        if (components.length > 2) {
            returnNpmName.tag = components[2];
        }
        return returnNpmName;
    }
    /**
     * Static helper to parse the name and scope.
     *
     * @param {string} name - The string to parse.
     * @param {NpmNameInfo} returnNpmName - The object to update.
     */
    static setNameAndScope(name, returnNpmName) {
        // There are at least 2 components. So there is likely a scope.
        const subComponents = name.split('/');
        if (subComponents.length === 2 && subComponents[0].trim().length > 0 && subComponents[1].trim().length > 0) {
            returnNpmName.scope = NpmName.validateComponentString(subComponents[0]);
            returnNpmName.name = NpmName.validateComponentString(subComponents[1]);
        }
        else if (subComponents.length === 1) {
            returnNpmName.name = NpmName.validateComponentString(subComponents[0]);
        }
        else {
            const err = new core_1.SfError('The npm name is invalid.', 'InvalidNpmName');
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore override readonly .name field
            err.name = 'InvalidNpmName';
            throw err;
        }
    }
    /**
     * Validate a component part that it's not empty and return it trimmed.
     *
     * @param {string} name The component to validate.
     * @return {string} A whitespace trimmed version of the component.
     */
    static validateComponentString(name) {
        const trimmedName = name.trim();
        if (trimmedName && trimmedName.length > 0) {
            return trimmedName;
        }
        else {
            const err = new core_1.SfError('The npm name is missing or invalid.', 'MissingOrInvalidNpmName');
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore override readonly .name field
            err.name = 'MissingOrInvalidNpmName';
            throw err;
        }
    }
    /**
     * Produce a string that can be used by npm. @salesforce/jj@1.2.3 becomes "salesforce-jj-1.2.3.tgz
     *
     * @param {string} [ext = tgz] The file extension to use.
     * @param {boolean} includeLatestTag - True if the "latest" tag should be used. Generally you wouldn't do this.
     * @return {string} Formatted npm string thats compatible with the npm utility
     */
    toFilename(ext = 'tgz', includeLatestTag) {
        const nameComponents = [];
        if (this.scope) {
            nameComponents.push(this.scope);
        }
        nameComponents.push(this.name);
        if (this.tag) {
            if (this.tag !== NpmName.DEFAULT_TAG) {
                nameComponents.push(this.tag);
            }
            else if (includeLatestTag) {
                nameComponents.push(this.tag);
            }
        }
        return nameComponents.join('-').concat(ext.startsWith('.') ? ext : `.${ext}`);
    }
    /**
     * Produces a formatted string version of the object.
     *
     * @return {string} A formatted string version of the object.
     */
    toString(includeTag = false) {
        const nameComponents = [];
        if (this.scope && this.scope.length > 0) {
            nameComponents.push(`@${this.scope}/`);
        }
        nameComponents.push(this.name);
        if (includeTag && this.tag && this.tag.length > 0) {
            nameComponents.push(`@${this.tag}`);
        }
        return nameComponents.join('');
    }
}
exports.NpmName = NpmName;
NpmName.DEFAULT_TAG = 'latest';
//# sourceMappingURL=NpmName.js.map