"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.doInstallationCodeSigningVerification = exports.doPrompt = exports.VerificationConfig = exports.InstallationVerification = exports.getNpmRegistry = exports.verify = exports.validSalesforceHostname = exports.CodeVerifierInfo = exports.DEFAULT_REGISTRY = exports.ALLOW_LIST_FILENAME = void 0;
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-return */
const path = require("path");
const stream_1 = require("stream");
const url_1 = require("url");
const util_1 = require("util");
const crypto = require("crypto");
const fs = require("fs");
const promises_1 = require("fs/promises");
const core_1 = require("@salesforce/core");
const request = require("request");
const npmCommand_1 = require("../shared/npmCommand");
const CRYPTO_LEVEL = 'RSA-SHA256';
exports.ALLOW_LIST_FILENAME = 'unsignedPluginAllowList.json';
exports.DEFAULT_REGISTRY = 'https://registry.npmjs.org/';
class CodeVerifierInfo {
    get dataToVerify() {
        return this.data;
    }
    set dataToVerify(value) {
        this.data = value;
    }
    get signatureStream() {
        return this.signature;
    }
    set signatureStream(value) {
        this.signature = value;
    }
    get publicKeyStream() {
        return this.publicKey;
    }
    set publicKeyStream(value) {
        this.publicKey = value;
    }
}
exports.CodeVerifierInfo = CodeVerifierInfo;
function validSalesforceHostname(url) {
    if (!url) {
        return false;
    }
    const parsedUrl = (0, url_1.parse)(url);
    if (process.env.SFDX_ALLOW_ALL_SALESFORCE_CERTSIG_HOSTING === 'true') {
        return parsedUrl.hostname && /(\.salesforce\.com)$/.test(parsedUrl.hostname);
    }
    else {
        return parsedUrl.protocol === 'https:' && parsedUrl.hostname && parsedUrl.hostname === 'developer.salesforce.com';
    }
}
exports.validSalesforceHostname = validSalesforceHostname;
function retrieveKey(stream) {
    return new Promise((resolve, reject) => {
        let key = '';
        if (stream) {
            stream.on('data', (chunk) => {
                key += chunk;
            });
            stream.on('end', () => {
                if (!key.includes('-----BEGIN')) {
                    return reject(new core_1.SfError('The specified key format is invalid.', 'InvalidKeyFormat'));
                }
                return resolve(key);
            });
            stream.on('error', (err) => {
                return reject(err);
            });
        }
    });
}
async function verify(codeVerifierInfo) {
    const publicKey = await retrieveKey(codeVerifierInfo.publicKeyStream);
    const signApi = crypto.createVerify(CRYPTO_LEVEL);
    return new Promise((resolve, reject) => {
        codeVerifierInfo.dataToVerify.pipe(signApi);
        codeVerifierInfo.dataToVerify.on('end', () => {
            // The sign signature returns a base64 encode string.
            let signature = Buffer.alloc(0);
            codeVerifierInfo.signatureStream.on('data', (chunk) => {
                signature = Buffer.concat([signature, chunk]);
            });
            codeVerifierInfo.signatureStream.on('end', () => {
                if (signature.byteLength === 0) {
                    return reject(new core_1.SfError('The provided signature is invalid or missing.', 'InvalidSignature'));
                }
                else {
                    const verification = signApi.verify(publicKey, signature.toString('utf8'), 'base64');
                    return resolve(verification);
                }
            });
            codeVerifierInfo.signatureStream.on('error', (err) => {
                return reject(err);
            });
        });
        codeVerifierInfo.dataToVerify.on('error', (err) => {
            return reject(err);
        });
    });
}
exports.verify = verify;
const getNpmRegistry = () => {
    return new url_1.URL(process.env.SFDX_NPM_REGISTRY || exports.DEFAULT_REGISTRY);
};
exports.getNpmRegistry = getNpmRegistry;
/**
 * class for verifying a digital signature pack of an npm
 */
class InstallationVerification {
    constructor(requestImpl, fsImpl) {
        // why? dependency injection is better than sinon
        this.requestImpl = requestImpl ? requestImpl : request;
        this.fsImpl = fsImpl ? fsImpl : fs;
        this.readFileAsync = (0, util_1.promisify)(this.fsImpl.readFile);
        this.unlinkAsync = (0, util_1.promisify)(this.fsImpl.unlink);
    }
    /**
     * setter for the cli engine config
     *
     * @param _config cli engine config
     */
    setConfig(_config) {
        if (_config) {
            this.config = _config;
            return this;
        }
        const err = new core_1.SfError('the cli engine config cannot be null', 'InvalidParam');
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore override readonly .name field
        err.name = 'InvalidParam';
        throw err;
    }
    /**
     * setter for the plugin name
     *
     * @param _pluginName the published plugin name
     */
    setPluginNpmName(_pluginName) {
        if (_pluginName) {
            this.pluginNpmName = _pluginName;
            return this;
        }
        const err = new core_1.SfError('pluginName must be specified.', 'InvalidParam');
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore override readonly .name field
        err.name = 'InvalidParam';
        throw err;
    }
    /**
     * validates the digital signature.
     */
    async verify() {
        const logger = await this.getLogger();
        const npmMeta = await this.streamTagGz();
        logger.debug(`verify | Found npmMeta? ${!!npmMeta}`);
        logger.debug(`verify | creating a read stream for path - npmMeta.tarballLocalPath: ${npmMeta.tarballLocalPath}`);
        const info = new CodeVerifierInfo();
        info.dataToVerify = this.fsImpl.createReadStream(npmMeta.tarballLocalPath, { encoding: 'binary' });
        logger.debug(`verify | npmMeta.signatureUrl: ${npmMeta.signatureUrl}`);
        logger.debug(`verify | npmMeta.publicKeyUrl: ${npmMeta.publicKeyUrl}`);
        return Promise.all([this.getSigningContent(npmMeta.signatureUrl), this.getSigningContent(npmMeta.publicKeyUrl)])
            .then((result) => {
            info.signatureStream = result[0];
            info.publicKeyStream = result[1];
            return verify(info);
        })
            .then((result) => {
            npmMeta.verified = result;
            return this.unlinkAsync(npmMeta.tarballLocalPath)
                .catch((err) => {
                logger.debug(`error occurred deleting cache tgz at path: ${npmMeta.tarballLocalPath}`);
                logger.debug(err);
            })
                .then(() => npmMeta);
        })
            .catch((e) => {
            if (e.code === 'DEPTH_ZERO_SELF_SIGNED_CERT') {
                const err = new core_1.SfError('Encountered a self signed certificated. To enable "export NODE_TLS_REJECT_UNAUTHORIZED=0"', 'SelfSignedCert');
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore override readonly .name field
                err.name = 'SelfSignedCert';
                throw err;
            }
            throw e;
        });
    }
    async isAllowListed() {
        const logger = await this.getLogger();
        const allowListedFilePath = path.join(this.getConfigPath(), exports.ALLOW_LIST_FILENAME);
        logger.debug(`isAllowListed | allowlistFilePath: ${allowListedFilePath}`);
        let fileContent;
        try {
            fileContent = await this.readFileAsync(allowListedFilePath);
            const allowlistArray = JSON.parse(fileContent);
            logger.debug('isAllowListed | Successfully parsed allowlist.');
            return allowlistArray && allowlistArray.includes(this.pluginNpmName.toString());
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                return false;
            }
            else {
                throw err;
            }
        }
    }
    /**
     * Retrieve url content for a host
     *
     * @param url host url.
     */
    getSigningContent(url) {
        return new Promise((resolve, reject) => {
            this.requestImpl(url, (err, response, responseData) => {
                if (err) {
                    return reject(err);
                }
                else {
                    if (response && response.statusCode === 200) {
                        // The verification api expects a readable
                        return resolve(new stream_1.Readable({
                            read() {
                                this.push(responseData);
                                this.push(null);
                            },
                        }));
                    }
                    else {
                        return reject(new core_1.SfError(`A request to url ${url} failed with error code: [${
                        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                        response ? response.statusCode : 'undefined'}]`, 'ErrorGettingContent'));
                    }
                }
            });
        });
    }
    /**
     * Downloads the tgz file content and stores it in a cache folder
     */
    async streamTagGz() {
        const logger = await this.getLogger();
        const npmMeta = await this.retrieveNpmMeta();
        const urlObject = new url_1.URL(npmMeta.tarballUrl);
        const urlPathsAsArray = urlObject.pathname.split('/');
        npmMeta.tarballFilename = npmMeta.moduleName.replace(/@/g, '');
        logger.debug(`streamTagGz | urlPathsAsArray: ${urlPathsAsArray.join(',')}`);
        const fileNameStr = urlPathsAsArray[urlPathsAsArray.length - 1];
        logger.debug(`streamTagGz | fileNameStr: ${fileNameStr}`);
        // Make sure the cache path exists.
        try {
            await (0, promises_1.mkdir)(this.getCachePath(), { recursive: true });
            const npmModule = new npmCommand_1.NpmModule(npmMeta.moduleName, npmMeta.version, this.config.cliRoot);
            await npmModule.fetchTarball((0, exports.getNpmRegistry)().href, {
                cwd: this.getCachePath(),
            });
            const tarBallFile = fs
                .readdirSync(this.getCachePath(), { withFileTypes: true })
                .find((entry) => entry.isFile() && entry.name.includes(npmMeta.version));
            npmMeta.tarballLocalPath = path.join(this.getCachePath(), tarBallFile.name);
        }
        catch (err) {
            logger.debug(err);
            throw err;
        }
        return npmMeta;
    }
    // this is generally $HOME/.config/sfdx
    getConfigPath() {
        return this.config.configDir;
    }
    // this is generally $HOME/Library/Caches/sfdx on mac
    getCachePath() {
        return this.config.cacheDir;
    }
    /**
     * Invoke npm to discover a urls for the certificate and digital signature.
     */
    async retrieveNpmMeta() {
        const logger = await this.getLogger();
        const npmRegistry = (0, exports.getNpmRegistry)();
        logger.debug(`retrieveNpmMeta | npmRegistry: ${npmRegistry.href}`);
        logger.debug(`retrieveNpmMeta | this.pluginNpmName.name: ${this.pluginNpmName.name}`);
        logger.debug(`retrieveNpmMeta | this.pluginNpmName.scope: ${this.pluginNpmName.scope}`);
        logger.debug(`retrieveNpmMeta | this.pluginNpmName.tag: ${this.pluginNpmName.tag}`);
        const npmShowModule = this.pluginNpmName.scope
            ? `@${this.pluginNpmName.scope}/${this.pluginNpmName.name}`
            : this.pluginNpmName.name;
        const npmModule = new npmCommand_1.NpmModule(npmShowModule, this.pluginNpmName.tag, this.config.cliRoot);
        const npmMetadata = npmModule.show(npmRegistry.href);
        logger.debug('retrieveNpmMeta | Found npm meta information.');
        if (!npmMetadata.versions) {
            const err = new core_1.SfError(`The npm metadata for plugin ${this.pluginNpmName.name} is missing the versions attribute.`, 'InvalidNpmMetadata');
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore override readonly .name field
            err.name = 'InvalidNpmMetadata';
            throw err;
        }
        // Assume the tag is version tag.
        let versionNumber = npmMetadata.versions.find((version) => version === this.pluginNpmName.tag);
        logger.debug(`retrieveNpmMeta | versionObject: ${JSON.stringify(versionNumber)}`);
        // If the assumption was not correct the tag must be a non-versioned dist-tag or not specified.
        if (!versionNumber) {
            // Assume dist-tag;
            const distTags = npmMetadata['dist-tags'];
            logger.debug(`retrieveNpmMeta | distTags: ${JSON.stringify(distTags)}`);
            if (distTags) {
                const tagVersionStr = distTags[this.pluginNpmName.tag];
                logger.debug(`retrieveNpmMeta | tagVersionStr: ${tagVersionStr}`);
                // if we got a dist tag hit look up the version object
                if (tagVersionStr && tagVersionStr.length > 0 && tagVersionStr.includes('.')) {
                    versionNumber = npmMetadata.versions.find((version) => version === tagVersionStr);
                    logger.debug(`retrieveNpmMeta | versionObject: ${versionNumber}`);
                }
                else {
                    const err = new core_1.SfError(`The dist tag ${this.pluginNpmName.tag} was not found for plugin: ${this.pluginNpmName.name}`, 'NpmTagNotFound');
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore override readonly .name field
                    err.name = 'NpmTagNotFound';
                    throw err;
                }
            }
            else {
                const err = new core_1.SfError('The deployed NPM is missing dist-tags.', 'UnexpectedNpmFormat');
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore override readonly .name field
                err.name = 'UnexpectedNpmFormat';
                throw err;
            }
        }
        npmModule.npmMeta.version = versionNumber;
        if (!npmMetadata.sfdx) {
            const err = new core_1.SfError('This plugin is not signed by Salesforce.com, Inc.', 'NotSigned');
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore override readonly .name field
            err.name = 'NotSigned';
            throw err;
        }
        else {
            if (!validSalesforceHostname(npmMetadata.sfdx.publicKeyUrl)) {
                const err = new core_1.SfError(`The host is not allowed to provide signing information. [${npmMetadata.sfdx.publicKeyUrl}]`, 'UnexpectedHost');
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore override readonly .name field
                err.name = 'UnexpectedHost';
                throw err;
            }
            else {
                logger.debug(`retrieveNpmMeta | versionObject.sfdx.publicKeyUrl: ${npmMetadata.sfdx.publicKeyUrl}`);
                npmModule.npmMeta.publicKeyUrl = npmMetadata.sfdx.publicKeyUrl;
            }
            if (!validSalesforceHostname(npmMetadata.sfdx.signatureUrl)) {
                const err = new core_1.SfError(`The host is not allowed to provide signing information. [${npmMetadata.sfdx.signatureUrl}]`, 'UnexpectedHost');
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore override readonly .name field
                err.name = 'UnexpectedHost';
                throw err;
            }
            else {
                logger.debug(`retrieveNpmMeta | versionObject.sfdx.signatureUrl: ${npmMetadata.sfdx.signatureUrl}`);
                npmModule.npmMeta.signatureUrl = npmMetadata.sfdx.signatureUrl;
            }
            npmModule.npmMeta.tarballUrl = npmMetadata.dist.tarball;
            logger.debug(`retrieveNpmMeta | meta.tarballUrl: ${npmModule.npmMeta.tarballUrl}`);
            return npmModule.npmMeta;
        }
    }
    async getLogger() {
        if (!this.logger) {
            this.logger = await core_1.Logger.child('InstallationVerification');
        }
        return this.logger;
    }
}
exports.InstallationVerification = InstallationVerification;
class VerificationConfig {
    get verifier() {
        return this.verifierMember;
    }
    set verifier(value) {
        this.verifierMember = value;
    }
    get log() {
        return this.logMember;
    }
    set log(value) {
        this.logMember = value;
    }
    get prompt() {
        return this.promptMember;
    }
    set prompt(value) {
        this.promptMember = value;
    }
}
exports.VerificationConfig = VerificationConfig;
async function doPrompt(vconfig) {
    const shouldContinue = await vconfig.prompt('This plugin is not digitally signed and its authenticity cannot be verified. Continue installation y/n?');
    switch (shouldContinue.toLowerCase()) {
        case 'y':
            return;
        default: {
            const err = new core_1.SfError('The user canceled the plugin installation.', 'InstallationCanceledError');
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore override readonly .name field
            err.name = 'InstallationCanceledError';
            throw err;
        }
    }
}
exports.doPrompt = doPrompt;
async function doInstallationCodeSigningVerification(config, plugin, verificationConfig) {
    try {
        const meta = await verificationConfig.verifier.verify();
        if (!meta.verified) {
            const err = new core_1.SfError("A digital signature is specified for this plugin but it didn't verify against the certificate.", 'FailedDigitalSignatureVerification');
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore override readonly .name field
            err.name = 'FailedDigitalSignatureVerification';
            throw err;
        }
        verificationConfig.log(`Successfully validated digital signature for ${plugin.plugin}.`);
    }
    catch (err) {
        if (err.name === 'NotSigned') {
            if (await verificationConfig.verifier.isAllowListed()) {
                verificationConfig.log(`The plugin [${plugin.plugin}] is not digitally signed but it is allow-listed.`);
                return;
            }
            else {
                return await doPrompt(verificationConfig);
            }
        }
        else if (err.name === 'PluginNotFound' || err.name === 'PluginAccessDenied') {
            const e = new core_1.SfError(err.message || 'The user canceled the plugin installation.');
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore override readonly .name field
            e.name = '';
            throw e;
        }
        const sfErr = core_1.SfError.wrap(err);
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore override readonly .name field
        sfErr.name = err.name;
        throw sfErr;
    }
}
exports.doInstallationCodeSigningVerification = doInstallationCodeSigningVerification;
//# sourceMappingURL=installationVerification.js.map