"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
/* eslint-disable @typescript-eslint/no-unused-vars */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NpmModule = exports.NpmCommand = void 0;
const os_1 = require("os");
const path = require("path");
const fs = require("fs");
const npm_run_path_1 = require("npm-run-path");
const shelljs = require("shelljs");
const core_1 = require("@salesforce/core");
const command_1 = require("@salesforce/command");
const kit_1 = require("@salesforce/kit");
class NpmCommand {
    static runNpmCmd(cmd, options = {}) {
        const nodeExecutable = NpmCommand.findNode(options.cliRoot);
        const npmCli = NpmCommand.npmCli();
        const command = `"${nodeExecutable}" "${npmCli}" ${cmd} --registry=${options.registry}`;
        const npmCmdResult = shelljs.exec(command, {
            ...options,
            silent: true,
            async: false,
            env: npm_run_path_1.default.env({ env: process.env }),
        });
        if (npmCmdResult.code !== 0) {
            const err = new core_1.SfError(npmCmdResult.stderr, 'ShellExecError');
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore override readonly .name field
            err.name = 'ShellExecError';
            throw err;
        }
        return npmCmdResult;
    }
    static npmPackagePath() {
        return this.npmPkgPath;
    }
    /**
     * Returns the path to the npm-cli.js file in this package's node_modules
     *
     * @private
     */
    static npmCli() {
        const pkgPath = NpmCommand.npmPackagePath();
        const fileData = fs.readFileSync(pkgPath, 'utf8');
        const pkgJson = (0, kit_1.parseJson)(fileData, pkgPath);
        const prjPath = pkgPath.substring(0, pkgPath.lastIndexOf(path.sep));
        return path.join(prjPath, pkgJson.bin['npm']);
    }
    /**
     * Locate node executable and return its absolute path
     * First it tries to locate the node executable on the root path passed in
     * If not found then tries to use whatver 'node' resolves to on the user's PATH
     * If found return absolute path to the executable
     * If the node executable cannot be found, an error is thrown
     *
     * @private
     */
    static findNode(root = undefined) {
        const isExecutable = (filepath) => {
            if ((0, os_1.type)() === 'Windows_NT')
                return filepath.endsWith('node.exe');
            try {
                if (filepath.endsWith('node')) {
                    // This checks if the filepath is executable on Mac or Linux, if it is not it errors.
                    fs.accessSync(filepath, fs.constants.X_OK);
                    return true;
                }
            }
            catch {
                return false;
            }
            return false;
        };
        if (root) {
            const sfdxBinDirs = NpmCommand.findSfdxBinDirs(root);
            if (sfdxBinDirs.length > 0) {
                // Find the node executable
                const node = shelljs.find(sfdxBinDirs).filter((file) => isExecutable(file))[0];
                if (node) {
                    return fs.realpathSync(node);
                }
            }
        }
        // Check to see if node is installed
        const nodeShellString = shelljs.which('node');
        if ((nodeShellString === null || nodeShellString === void 0 ? void 0 : nodeShellString.code) === 0 && (nodeShellString === null || nodeShellString === void 0 ? void 0 : nodeShellString.stdout))
            return nodeShellString.stdout;
        const err = new core_1.SfError('Cannot locate node executable.', 'CannotFindNodeExecutable');
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore override readonly .name field
        err.name = 'CannotFindNodeExecutable';
        throw err;
    }
    /**
     * Finds the bin directory in the sfdx installation root path
     *
     * @param sfdxPath
     * @private
     */
    static findSfdxBinDirs(sfdxPath) {
        return sfdxPath
            ? [path.join(sfdxPath, 'bin'), path.join(sfdxPath, 'client', 'bin')].filter((p) => fs.existsSync(p))
            : [];
    }
}
exports.NpmCommand = NpmCommand;
NpmCommand.npmPkgPath = require.resolve('npm/package.json');
class NpmModule {
    constructor(module, version = 'latest', cliRoot = undefined) {
        this.module = module;
        this.version = version;
        this.cliRoot = cliRoot;
        this.npmMeta = {
            moduleName: module,
        };
    }
    show(registry) {
        const showCmd = NpmCommand.runNpmCmd(`show ${this.module}@${this.version} --json`, {
            registry,
            cliRoot: this.cliRoot,
        });
        // `npm show` doesn't return exit code 1 when it fails to get a specific package version
        // If `stdout` is empty then no info was found in the registry.
        if (showCmd.stdout === '') {
            const err = new core_1.SfError(`Failed to find ${this.module}@${this.version} in the registry`, 'NpmError');
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore override readonly .name field
            err.name = 'NpmError';
            throw err;
        }
        try {
            return JSON.parse(showCmd.stdout);
        }
        catch (error) {
            const err = new core_1.SfError(error, 'ShellParseError');
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore override readonly .name field
            err.name = 'ShellParseError';
            throw err;
        }
    }
    pack(registry, options) {
        try {
            NpmCommand.runNpmCmd(`pack ${this.module}@${this.version}`, {
                ...options,
                registry,
                cliRoot: this.cliRoot,
            });
        }
        catch (err) {
            const sfErr = core_1.SfError.wrap(err);
            const e = new core_1.SfError(`Failed to fetch tarball from the registry: \n${sfErr.message}`, 'NpmError');
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore override readonly .name field
            e.name = 'NpmError';
            throw e;
        }
        return;
    }
    async fetchTarball(registry, options) {
        await this.pollForAvailability(() => {
            this.pack(registry, options);
        });
        this.pack(registry, options);
    }
    async pollForAvailability(checkFn) {
        const ux = await command_1.UX.create();
        const isNonTTY = process.env.CI !== undefined || process.env.CIRCLECI !== undefined;
        let found = false;
        let attempts = 0;
        const maxAttempts = 300;
        const start = isNonTTY ? (msg) => ux.log(msg) : (msg) => ux.startSpinner(msg);
        const update = isNonTTY ? (msg) => ux.log(msg) : (msg) => ux.setSpinnerStatus(msg);
        const stop = isNonTTY ? (msg) => ux.log(msg) : (msg) => ux.stopSpinner(msg);
        start('Polling for new version(s) to become available on npm');
        while (!found && attempts < maxAttempts) {
            attempts += 1;
            update(`attempt: ${attempts} of ${maxAttempts}`);
            try {
                checkFn();
                found = true;
            }
            catch (error) {
                if (attempts === maxAttempts) {
                    throw error;
                }
                found = false;
            }
            await (0, kit_1.sleep)(1000);
        }
        stop(attempts >= maxAttempts ? 'failed' : 'done');
    }
}
exports.NpmModule = NpmModule;
//# sourceMappingURL=npmCommand.js.map