"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Verify = void 0;
const os = require("os");
const ts_types_1 = require("@salesforce/ts-types");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const installationVerification_1 = require("../../../shared/installationVerification");
const NpmName_1 = require("../../../shared/NpmName");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-trust', 'verify');
class Verify extends command_1.SfdxCommand {
    async run() {
        this.ux.log('Checking for digital signature.');
        const npmName = NpmName_1.NpmName.parse(this.flags.npm);
        this.logger.debug(`running verify command for npm: ${npmName.name}`);
        const vConfig = new installationVerification_1.VerificationConfig();
        const configContext = {
            cacheDir: (0, ts_types_1.get)(this.config, 'cacheDir'),
            configDir: (0, ts_types_1.get)(this.config, 'configDir'),
            dataDir: (0, ts_types_1.get)(this.config, 'dataDir'),
            cliRoot: (0, ts_types_1.get)(this.config, 'root'),
        };
        this.logger.debug(`cacheDir: ${configContext.cacheDir}`);
        this.logger.debug(`configDir: ${configContext.configDir}`);
        this.logger.debug(`dataDir: ${configContext.dataDir}`);
        vConfig.verifier = this.getVerifier(npmName, configContext);
        vConfig.log = this.ux.log.bind(this.ux);
        if (this.flags.registry) {
            process.env.SFDX_NPM_REGISTRY = this.flags.registry;
        }
        try {
            const meta = await vConfig.verifier.verify();
            this.logger.debug(`meta.verified: ${meta.verified}`);
            if (!meta.verified) {
                const e = messages.createError('FailedDigitalSignatureVerification');
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore override readonly .name field
                e.name = 'FailedDigitalSignatureVerification';
                throw e;
            }
            const message = `Successfully validated digital signature for ${npmName.name}.`;
            if (!this.flags.json) {
                vConfig.log(message);
            }
            else {
                return { message, verified: true };
            }
        }
        catch (error) {
            const err = error;
            this.logger.debug(`err reported: ${JSON.stringify(err, null, 4)}`);
            const response = {
                verified: false,
                message: err.message,
            };
            if (err.name === 'NotSigned') {
                let message = err.message;
                if (await vConfig.verifier.isAllowListed()) {
                    message = `The plugin [${npmName.name}] is not digitally signed but it is allow-listed.`;
                    vConfig.log(message);
                    response.message = message;
                }
                else {
                    message = 'The plugin is not digitally signed.';
                    vConfig.log(message);
                    response.message = message;
                }
                return response;
            }
            throw core_1.SfError.wrap(err);
        }
    }
    getVerifier(npmName, config) {
        return new installationVerification_1.InstallationVerification().setPluginNpmName(npmName).setConfig(config);
    }
}
exports.Verify = Verify;
Verify.description = messages.getMessage('description');
Verify.examples = messages.getMessage('examples').split(os.EOL);
Verify.flagsConfig = {
    npm: command_1.flags.string({
        char: 'n',
        required: true,
        description: messages.getMessage('flags.npm'),
    }),
    registry: command_1.flags.string({
        char: 'r',
        required: false,
        description: messages.getMessage('flags.registry'),
    }),
};
//# sourceMappingURL=verify.js.map