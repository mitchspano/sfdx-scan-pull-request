"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Prompts = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
const chalk = require("chalk");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-auth', 'messages');
function dimMessage(message) {
    return chalk.dim(message);
}
class Prompts {
    static async shouldExitCommand(ux, noPrompt, message) {
        if (noPrompt || core_1.Global.getEnvironmentMode() !== core_1.Mode.DEMO) {
            return false;
        }
        else {
            const msg = dimMessage(message || messages.getMessage('warnAuth'));
            const answer = await ux.prompt(msg);
            return Prompts.answeredNo(answer);
        }
    }
    static async shouldRunCommand(ux, noPrompt, message) {
        if (noPrompt || core_1.Global.getEnvironmentMode() === core_1.Mode.DEMO) {
            return true;
        }
        else {
            const msg = dimMessage(message || messages.getMessage('warnAuth'));
            const answer = await ux.prompt(msg);
            return Prompts.answeredYes(answer);
        }
    }
    static async askForClientSecret(ux, disableMasking = false) {
        return Prompts.askForHiddenResponse(ux, 'clientSecretStdin', disableMasking);
    }
    static async askForAccessToken(ux, disableMasking = false) {
        return Prompts.askForHiddenResponse(ux, 'accessTokenStdin', disableMasking);
    }
    static async askOverwriteAuthFile(ux, username) {
        const yN = await ux.prompt(messages.getMessage('overwriteAccessTokenAuthUserFile', [username]), {
            type: 'normal',
            default: 'y',
        });
        return Prompts.answeredYes(yN);
    }
    static async askForHiddenResponse(ux, messageKey, disableMasking = false) {
        const msg = dimMessage(messages.getMessage(messageKey));
        return ux.prompt(msg, {
            type: disableMasking ? 'normal' : 'hide',
        });
    }
    static answeredYes(answer) {
        return ['YES', 'Y'].includes(answer.toUpperCase());
    }
    static answeredNo(answer) {
        return !['YES', 'Y'].includes(answer.toUpperCase());
    }
}
exports.Prompts = Prompts;
//# sourceMappingURL=prompts.js.map