"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
const kit_1 = require("@salesforce/kit");
const prompts_1 = require("../../../prompts");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-auth', 'accesstoken.store');
const commonMessages = core_1.Messages.loadMessages('@salesforce/plugin-auth', 'messages');
const ACCESS_TOKEN_FORMAT = '"<org id>!<accesstoken>"';
class Store extends command_1.SfdxCommand {
    async run() {
        const instanceUrl = (0, ts_types_1.ensureString)((0, ts_types_1.getString)(this.flags, 'instanceurl.href'));
        const accessToken = await this.getAccessToken();
        const authInfo = await this.getUserInfo(accessToken, instanceUrl);
        return this.storeAuthFromAccessToken(authInfo);
    }
    async getUserInfo(accessToken, instanceUrl) {
        return core_1.AuthInfo.create({ accessTokenOptions: { accessToken, instanceUrl, loginUrl: instanceUrl } });
    }
    async storeAuthFromAccessToken(authInfo) {
        if (await this.overwriteAuthInfo(authInfo.getUsername())) {
            await this.saveAuthInfo(authInfo);
            const successMsg = commonMessages.getMessage('authorizeCommandSuccess', [
                authInfo.getUsername(),
                authInfo.getFields(true).orgId,
            ]);
            this.ux.log(successMsg);
        }
        return authInfo.getFields(true);
    }
    async saveAuthInfo(authInfo) {
        await authInfo.save();
        await authInfo.handleAliasAndDefaultSettings({
            alias: this.flags.setalias,
            setDefault: this.flags.setdefaultusername,
            setDefaultDevHub: this.flags.setdefaultdevhubusername,
        });
        await core_1.AuthInfo.identifyPossibleScratchOrgs(authInfo.getFields(true), authInfo);
    }
    async overwriteAuthInfo(username) {
        if (!this.flags.noprompt) {
            const stateAggregator = await core_1.StateAggregator.getInstance();
            if (await stateAggregator.orgs.exists(username)) {
                return prompts_1.Prompts.askOverwriteAuthFile(this.ux, username);
            }
        }
        return true;
    }
    async getAccessToken() {
        let accessToken;
        if (kit_1.env.getString('SFDX_ACCESS_TOKEN')) {
            accessToken = kit_1.env.getString('SFDX_ACCESS_TOKEN');
        }
        else {
            accessToken = await prompts_1.Prompts.askForAccessToken(this.ux);
        }
        if (!core_1.sfdc.matchesAccessToken(accessToken)) {
            throw new core_1.SfError(messages.getMessage('invalidAccessTokenFormat', [ACCESS_TOKEN_FORMAT]));
        }
        return accessToken;
    }
}
exports.default = Store;
Store.description = messages.getMessage('description', [ACCESS_TOKEN_FORMAT]);
Store.examples = messages.getMessage('examples').split(os.EOL);
Store.aliases = ['force:auth:accesstoken:store'];
Store.flagsConfig = {
    instanceurl: command_1.flags.url({
        char: 'r',
        description: commonMessages.getMessage('instanceUrl'),
        required: true,
    }),
    setdefaultdevhubusername: command_1.flags.boolean({
        char: 'd',
        description: commonMessages.getMessage('setDefaultDevHub'),
        default: false,
    }),
    setdefaultusername: command_1.flags.boolean({
        char: 's',
        description: commonMessages.getMessage('setDefaultUsername'),
        default: false,
    }),
    setalias: command_1.flags.string({
        char: 'a',
        description: commonMessages.getMessage('setAlias'),
    }),
    noprompt: command_1.flags.boolean({
        char: 'p',
        description: commonMessages.getMessage('noPrompt'),
        required: false,
        default: false,
    }),
};
//# sourceMappingURL=store.js.map