"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const promises_1 = require("fs/promises");
const fs_extra_1 = require("fs-extra");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const prompts_1 = require("../../../prompts");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-auth', 'sfdxurl.store');
const commonMessages = core_1.Messages.loadMessages('@salesforce/plugin-auth', 'messages');
const AUTH_URL_FORMAT = 'force://<clientId>:<clientSecret>:<refreshToken>@<instanceUrl>';
class Store extends command_1.SfdxCommand {
    async run() {
        var _a;
        if (await prompts_1.Prompts.shouldExitCommand(this.ux, this.flags.noprompt))
            return {};
        const authFile = this.flags.sfdxurlfile;
        const sfdxAuthUrl = authFile.endsWith('.json')
            ? await this.getUrlFromJson(authFile)
            : await (0, promises_1.readFile)(authFile, 'utf8');
        if (!sfdxAuthUrl) {
            throw new Error(`Error getting the auth URL from file ${authFile}. Please ensure it meets the description shown in the documentation for this command.`);
        }
        const oauth2Options = core_1.AuthInfo.parseSfdxAuthUrl(sfdxAuthUrl);
        const authInfo = await core_1.AuthInfo.create({ oauth2Options });
        await authInfo.save();
        await authInfo.handleAliasAndDefaultSettings({
            alias: this.flags.setalias,
            setDefault: this.flags.setdefaultusername,
            setDefaultDevHub: this.flags.setdefaultdevhubusername,
        });
        const result = authInfo.getFields(true);
        // ensure the clientSecret field... even if it is empty
        result.clientSecret = (_a = result.clientSecret) !== null && _a !== void 0 ? _a : '';
        await core_1.AuthInfo.identifyPossibleScratchOrgs(result, authInfo);
        const successMsg = commonMessages.getMessage('authorizeCommandSuccess', [result.username, result.orgId]);
        this.ux.log(successMsg);
        return result;
    }
    async getUrlFromJson(authFile) {
        var _a;
        const authFileJson = (await (0, fs_extra_1.readJson)(authFile));
        return ((_a = authFileJson.result) === null || _a === void 0 ? void 0 : _a.sfdxAuthUrl) || authFileJson.sfdxAuthUrl;
    }
}
exports.default = Store;
Store.description = messages.getMessage('description', [AUTH_URL_FORMAT]);
Store.examples = messages.getMessage('examples').split(os.EOL);
Store.aliases = ['force:auth:sfdxurl:store'];
Store.flagsConfig = {
    sfdxurlfile: command_1.flags.filepath({
        char: 'f',
        description: messages.getMessage('file'),
        required: true,
    }),
    setdefaultdevhubusername: command_1.flags.boolean({
        char: 'd',
        description: commonMessages.getMessage('setDefaultDevHub'),
    }),
    setdefaultusername: command_1.flags.boolean({
        char: 's',
        description: commonMessages.getMessage('setDefaultUsername'),
    }),
    setalias: command_1.flags.string({
        char: 'a',
        description: commonMessages.getMessage('setAlias'),
    }),
    noprompt: command_1.flags.boolean({
        char: 'p',
        description: commonMessages.getMessage('noPromptAuth'),
        required: false,
        hidden: true,
    }),
};
//# sourceMappingURL=store.js.map