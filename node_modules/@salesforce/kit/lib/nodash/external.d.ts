import { AnyFunction, Dictionary, Many, Nullable, Optional } from '@salesforce/ts-types';
import { ListIteratee, NumericDictionary, ObjectIteratee, Omit, ValueIteratee, ValueIterateeCustom } from './support';
/**
 * Assigns own enumerable properties of source object(s) to the destination object for all destination
 * properties that resolve to undefined. Once a property is set, additional values of the same property are
 * ignored.
 *
 * Note: This method mutates `obj`.
 *
 * @param obj The destination object.
 * @param sources The source objects.
 */
export declare function defaults<T, S>(obj: T, source: S): S & T;
/**
 * @see defaults
 */
export declare function defaults<T, S1, S2>(obj: T, source1: S1, source2: S2): S2 & S1 & T;
/**
 * @see defaults
 */
export declare function defaults<T, S1, S2, S3>(obj: T, source1: S1, source2: S2, source3: S3): S3 & S2 & S1 & T;
/**
 * @see defaults
 */
export declare function defaults<T, S1, S2, S3, S4>(obj: T, source1: S1, source2: S2, source3: S3, source4: S4): S4 & S3 & S2 & S1 & T;
/**
 * @see defaults
 */
export declare function defaults<T>(obj: T): T;
/**
 * This method is like `find` except that it returns the key of the first element predicate returns truthy for
 * instead of the element itself.
 *
 * @param obj The object to search.
 * @param predicate The function invoked per iteration.
 */
export declare function findKey<T>(obj: Nullable<T>, predicate?: ObjectIteratee<T>): Optional<string>;
/**
 * Checks if target is in collection using SameValueZero for equality comparisons. If fromIndex is negative,
 * it’s used as the offset from the end of collection.
 *
 * @param collection The collection to search.
 * @param target The value to search for.
 * @param fromIndex The index to search from.
 */
export declare function includes<T>(collection: Nullable<ArrayLike<T> | Dictionary<T> | NumericDictionary<T>>, target: T, fromIndex?: number): boolean;
/**
 * Creates an object composed of keys generated from the results of running each element of collection through
 * iteratee. The corresponding value of each key is the last element responsible for generating the key. The
 * iteratee function is invoked with one argument: (value).
 *
 * @param collection The collection to iterate over.
 * @param iteratee The function invoked per iteration.
 */
export declare function keyBy<T>(collection: Nullable<ArrayLike<T>>, iteratee?: ValueIterateeCustom<T, PropertyKey>): Dictionary<T>;
/**
 * @see keyBy
 */
export declare function keyBy<T extends object>(collection: Nullable<T>, iteratee?: ValueIterateeCustom<T[keyof T], PropertyKey>): Dictionary<T[keyof T]>;
/**
 * This method creates an object with the same values as object and keys generated
 * by running each own enumerable property of object through iteratee.
 *
 * @param obj The object to iterate over.
 * @param iteratee The function invoked per iteration.
 */
export declare function mapKeys<T>(object: Nullable<ArrayLike<T>>, iteratee?: ListIteratee<T>): Dictionary<T>;
/**
 * @see mapKeys
 */
export declare function mapKeys<T extends object>(object: Nullable<T>, iteratee?: ObjectIteratee<T>): Dictionary<T[keyof T]>;
/**
 * This method is like `_.min` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 *
 * @param array The array to iterate over.
 * @param iteratee The iteratee invoked per element.
 */
export declare function minBy<T>(collection: Nullable<ArrayLike<T>>, iteratee?: ValueIteratee<T>): Optional<T>;
/**
 * This method is like `_.max` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 *
 * @param array The array to iterate over.
 * @param iteratee The iteratee invoked per element.
 */
export declare function maxBy<T>(collection: Nullable<ArrayLike<T>>, iteratee?: ValueIteratee<T>): Optional<T>;
/**
 * Recursively merges own and inherited enumerable properties of source
 * objects into the destination object, skipping source properties that resolve
 * to `undefined`. Array and plain object properties are merged recursively.
 * Other objects and value types are overridden by assignment. Source objects
 * are applied from left to right. Subsequent sources overwrite property
 * assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @param object The destination object.
 * @param sources The source objects.
 */
export declare function merge<T, S>(object: T, source: S): T & S;
/**
 * @see merge
 */
export declare function merge<T, S1, S2>(object: T, source1: S1, source2: S2): T & S1 & S2;
/**
 * @see merge
 */
export declare function merge<T, S1, S2, S3>(object: T, source1: S1, source2: S2, source3: S3): T & S1 & S2 & S3;
/**
 * @see merge
 */
export declare function merge<T, S1, S2, S3, S4>(object: T, source1: S1, source2: S2, source3: S3, source4: S4): T & S1 & S2 & S3 & S4;
/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable properties of `object` that are not omitted.
 *
 * @param obj The source object.
 * @param paths The property names to omit, specified individually or in arrays..
 */
export declare function omit<T extends Dictionary<unknown>>(obj: Nullable<T>, ...paths: Array<Many<PropertyKey>>): T;
/**
 * @see omit
 */
export declare function omit<T extends object, K extends keyof T>(obj: Nullable<T>, ...paths: Array<Many<K>>): Omit<T, K>;
/**
 * @see omit
 */
export declare function omit<T extends object>(obj: Nullable<T>, ...paths: Array<Many<PropertyKey>>): Partial<T>;
/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls to the function return the value
 * of the first call. The `func` is invoked with the this binding and arguments of the created function.
 *
 * @param func The function to restrict.
 */
export declare function once<T extends AnyFunction>(func: T): T;
/**
 * Sets the value at path of object. If a portion of path doesn’t exist it’s created. Arrays are created for
 * missing index properties while objects are created for all other missing properties. Use _.setWith to
 * customize path creation.
 *
 * @param obj The object to modify.
 * @param path The path of the property to set.
 * @param value The value to set.
 */
export declare function set<T extends object>(obj: T, path: string, value: unknown): T;
/**
 * @see set
 */
export declare function set<R>(obj: object, path: string, value: unknown): R;
/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection through each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @param collection The collection to iterate over.
 * @param iteratees The iteratees to sort by, specified individually or in arrays.
 */
export declare function sortBy<T>(collection: Nullable<ArrayLike<T>>, ...iteratees: Array<Many<ListIteratee<T>>>): T[];
/**
 * @see sortBy
 */
export declare function sortBy<T extends object>(collection: Nullable<T>, ...iteratees: Array<Many<ObjectIteratee<T>>>): Array<T[keyof T]>;
/**
 * Converts `value` to a number.
 *
 * @param value The value to process.
 *
 * ```
 * _.toNumber(3);
 * // => 3
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3');
 * // => 3
 * ```
 */
export declare function toNumber(value: unknown): number;
