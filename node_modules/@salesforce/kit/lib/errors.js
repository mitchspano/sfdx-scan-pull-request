"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidDefaultEnvValueError = exports.JsonDataFormatError = exports.JsonStringifyError = exports.JsonParseError = exports.NamedError = void 0;
class NamedError extends Error {
    constructor(name, messageOrCause, cause) {
        if (typeof messageOrCause === 'string') {
            super(messageOrCause);
            this.cause = cause;
        }
        else {
            super();
            this.cause = messageOrCause;
        }
        this.name = name;
    }
    get fullStack() {
        var _a, _b;
        let stack = this.stack;
        const causedStack = ((_a = this.cause) === null || _a === void 0 ? void 0 : _a.fullStack) || ((_b = this.cause) === null || _b === void 0 ? void 0 : _b.stack);
        if (causedStack) {
            stack = `${stack ? stack + '\n' : ''}Caused by: ${causedStack}`;
        }
        return stack;
    }
}
exports.NamedError = NamedError;
class JsonParseError extends NamedError {
    constructor(cause, path, line, errorPortion) {
        super('JsonParseError', JsonParseError.format(cause, path, line, errorPortion), cause);
        this.path = path;
        this.line = line;
        this.errorPortion = errorPortion;
    }
    /**
     * Creates a `JsonParseError` from a `SyntaxError` thrown during JSON parsing.
     *
     * @param error The `SyntaxError` to convert to a `JsonParseError`.
     * @param data The data input that caused the error.
     * @param jsonPath The path from which the data was read, if known.
     */
    static create(error, data, jsonPath) {
        // Get the position of the error from the error message. This is the error index
        // within the file contents as 1 long string.
        const positionMatch = /position (\d+)/.exec(error.message);
        if (!positionMatch) {
            return new JsonParseError(error, jsonPath);
        }
        const errPosition = parseInt(positionMatch[1], 10);
        // Get a buffered error portion to display.
        const BUFFER = 20;
        const start = Math.max(0, errPosition - BUFFER);
        const end = Math.min(data.length, errPosition + BUFFER);
        const errorPortion = data.slice(start, end);
        // Only need to count new lines before the error position.
        const lineNumber = data.slice(0, errPosition).split('\n').length;
        return new JsonParseError(error, jsonPath, lineNumber, errorPortion);
    }
    static format(cause, path, line, errorPortion) {
        if (line == null)
            return cause.message || 'Unknown cause';
        return `Parse error in file ${path || 'unknown'} on line ${line}\n${errorPortion || cause.message}`;
    }
}
exports.JsonParseError = JsonParseError;
class JsonStringifyError extends NamedError {
    constructor(cause) {
        super('JsonStringifyError', cause);
    }
}
exports.JsonStringifyError = JsonStringifyError;
class JsonDataFormatError extends NamedError {
    constructor(message) {
        super('JsonDataFormatError', message);
    }
}
exports.JsonDataFormatError = JsonDataFormatError;
class InvalidDefaultEnvValueError extends NamedError {
    constructor(message) {
        super('InvalidDefaultEnvValueError', message);
    }
}
exports.InvalidDefaultEnvValueError = InvalidDefaultEnvValueError;
//# sourceMappingURL=errors.js.map