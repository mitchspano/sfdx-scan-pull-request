"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelemetryReporter = exports.TelemetryClient = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os = require("os");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const axios_1 = require("axios");
const appInsights_1 = require("./appInsights");
const DISABLE_TELEMETRY = 'disableTelemetry';
var appInsights_2 = require("./appInsights");
Object.defineProperty(exports, "TelemetryClient", { enumerable: true, get: function () { return appInsights_2.TelemetryClient; } });
/**
 * Reports telemetry events to app insights. We do not send if the config 'disableTelemetry' is set.
 */
class TelemetryReporter extends kit_1.AsyncCreatable {
    constructor(options) {
        super(options);
        this.options = options;
    }
    /**
     * Determine if the telemetry event should be logged.
     * Setting the disableTelemetry config var to true will disable insights for errors and diagnostics.
     */
    static async determineSfdxTelemetryEnabled() {
        if (!TelemetryReporter.config) {
            TelemetryReporter.config = await core_1.SfdxConfigAggregator.create({});
        }
        const configValue = TelemetryReporter.config.getPropertyValue(DISABLE_TELEMETRY);
        const sfdxDisableInsights = configValue === 'true' || kit_1.env.getBoolean('SFDX_DISABLE_INSIGHTS');
        return !sfdxDisableInsights;
    }
    async init() {
        this.logger = await core_1.Logger.child('TelemetryReporter');
        if (!TelemetryReporter.config) {
            TelemetryReporter.config = await core_1.SfdxConfigAggregator.create({});
        }
        this.config = TelemetryReporter.config;
        if (this.options.waitForConnection)
            await this.waitForConnection();
        this.reporter = await appInsights_1.AppInsights.create(this.options);
    }
    /**
     * Starts data collection services. This is for long running processes. Short lived
     * processes can call send*Event directly then finish it by TelemetryReporter.stop().
     */
    start() {
        this.reporter.start();
    }
    /**
     * Immediately flush and dispose of the reporter. This can usually take 1-3 seconds
     * not counting timeouts.
     */
    stop() {
        this.reporter.stop();
    }
    async waitForConnection() {
        const canConnect = await this.testConnection();
        if (!canConnect) {
            throw new Error('Unable to connect to app insights.');
        }
    }
    async testConnection() {
        const timeout = parseInt(kit_1.env.getString('SFDX_TELEMETRY_TIMEOUT', '1000'), 10);
        this.logger.debug(`Testing connection to ${appInsights_1.AppInsights.APP_INSIGHTS_SERVER} with timeout of ${timeout} ms`);
        // set up a CancelToken to handle connection timeouts because
        // the built in timeout functionality only handles response timeouts
        // see here: https://github.com/axios/axios/issues/647#issuecomment-322209906
        const cancelRequest = axios_1.default.CancelToken.source();
        setTimeout(() => cancelRequest.cancel('connection timeout'), timeout);
        let canConnect;
        try {
            const options = {
                timeout,
                cancelToken: cancelRequest.token,
                // We want any status less than 500 to be resolved (not rejected)
                validateStatus: (status) => status < 500,
            };
            await axios_1.default.get(appInsights_1.AppInsights.APP_INSIGHTS_SERVER, options);
            canConnect = true;
        }
        catch (err) {
            canConnect = false;
        }
        if (canConnect) {
            this.logger.debug(`Successfully made a connection to ${appInsights_1.AppInsights.APP_INSIGHTS_SERVER}`);
        }
        else {
            this.logger.warn(`Connection to ${appInsights_1.AppInsights.APP_INSIGHTS_SERVER} timed out after ${timeout} ms`);
        }
        return canConnect;
    }
    /**
     * Sends message to child process.
     *
     * @param eventName {string} - name of the event you want published.
     * @param attributes {Attributes} - map of properties to publish alongside the event.
     */
    sendTelemetryEvent(eventName, attributes = {}) {
        if (this.isSfdxTelemetryEnabled()) {
            this.reporter.sendTelemetryEvent(eventName, attributes);
        }
    }
    /**
     * Sends exception to child process.
     *
     * @param exception {Error} - exception you want published.
     * @param attributes {Attributes} - map of measurements to publish alongside the event.
     */
    sendTelemetryException(exception, attributes = {}) {
        if (this.isSfdxTelemetryEnabled()) {
            // Scrub stack for GDPR
            exception.stack =
                exception.stack && exception.stack.replace(new RegExp(os.homedir(), 'g'), appInsights_1.AppInsights.GDPR_HIDDEN);
            this.reporter.sendTelemetryException(exception, attributes);
        }
    }
    /**
     * Publishes diagnostic information to app insights dashboard
     *
     * @param traceMessage {string} - trace message to sen to app insights.
     * @param properties {Properties} - map of properties to publish alongside the event.
     */
    sendTelemetryTrace(traceMessage, properties) {
        if (this.isSfdxTelemetryEnabled()) {
            this.reporter.sendTelemetryTrace(traceMessage, properties);
        }
    }
    /**
     * Publishes metric to app insights dashboard
     *
     * @param metricName {string} - name of the metric you want published
     * @param value {number} - value of the metric
     * @param properties {Properties} - map of properties to publish alongside the event.
     */
    sendTelemetryMetric(metricName, value, properties) {
        if (this.isSfdxTelemetryEnabled()) {
            this.reporter.sendTelemetryMetric(metricName, value, properties);
        }
    }
    /**
     * Determine if the telemetry event should be logged.
     * Setting the disableTelemetry config var to true will disable insights for errors and diagnostics.
     */
    isSfdxTelemetryEnabled() {
        const configValue = this.config.getPropertyValue(DISABLE_TELEMETRY);
        const sfdxDisableInsights = configValue === 'true' || kit_1.env.getBoolean('SFDX_DISABLE_INSIGHTS');
        // isEnabled = !sfdxDisableInsights
        return !sfdxDisableInsights;
    }
    logTelemetryStatus() {
        const isEnabled = this.isSfdxTelemetryEnabled();
        if (isEnabled) {
            this.logger.warn(`Telemetry is enabled. This can be disabled by running sfdx force:config:set ${DISABLE_TELEMETRY}=true`);
        }
        else {
            this.logger.warn(`Telemetry is disabled. This can be enabled by running sfdx force:config:set ${DISABLE_TELEMETRY}=false`);
        }
    }
    /**
     * Gets the underline telemetry client. This should only be used to set
     * additional options that are not exposed in the init options. This should
     * NOT be used to send events as it will by pass disabled checks.
     */
    getTelemetryClient() {
        return this.reporter.appInsightsClient;
    }
}
exports.TelemetryReporter = TelemetryReporter;
//# sourceMappingURL=telemetryReporter.js.map