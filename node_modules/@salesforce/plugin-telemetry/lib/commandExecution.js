"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandExecution = void 0;
const path_1 = require("path");
const fs = require("fs");
const core_1 = require("@oclif/core");
const core_2 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const debuger_1 = require("./debuger");
const telemetryInit_1 = require("./hooks/telemetryInit");
class CommandExecution extends kit_1.AsyncCreatable {
    constructor(options) {
        super(options);
        this.specifiedFlags = [];
        this.specifiedFlagFullNames = [];
        this.start = Date.now();
        this.command = options.command;
        this.argv = options.argv;
        this.config = options.config;
        this.upTimeAtCmdStart = process.uptime() * 1000;
    }
    /**
     * Determines whether the SFDX project is using GIT for version control or some other VCS.
     * Returns a token indicating the VCS for usage stats, or an empty string if the command
     * was executed outside of an SFDX project.
     */
    static async resolveVCSInfo() {
        let possibleVcsPath;
        try {
            possibleVcsPath = await core_2.SfProject.resolveProjectPath();
        }
        catch (err) {
            (0, debuger_1.debug)('Not in a sfdx project, using current working directory');
            possibleVcsPath = process.cwd();
        }
        const gitPath = (0, path_1.join)(possibleVcsPath, '.git');
        try {
            await fs.promises.access(gitPath, fs.constants.R_OK);
            return 'git';
        }
        catch (err) {
            return 'other';
        }
    }
    toJson() {
        const pluginInfo = this.getPluginInfo();
        return {
            eventName: 'COMMAND_EXECUTION',
            // System information
            platform: this.config.platform,
            shell: this.config.shell,
            arch: this.config.arch,
            vcs: this.vcs,
            nodeEnv: process.env.NODE_ENV,
            nodeVersion: process.version,
            processUptime: process.uptime() * 1000,
            // CLI information
            version: this.config.version,
            channel: this.config.channel,
            executable: this.config.bin,
            origin: this.config.userAgent,
            plugin: pluginInfo.name,
            // eslint-disable-next-line camelcase
            plugin_version: pluginInfo.version,
            command: this.command.id,
            // As the user specified, including short names
            specifiedFlags: this.specifiedFlags.join(' '),
            // Flags the user specified, only the full names
            specifiedFlagFullNames: this.specifiedFlagFullNames.join(' '),
            sfdxEnv: process.env.SFDX_ENV,
            s3HostOverride: process.env.SFDX_S3_HOST,
            npmRegistryOverride: process.env.SFDX_NPM_REGISTRY,
            tool: process.env.SFDX_TOOL,
            interceptorMode: process.env.INTERCEPTOR_MODE,
            // Execution information
            date: new Date().toUTCString(),
            // Don't log status or timestamp as a number, otherwise vscode will think it is a metric
            status: (0, ts_types_1.isNumber)(this.status) ? this.status.toString() : undefined,
            timestamp: String(Date.now()),
            runtime: Date.now() - this.start,
            upTimeAtCmdStart: this.upTimeAtCmdStart,
            oclifLoadTime: telemetryInit_1.InitData.upTimeAtInit,
            commandLoadTime: this.upTimeAtCmdStart - telemetryInit_1.InitData.upTimeAtInit,
            // Salesforce Information
            // Set the usernames so the uploader can resolve it to orgIds.
            // Since resolving org ids can make API calls, we want to do that in the
            // uploader process so we don't slow down the CLI.
            devHubUsername: this.devHubOrgUsername,
            orgUsername: this.orgUsername,
        };
    }
    getPluginInfo() {
        return {
            name: this.command.plugin && this.command.plugin.name,
            version: this.command.plugin && this.command.plugin.version,
        };
    }
    getCommandName() {
        return this.command.id;
    }
    async init() {
        const argv = this.argv;
        const flagDefinitions = this.command.flags || {};
        // We can't get varargs on type Class, so we need to cast to any to parse flags properly
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const anyCmd = this.command;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        const commandDef = { flags: flagDefinitions, args: this.command.args, strict: !anyCmd.varargs };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let flags = {};
        try {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            flags = (await core_1.Parser.parse(argv, commandDef)).flags;
        }
        catch (error) {
            (0, debuger_1.debug)('Error parsing flags');
        }
        this.orgUsername = flags['targetusername'];
        this.devHubOrgUsername = flags['targetdevhubusername'];
        this.determineSpecifiedFlags(argv, flags, flagDefinitions);
        this.vcs = await CommandExecution.resolveVCSInfo();
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    determineSpecifiedFlags(argv, flags, flagDefinitions) {
        // Help won't be in the parsed flags
        const shortHelp = argv.find((arg) => /^-h$/.test(arg));
        const fullHelp = argv.find((arg) => /^--help$/.test(arg));
        if (shortHelp || fullHelp) {
            if (shortHelp) {
                this.specifiedFlags.push('h');
            }
            else {
                this.specifiedFlags.push('help');
            }
            this.specifiedFlagFullNames.push('help');
            // All other flags don't matter if help is specified, so end here.
        }
        else {
            Object.keys(flags).forEach((flagName) => {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                const shortCode = flagDefinitions[flagName] && flagDefinitions[flagName].char;
                // Oclif will include the flag if there is a default, but we only want to add it if the
                // user specified it, so confirm in the argv list.
                if (shortCode && argv.find((arg) => new RegExp(`^-${shortCode}(=.*)?$`).test(arg))) {
                    this.specifiedFlags.push(shortCode);
                    this.specifiedFlagFullNames.push(flagName);
                }
                else if (argv.find((arg) => new RegExp(`^--${flagName}(=.*)?$`).test(arg))) {
                    this.specifiedFlags.push(flagName);
                    this.specifiedFlagFullNames.push(flagName);
                }
            });
        }
    }
}
exports.CommandExecution = CommandExecution;
//# sourceMappingURL=commandExecution.js.map