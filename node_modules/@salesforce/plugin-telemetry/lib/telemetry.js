"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const crypto_1 = require("crypto");
const fs = require("fs");
const os_1 = require("os");
const path_1 = require("path");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const debuger_1 = require("./debuger");
const CLI_ID_FILE_NAME = 'CLIID.txt';
const USAGE_ACKNOWLEDGEMENT_FILE_NAME = 'acknowledgedUsageCollection.json';
class Telemetry extends kit_1.AsyncCreatable {
    constructor(options) {
        super(options);
        this.firstRun = false;
        if (options.cacheDir && !Telemetry.cacheDir) {
            Telemetry.cacheDir = options.cacheDir;
        }
        // We want to run off of a specific telemetry file, so override.
        if (options.telemetryFilePath) {
            Telemetry.telemetryTmpFile = options.telemetryFilePath;
        }
        if (options.executable) {
            Telemetry.executable = options.executable;
        }
    }
    /**
     * Tell the user they acknowledge data collection.
     */
    static async acknowledgeDataCollection() {
        // Only check once per process, regardless of how often this is instantiated.
        if (Telemetry.acknowledged) {
            return;
        }
        if (!Telemetry.cacheDir) {
            (0, debuger_1.debug)('Unable to check acknowledgment path because Telemetry.cacheDir is not set yet');
            return;
        }
        const acknowledgementFilePath = (0, path_1.join)(Telemetry.cacheDir, USAGE_ACKNOWLEDGEMENT_FILE_NAME);
        try {
            await fs.promises.access(acknowledgementFilePath, fs.constants.R_OK);
            (0, debuger_1.debug)('Usage acknowledgement file already exists');
        }
        catch (error) {
            const err = error;
            if (err.code === 'ENOENT') {
                if (!kit_1.env.getBoolean('SFDX_TELEMETRY_DISABLE_ACKNOWLEDGEMENT', false)) {
                    // eslint-disable-next-line no-console
                    console.warn(`You acknowledge and agree that the CLI tool may collect usage information, user environment, and crash reports for the purposes of providing services or functions that are relevant to use of the CLI tool and product improvements.${os_1.EOL}`);
                }
                Telemetry.acknowledged = true;
                await fs.promises.mkdir(Telemetry.cacheDir, { recursive: true });
                await fs.promises.writeFile(acknowledgementFilePath, JSON.stringify({ acknowledged: true }));
                (0, debuger_1.debug)('Wrote usage acknowledgement file', acknowledgementFilePath);
            }
            else {
                (0, debuger_1.debug)('Could not access', acknowledgementFilePath, 'DUE TO:', err.code, err.message);
            }
        }
    }
    // eslint-disable-next-line complexity
    static guessCISystem() {
        const keys = Object.keys(process.env);
        if (keys.find((key) => key.startsWith('CIRCLE'))) {
            return 'circleci';
        }
        if (keys.find((key) => key.startsWith('TRAVIS'))) {
            return 'travisci';
        }
        if (keys.find((key) => key.startsWith('BITBUCKET'))) {
            return 'bitbucket';
        }
        if (keys.find((key) => key.startsWith('CIRRUS'))) {
            return 'cirrus';
        }
        if (keys.find((key) => key.startsWith('HEROKU_TEST_RUN_ID'))) {
            return 'heroku';
        }
        if (keys.find((key) => key.startsWith('bamboo') || key.startsWith('BAMBOO'))) {
            return 'bamboo';
        }
        if (keys.find((key) => key.startsWith('CODEBUILD'))) {
            return 'codebuild';
        }
        if (keys.find((key) => key.startsWith('GITHUB_ACTION'))) {
            return 'github_actions';
        }
        if (keys.find((key) => key.startsWith('AGENT_NAME')) || keys.find((key) => key.startsWith('BUILD_BUILDNUMBER'))) {
            return 'azure_pipelines';
        }
        if (keys.find((key) => key.startsWith('TEAMCITY'))) {
            return 'teamcity';
        }
        if (keys.find((key) => key.startsWith('GITLAB'))) {
            return 'gitlab';
        }
        if (keys.find((key) => key.startsWith('NEVERCODE'))) {
            return 'nevercode';
        }
        if (keys.find((key) => key.startsWith('WERCKER'))) {
            return 'wercker';
        }
        if (keys.find((key) => key.startsWith('BUILDKITE'))) {
            return 'buildkite';
        }
        if (keys.find((key) => key.startsWith('SEMAPHORE'))) {
            return 'semaphore';
        }
        if (keys.find((key) => key.startsWith('BITRISE'))) {
            return 'bitrise';
        }
        if (keys.find((key) => key.startsWith('BUDDY'))) {
            return 'buddy';
        }
        if (keys.find((key) => key.startsWith('APPVEYOR'))) {
            return 'appveyor';
        }
        if (keys.find((key) => key.startsWith('JENKINS'))) {
            return 'jenkins';
        }
        if (keys.find((key) => key.startsWith('HUDSON'))) {
            return 'hudson';
        }
        if (keys.find((key) => key === 'CI' || key === 'CONTINUOUS_INTEGRATION' || key === 'BUILD_ID')) {
            return 'unknown';
        }
    }
    static generateRandomId() {
        return (0, crypto_1.randomBytes)(20).toString('hex');
    }
    getTelemetryFilePath() {
        return Telemetry.telemetryTmpFile;
    }
    getCLIId() {
        if (this.cliId)
            return this.cliId;
        const cliIdPath = (0, path_1.join)(Telemetry.cacheDir, CLI_ID_FILE_NAME);
        try {
            this.cliId = fs.readFileSync(cliIdPath, 'utf8');
        }
        catch (err) {
            (0, debuger_1.debug)('Unique CLI ID not found, generating and writing new ID to ', cliIdPath);
            this.cliId = Telemetry.generateRandomId();
            fs.writeFileSync(cliIdPath, this.cliId, 'utf8');
            // If there is not a unique ID for this CLI, consider it a first run.
            this.firstRun = true;
        }
        return this.cliId;
    }
    /**
     * Record data to the telemetry file. Only valid properties will be recorded to the file, which
     * are strings, numbers, and booleans. All booleans get logged to App Insights as string representations.
     */
    record(data) {
        // Only store valid telemetry attributes to the log file.
        const dataToRecord = Object.keys(data).reduce((map, key) => {
            const value = data[key];
            const isException = data.type === Telemetry.EXCEPTION && key === 'error';
            const validType = (0, ts_types_1.isString)(value) || (0, ts_types_1.isBoolean)(value) || (0, ts_types_1.isNumber)(value);
            if (isException || validType) {
                map[key] = value;
            }
            return map;
        }, {});
        if (!dataToRecord.type) {
            dataToRecord.type = Telemetry.EVENT;
        }
        if (!dataToRecord.eventName) {
            // This would mean a consumer forgot to set this.
            // Still log it as unknown so we can try to fix it.
            dataToRecord.eventName = 'UNKNOWN';
            // Don't break this into a utility because the stack HAS to start from this method.
            const stack = new Error().stack || '';
            const locations = stack.split(/\r?\n/).filter((line) => /\s*at /.test(line));
            if (locations.length >= 2) {
                // The first location is this file, the second is the calling file.
                // Replace HOME for GDPR.
                dataToRecord.requestorLocation = locations[1].replace(process.env.HOME || '', '');
            }
            (0, debuger_1.debug)('Missing event name!');
        }
        // Unique to this CLI installation
        dataToRecord.cliId = this.getCLIId();
        dataToRecord.ci = Telemetry.guessCISystem();
        dataToRecord.executable = Telemetry.executable;
        try {
            fs.writeSync(this.fileDescriptor, JSON.stringify(dataToRecord) + os_1.EOL);
        }
        catch (err) {
            const error = err;
            (0, debuger_1.debug)(`Error saving telemetry line to file: ${error.message}`);
        }
    }
    recordError(error, data) {
        data.type = Telemetry.EXCEPTION;
        // Also have on custom attributes since app insights might parse differently
        data.errorName = error.name;
        data.errorMessage = error.message;
        data.error = Object.assign({
            name: error.name,
            message: error.message,
            stack: error.stack,
        }, error);
        this.record(data);
    }
    async clear() {
        (0, debuger_1.debug)('Deleting the log file', this.getTelemetryFilePath());
        await fs.promises.unlink(this.getTelemetryFilePath());
    }
    async read() {
        try {
            (0, debuger_1.debug)(`Reading ${this.getTelemetryFilePath()}`);
            const data = await fs.promises.readFile(this.getTelemetryFilePath(), 'utf8');
            return data
                .split(os_1.EOL)
                .filter((line) => !!line)
                .map((line) => JSON.parse(line));
        }
        catch (error) {
            const err = error;
            (0, debuger_1.debug)(`Error reading: ${err.message}`);
            // If anything goes wrong, it just means a couple of lost telemetry events.
            return [];
        }
    }
    upload() {
        // Completely disconnect from this process so it doesn't wait for telemetry to upload
        const processPath = (0, path_1.join)(__dirname, '..', 'processes', 'upload');
        const telemetryDebug = kit_1.env.getBoolean('SFDX_TELEMETRY_DEBUG', false);
        const nodePath = process.argv[0];
        // Don't spawn if we are in telemetry debug. This allows us to run the process manually with --inspect-brk.
        if (!telemetryDebug) {
            (0, debuger_1.debug)(`Spawning "${nodePath} ${processPath} ${Telemetry.cacheDir} ${this.getTelemetryFilePath()}"`);
            (0, child_process_1.spawn)(nodePath, [processPath, Telemetry.cacheDir, this.getTelemetryFilePath()], {
                detached: true,
                stdio: 'ignore',
            }).unref();
        }
        else {
            (0, debuger_1.debug)(
            // eslint-disable-next-line prettier/prettier
            `DEBUG MODE. Run the uploader manually with the following command:${os_1.EOL}${processPath} ${Telemetry.cacheDir} ${this.getTelemetryFilePath()}`);
        }
    }
    async init() {
        // If we are going to record telemetry, make sure the user is aware.
        await Telemetry.acknowledgeDataCollection();
        // Make sure the tmp dir is created.
        try {
            await fs.promises.access(Telemetry.tmpDir, fs.constants.W_OK);
        }
        catch (error) {
            const err = error;
            if (err.code === 'ENOENT') {
                (0, debuger_1.debug)('Telemetry temp dir does not exist, creating...');
                await fs.promises.mkdir(Telemetry.tmpDir, { recursive: true });
            }
        }
        // Create a file descriptor to be used
        this.fileDescriptor = fs.openSync(this.getTelemetryFilePath(), 'a');
        (0, debuger_1.debug)(`Using telemetry logging file ${this.getTelemetryFilePath()}`);
    }
}
exports.default = Telemetry;
/**
 * The name of event telemetry type.
 */
Telemetry.EVENT = 'EVENT';
/**
 * The name of exception telemetry type.
 */
Telemetry.EXCEPTION = 'EXCEPTION';
/**
 * The temporary directory where telemetry log files are stored.
 */
Telemetry.tmpDir = kit_1.env.getString('SFDX_TELEMETRY_PATH', (0, path_1.join)((0, os_1.tmpdir)(), 'sfdx-telemetry'));
Telemetry.executable = 'sfdx';
Telemetry.telemetryTmpFile = (0, path_1.join)(Telemetry.tmpDir, `telemetry-${Telemetry.generateRandomId()}.log`);
Telemetry.acknowledged = false;
//# sourceMappingURL=telemetry.js.map