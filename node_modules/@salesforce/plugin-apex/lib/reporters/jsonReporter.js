"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonReporter = void 0;
const skippedProperties = ['skipRate', 'coveredLines', 'totalLines'];
const timeProperties = [
    'testExecutionTimeInMs',
    'testTotalTimeInMs',
    'commandTimeInMs'
];
class JsonReporter {
    format(result) {
        return Object.assign({ summary: this.formatSummary(result), tests: this.formatTestResults(result.tests) }, (result.codecoverage
            ? {
                coverage: this.formatCoverage(result)
            }
            : {}));
    }
    formatSummary(testResult) {
        const summary = {};
        Object.entries(testResult.summary).forEach(([key, value]) => {
            if (skippedProperties.includes(key)) {
                return;
            }
            if (timeProperties.includes(key)) {
                key = key.replace('InMs', '');
                value = `${value} ms`;
            }
            Object.assign(summary, { [key]: value });
        });
        return summary;
    }
    formatTestResults(testResults) {
        return testResults.map(test => {
            return {
                Id: test.id,
                QueueItemId: test.queueItemId,
                StackTrace: test.stackTrace,
                Message: test.message,
                AsyncApexJobId: test.asyncApexJobId,
                MethodName: test.methodName,
                Outcome: test.outcome,
                ApexClass: {
                    Id: test.apexClass.id,
                    Name: test.apexClass.name,
                    NamespacePrefix: test.apexClass.namespacePrefix
                },
                RunTime: test.runTime,
                FullName: test.fullName
            };
        });
    }
    formatCoverage(testResult) {
        const formattedCov = {
            coverage: [],
            records: [],
            summary: {
                totalLines: testResult.summary.totalLines,
                coveredLines: testResult.summary.coveredLines,
                orgWideCoverage: testResult.summary.orgWideCoverage,
                testRunCoverage: testResult.summary.testRunCoverage
            }
        };
        if (testResult.codecoverage) {
            formattedCov.coverage = testResult.codecoverage.map(cov => {
                const lines = {};
                cov.coveredLines.forEach(covLine => (lines[covLine] = 1));
                cov.uncoveredLines.forEach(uncovLine => (lines[uncovLine] = 0));
                return {
                    id: cov.apexId,
                    name: cov.name,
                    totalLines: cov.numLinesCovered + cov.numLinesUncovered,
                    lines,
                    totalCovered: cov.numLinesCovered,
                    coveredPercent: parseInt(cov.percentage)
                };
            });
            testResult.tests.forEach(test => {
                if (test.perClassCoverage) {
                    test.perClassCoverage.forEach(perClassCov => {
                        formattedCov.records.push(Object.assign(Object.assign({ ApexTestClass: { Id: test.id, Name: test.apexClass.name } }, (perClassCov.coverage
                            ? { Coverage: perClassCov.coverage }
                            : {})), { TestMethodName: test.methodName, NumLinesCovered: perClassCov.numLinesCovered, ApexClassOrTrigger: {
                                Id: perClassCov.apexClassOrTriggerId,
                                Name: perClassCov.apexClassOrTriggerName
                            }, NumLinesUncovered: perClassCov.numLinesUncovered }));
                    });
                }
            });
        }
        return formattedCov;
    }
}
exports.JsonReporter = JsonReporter;
//# sourceMappingURL=jsonReporter.js.map