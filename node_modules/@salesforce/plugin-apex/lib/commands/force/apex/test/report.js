"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const apex_node_1 = require("@salesforce/apex-node");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const reporters_1 = require("../../../../reporters");
const utils_1 = require("../../../../utils");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/plugin-apex', 'report', [
    'apexLibErr',
    'apexTestReportFormatHint',
    'codeCoverageDescription',
    'commandDescription',
    'jsonDescription',
    'logLevelDescription',
    'logLevelLongDescription',
    'longDescription',
    'outputDirectoryDescription',
    'outputDirHint',
    'resultFormatLongDescription',
    'testResultProcessErr',
    'testRunIdDescription',
    'verboseDescription',
    'waitDescription',
    'warningMessage'
]);
class Report extends command_1.SfdxCommand {
    run() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.flags.outputdir) {
                this.ux.warn(messages.getMessage('warningMessage'));
            }
            // add listener for errors
            process.on('uncaughtException', err => {
                const formattedErr = this.formatError(new core_1.SfError(messages.getMessage('apexLibErr', [err.message])));
                this.ux.error(...formattedErr);
                process.exit();
            });
            if (!this.org) {
                throw Error('Unable to get connection from Org.');
            }
            // org is guaranteed by requiresUsername field
            const conn = this.org.getConnection();
            const testService = new apex_node_1.TestService(conn);
            const result = yield testService.reportAsyncResults(this.flags.testrunid, this.flags.codecoverage);
            const jsonOutput = this.formatResultInJson(result);
            if (this.flags.outputdir) {
                const outputDirConfig = (0, reporters_1.buildOutputDirConfig)(result, jsonOutput, this.flags.outputdir, this.flags.resultformat, true);
                yield testService.writeResultFiles(result, outputDirConfig, this.flags.codecoverage);
            }
            try {
                if (result.summary.outcome === "Failed" /* Failed */) {
                    process.exitCode = utils_1.FAILURE_EXIT_CODE;
                }
                switch (this.flags.resultformat) {
                    case 'tap':
                        this.logTap(result);
                        break;
                    case 'junit':
                        this.logJUnit(result);
                        break;
                    case 'json':
                        // when --json flag is specified, we should log CLI json format
                        if (!this.flags.json) {
                            this.ux.logJson({
                                status: process.exitCode,
                                result: jsonOutput
                            });
                        }
                        break;
                    default:
                        this.logHuman(result, true, this.flags.outputdir);
                }
            }
            catch (e) {
                this.ux.logJson(jsonOutput);
                const msg = messages.getMessage('testResultProcessErr', [
                    e.message
                ]);
                this.ux.error(msg);
            }
            return jsonOutput;
        });
    }
    logHuman(result, detailedCoverage, outputDir) {
        if (outputDir) {
            this.ux.log(messages.getMessage('outputDirHint', [outputDir]));
        }
        const humanReporter = new apex_node_1.HumanReporter();
        const output = humanReporter.format(result, detailedCoverage);
        this.ux.log(output);
    }
    logTap(result) {
        const reporter = new apex_node_1.TapReporter();
        const hint = this.formatReportHint(result);
        this.ux.log(reporter.format(result, [hint]));
    }
    logJUnit(result) {
        const reporter = new apex_node_1.JUnitReporter();
        this.ux.log(reporter.format(result));
    }
    formatResultInJson(result) {
        try {
            const reporter = new reporters_1.JsonReporter();
            return reporter.format(result);
        }
        catch (e) {
            this.ux.logJson(result);
            const msg = messages.getMessage('testResultProcessErr', [
                e.message
            ]);
            this.ux.error(msg);
            throw e;
        }
    }
    formatReportHint(result) {
        let reportArgs = `-i ${result.summary.testRunId}`;
        if (this.flags.targetusername) {
            reportArgs += ` -u ${this.flags.targetusername}`;
        }
        const hint = messages.getMessage('apexTestReportFormatHint', [reportArgs]);
        return hint;
    }
}
exports.default = Report;
Report.requiresUsername = true;
Report.description = (0, utils_1.buildDescription)(messages.getMessage('commandDescription'), messages.getMessage('longDescription'));
Report.longDescription = messages.getMessage('longDescription');
Report.examples = [
    `$ sfdx force:apex:test:report -i <test run id>`,
    `$ sfdx force:apex:test:report -i <test run id> -r junit`,
    `$ sfdx force:apex:test:report -i <test run id> -c --json`,
    `$ sfdx force:apex:test:report -i <test run id> -c -d <path to outputdir> -u me@myorg`
];
Report.flagsConfig = {
    testrunid: command_1.flags.string({
        char: 'i',
        description: messages.getMessage('testRunIdDescription'),
        required: true
    }),
    json: command_1.flags.boolean({
        description: messages.getMessage('jsonDescription')
    }),
    loglevel: command_1.flags.enum({
        description: messages.getMessage('logLevelDescription'),
        longDescription: messages.getMessage('logLevelLongDescription'),
        default: 'warn',
        options: utils_1.logLevels
    }),
    apiversion: command_1.flags.builtin(),
    codecoverage: command_1.flags.boolean({
        char: 'c',
        description: messages.getMessage('codeCoverageDescription')
    }),
    outputdir: command_1.flags.string({
        char: 'd',
        description: messages.getMessage('outputDirectoryDescription')
    }),
    resultformat: command_1.flags.enum({
        char: 'r',
        description: messages.getMessage('resultFormatLongDescription'),
        options: utils_1.resultFormat
    }),
    wait: command_1.flags.string({
        char: 'w',
        description: messages.getMessage('waitDescription')
    }),
    verbose: command_1.flags.builtin({
        description: messages.getMessage('verboseDescription')
    })
};
//# sourceMappingURL=report.js.map