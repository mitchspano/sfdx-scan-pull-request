"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestLevelValues = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const apex_node_1 = require("@salesforce/apex-node");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const reporters_1 = require("../../../../reporters");
const utils_1 = require("../../../../utils");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/plugin-apex', 'run', [
    'apexLibErr',
    'apexTestReportFormatHint',
    'classNamesDescription',
    'classSuiteTestErr',
    'codeCoverageDescription',
    'commandDescription',
    'detailedCoverageDescription',
    'jsonDescription',
    'logLevelDescription',
    'logLevelLongDescription',
    'longDescription',
    'missingReporterErr',
    'outputDirectoryDescription',
    'outputDirHint',
    'resultFormatLongDescription',
    'runTestReportCommand',
    'suiteNamesDescription',
    'syncClassErr',
    'synchronousDescription',
    'testLevelDescription',
    'testLevelErr',
    'testResultProcessErr',
    'testsDescription',
    'verboseDescription',
    'waitDescription',
    'warningMessage'
]);
exports.TestLevelValues = [
    'RunLocalTests',
    'RunAllTestsInOrg',
    'RunSpecifiedTests'
];
class Run extends command_1.SfdxCommand {
    constructor() {
        super(...arguments);
        this.cancellationTokenSource = new apex_node_1.CancellationTokenSource();
    }
    run() {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.validateFlags();
            if (this.flags.outputdir) {
                this.ux.warn(messages.getMessage('warningMessage'));
            }
            // add listener for errors
            process.on('uncaughtException', err => {
                const formattedErr = this.formatError(new core_1.SfError(messages.getMessage('apexLibErr', [err.message])));
                this.ux.error(...formattedErr);
                process.exit();
            });
            // graceful shutdown
            const exitHandler = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield this.cancellationTokenSource.asyncCancel();
                process.exit();
            });
            process.on('SIGINT', exitHandler);
            process.on('SIGTERM', exitHandler);
            const testLevel = this.getTestLevelfromFlags();
            // org is guaranteed by requiresUsername field
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const conn = this.org.getConnection();
            const testService = new apex_node_1.TestService(conn);
            let result;
            // NOTE: This is a *bug*. Synchronous test runs should throw an error when multiple test classes are specified
            // This was re-introduced due to https://github.com/forcedotcom/salesforcedx-vscode/issues/3154
            // Address with W-9163533
            if (this.flags.synchronous && testLevel === "RunSpecifiedTests" /* RunSpecifiedTests */) {
                const payload = yield testService.buildSyncPayload(testLevel, this.flags.tests, this.flags.classnames);
                payload.skipCodeCoverage = this.flags.codecoverage ? false : true;
                result = (yield testService.runTestSynchronous(payload, this.flags.codecoverage, this.cancellationTokenSource.token));
            }
            else {
                const payload = yield testService.buildAsyncPayload(testLevel, this.flags.tests, this.flags.classnames, this.flags.suitenames);
                payload.skipCodeCoverage = this.flags.codecoverage ? false : true;
                const reporter = undefined;
                result = yield testService.runTestAsynchronous(payload, this.flags.codecoverage, this.shouldImmediatelyReturn(), reporter, this.cancellationTokenSource.token);
            }
            if (this.cancellationTokenSource.token.isCancellationRequested) {
                return null;
            }
            if (this.flags.outputdir) {
                const jsonOutput = this.formatResultInJson(result);
                const outputDirConfig = (0, reporters_1.buildOutputDirConfig)(result, jsonOutput, this.flags.outputdir, this.flags.resultformat, this.flags.detailedcoverage, this.flags.synchronous);
                yield testService.writeResultFiles(result, outputDirConfig, this.flags.codecoverage);
            }
            try {
                if (result.hasOwnProperty('summary') &&
                    result.summary.outcome ===
                        "Failed" /* Failed */) {
                    process.exitCode = utils_1.FAILURE_EXIT_CODE;
                }
                switch (this.flags.resultformat) {
                    case 'human':
                        this.logHuman(result, this.flags.detailedcoverage, this.flags.outputdir);
                        break;
                    case 'tap':
                        this.logTap(result);
                        break;
                    case 'junit':
                        this.logJUnit(result);
                        break;
                    case 'json':
                        // when --json flag is specified, we should log CLI json format
                        if (!this.flags.json) {
                            this.ux.logJson({
                                status: process.exitCode,
                                result: this.formatResultInJson(result)
                            });
                        }
                        break;
                    default:
                        if (this.flags.synchronous || this.flags.wait) {
                            this.logHuman(result, this.flags.detailedcoverage, this.flags.outputdir);
                        }
                        else {
                            const id = result.testRunId;
                            this.ux.log(messages.getMessage('runTestReportCommand', [
                                id,
                                (_a = this.org) === null || _a === void 0 ? void 0 : _a.getUsername()
                            ]));
                        }
                }
            }
            catch (e) {
                this.ux.logJson(result);
                const msg = messages.getMessage('testResultProcessErr', [
                    e.message
                ]);
                this.ux.error(msg);
            }
            return this.formatResultInJson(result);
        });
    }
    validateFlags() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.flags.codecoverage && !this.flags.resultformat) {
                return Promise.reject(new Error(messages.getMessage('missingReporterErr')));
            }
            if ((this.flags.classnames && (this.flags.suitenames || this.flags.tests)) ||
                (this.flags.suitenames && this.flags.tests)) {
                return Promise.reject(new Error(messages.getMessage('classSuiteTestErr')));
            }
            if (this.flags.synchronous &&
                (this.flags.suitenames ||
                    (this.flags.classnames && this.flags.classnames.split(',').length > 1))) {
                return Promise.reject(new Error(messages.getMessage('syncClassErr')));
            }
            if ((this.flags.tests || this.flags.classnames || this.flags.suitenames) &&
                this.flags.testlevel &&
                this.flags.testlevel !== 'RunSpecifiedTests') {
                return Promise.reject(new Error(messages.getMessage('testLevelErr')));
            }
        });
    }
    getTestLevelfromFlags() {
        let testLevel;
        if (this.flags.testlevel) {
            testLevel = this.flags.testlevel;
        }
        else if (this.flags.classnames ||
            this.flags.suitenames ||
            this.flags.tests) {
            testLevel = "RunSpecifiedTests" /* RunSpecifiedTests */;
        }
        else {
            testLevel = "RunLocalTests" /* RunLocalTests */;
        }
        return testLevel;
    }
    logHuman(result, detailedCoverage, outputDir) {
        if (outputDir) {
            this.ux.log(messages.getMessage('outputDirHint', [outputDir]));
        }
        const humanReporter = new apex_node_1.HumanReporter();
        const output = humanReporter.format(result, detailedCoverage);
        this.ux.log(output);
    }
    logTap(result) {
        const reporter = new apex_node_1.TapReporter();
        const hint = this.formatReportHint(result);
        this.ux.log(reporter.format(result, [hint]));
    }
    logJUnit(result) {
        const reporter = new apex_node_1.JUnitReporter();
        this.ux.log(reporter.format(result));
    }
    formatResultInJson(result) {
        try {
            const reporter = new reporters_1.JsonReporter();
            return result.hasOwnProperty('summary')
                ? reporter.format(result)
                : result;
        }
        catch (e) {
            this.ux.logJson(result);
            const msg = messages.getMessage('testResultProcessErr', [
                e.message
            ]);
            this.ux.error(msg);
            throw e;
        }
    }
    formatReportHint(result) {
        let reportArgs = `-i ${result.summary.testRunId}`;
        if (this.flags.targetusername) {
            reportArgs += ` -u ${this.flags.targetusername}`;
        }
        const hint = messages.getMessage('apexTestReportFormatHint', [reportArgs]);
        return hint;
    }
    /**
     * Handles special exceptions where we don't want to return early
     * with the testRunId.
     **/
    shouldImmediatelyReturn() {
        if (this.flags.resultformat !== undefined) {
            return false;
        }
        // when the user has explictly asked to wait for results, but didn't give a format
        if (this.flags.wait) {
            return false;
        }
        //historical expectation to wait for results from a synchronous test run
        if (this.flags.synchronous && !this.flags.json) {
            return false;
        }
        return true;
    }
}
exports.default = Run;
Run.requiresUsername = true;
Run.description = (0, utils_1.buildDescription)(messages.getMessage('commandDescription'), messages.getMessage('longDescription'));
Run.longDescription = messages.getMessage('longDescription');
Run.examples = [
    `$ sfdx force:apex:test:run`,
    `$ sfdx force:apex:test:run -n "MyClassTest,MyOtherClassTest" -r human`,
    `$ sfdx force:apex:test:run -s "MySuite,MyOtherSuite" -c -v --json`,
    `$ sfdx force:apex:test:run -t "MyClassTest.testCoolFeature,MyClassTest.testAwesomeFeature,AnotherClassTest,namespace.TheirClassTest.testThis" -r human`,
    `$ sfdx force:apex:test:run -l RunLocalTests -d <path to outputdir> -u me@my.org`
];
Run.flagsConfig = {
    json: command_1.flags.boolean({
        description: messages.getMessage('jsonDescription')
    }),
    loglevel: command_1.flags.enum({
        description: messages.getMessage('logLevelDescription'),
        longDescription: messages.getMessage('logLevelLongDescription'),
        default: 'warn',
        options: utils_1.logLevels
    }),
    apiversion: command_1.flags.builtin(),
    codecoverage: command_1.flags.boolean({
        char: 'c',
        description: messages.getMessage('codeCoverageDescription')
    }),
    outputdir: command_1.flags.string({
        char: 'd',
        description: messages.getMessage('outputDirectoryDescription')
    }),
    testlevel: command_1.flags.enum({
        char: 'l',
        description: messages.getMessage('testLevelDescription'),
        options: exports.TestLevelValues
    }),
    classnames: command_1.flags.string({
        char: 'n',
        description: messages.getMessage('classNamesDescription')
    }),
    resultformat: command_1.flags.enum({
        char: 'r',
        description: messages.getMessage('resultFormatLongDescription'),
        options: utils_1.resultFormat
    }),
    suitenames: command_1.flags.string({
        char: 's',
        description: messages.getMessage('suiteNamesDescription')
    }),
    tests: command_1.flags.string({
        char: 't',
        description: messages.getMessage('testsDescription')
    }),
    wait: command_1.flags.string({
        char: 'w',
        description: messages.getMessage('waitDescription')
    }),
    synchronous: command_1.flags.boolean({
        char: 'y',
        description: messages.getMessage('synchronousDescription')
    }),
    verbose: command_1.flags.builtin({
        description: messages.getMessage('verboseDescription')
    }),
    detailedcoverage: command_1.flags.boolean({
        char: 'v',
        description: messages.getMessage('detailedCoverageDescription'),
        dependsOn: ['codecoverage']
    })
};
//# sourceMappingURL=run.js.map