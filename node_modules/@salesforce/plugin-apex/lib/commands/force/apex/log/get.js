"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const apex_node_1 = require("@salesforce/apex-node");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const utils_1 = require("../../../../utils");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/plugin-apex', 'get', [
    'commandDescription',
    'jsonDescription',
    'logIDDescription',
    'logLevelDescription',
    'logLevelLongDescription',
    'longDescription',
    'noResultsFound',
    'numberDescription',
    'outputDirDescription',
    'outputDirLongDescription'
]);
class Get extends command_1.SfdxCommand {
    run() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.org) {
                    throw Error('Unable to get connection from Org.');
                }
                // org is guaranteed by requiresUsername field
                const conn = this.org.getConnection();
                const logService = new apex_node_1.LogService(conn);
                if (!this.flags.logid && !this.flags.number) {
                    this.flags.number = 1;
                }
                const logResults = yield logService.getLogs({
                    logId: this.flags.logid,
                    numberOfLogs: this.flags.number,
                    outputDir: this.flags.outputdir
                });
                if (logResults.length === 0) {
                    this.ux.log(messages.getMessage('noResultsFound'));
                    return [];
                }
                if (this.flags.outputdir) {
                    this.ux.log(`Log files written to ${this.flags.outputdir}`);
                    return logResults.map(logResult => logResult.log);
                }
                const parsedLogs = logResults.map(logResult => {
                    const colored = (0, utils_1.colorLogs)(logResult.log);
                    this.ux.log(colored);
                    return { log: logResult.log };
                });
                return parsedLogs;
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
}
exports.default = Get;
Get.requiresUsername = true;
Get.description = (0, utils_1.buildDescription)(messages.getMessage('commandDescription'), messages.getMessage('longDescription'));
Get.longDescription = messages.getMessage('longDescription');
Get.examples = [
    `$ sfdx force:apex:log:get -i <log id>`,
    `$ sfdx force:apex:log:get -i <log id> -u me@my.org`,
    `$ sfdx force:apex:log:get -n 2 -c`,
    `$ sfdx force:apex:log:get -d Users/Desktop/logs -n 2`
];
Get.flagsConfig = {
    json: command_1.flags.boolean({
        description: messages.getMessage('jsonDescription')
    }),
    loglevel: command_1.flags.enum({
        description: messages.getMessage('logLevelDescription'),
        longDescription: messages.getMessage('logLevelLongDescription'),
        default: 'warn',
        options: utils_1.logLevels
    }),
    apiversion: command_1.flags.builtin(),
    logid: command_1.flags.id({
        char: 'i',
        description: messages.getMessage('logIDDescription')
    }),
    number: command_1.flags.number({
        char: 'n',
        min: 1,
        max: 25,
        description: messages.getMessage('numberDescription')
    }),
    outputdir: command_1.flags.string({
        char: 'd',
        description: messages.getMessage('outputDirDescription'),
        longDescription: messages.getMessage('outputDirLongDescription')
    })
};
//# sourceMappingURL=get.js.map