"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const apex_node_1 = require("@salesforce/apex-node");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const utils_1 = require("../../../utils");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/plugin-apex', 'execute', [
    'apexCodeFileDescription',
    'commandDescription',
    'executeCompileSuccess',
    'executeRuntimeSuccess',
    'logLevelDescription',
    'logLevelLongDescription',
    'longDescription'
]);
class Execute extends command_1.SfdxCommand {
    run() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                // org is guaranteed by requiresUsername field
                if (!this.org) {
                    throw Error('Unable to get connection from Org.');
                }
                const conn = this.org.getConnection();
                const exec = new apex_node_1.ExecuteService(conn);
                const execAnonOptions = Object.assign({}, (this.flags.apexcodefile
                    ? { apexFilePath: this.flags.apexcodefile }
                    : { userInput: true }));
                const result = yield exec.executeAnonymous(execAnonOptions);
                this.ux.log(this.formatDefault(result));
                return this.formatJson(result);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    formatDefault(response) {
        let outputText = '';
        if (response.success) {
            outputText += `${(0, utils_1.colorSuccess)(messages.getMessage('executeCompileSuccess'))}\n`;
            outputText += `${(0, utils_1.colorSuccess)(messages.getMessage('executeRuntimeSuccess'))}\n`;
            outputText += `\n${response.logs}`;
        }
        else {
            if (!response.diagnostic) {
                throw Error('No diagnostic property found on response.');
            }
            const diagnostic = response.diagnostic[0];
            if (!response.compiled) {
                outputText += (0, utils_1.colorError)(`Error: Line: ${diagnostic.lineNumber}, Column: ${diagnostic.columnNumber}\n`);
                outputText += (0, utils_1.colorError)(`Error: ${diagnostic.compileProblem}\n`);
            }
            else {
                outputText += `${(0, utils_1.colorSuccess)(messages.getMessage('executeCompileSuccess'))}\n`;
                outputText += (0, utils_1.colorError)(`Error: ${diagnostic.exceptionMessage}\n`);
                outputText += (0, utils_1.colorError)(`Error: ${diagnostic.exceptionStackTrace}\n`);
                outputText += `\n${response.logs}`;
            }
        }
        return outputText;
    }
    formatJson(response) {
        const diagnostic = typeof response.diagnostic !== 'undefined';
        // Allow assumption below that diagnostic array is populated.
        /* eslint-disable @typescript-eslint/no-non-null-assertion */
        const formattedResponse = {
            success: response.success,
            compiled: response.compiled,
            compileProblem: diagnostic ? response.diagnostic[0].compileProblem : '',
            exceptionMessage: diagnostic
                ? response.diagnostic[0].exceptionMessage
                : '',
            exceptionStackTrace: diagnostic
                ? response.diagnostic[0].exceptionStackTrace
                : '',
            line: diagnostic ? response.diagnostic[0].lineNumber : -1,
            column: diagnostic ? response.diagnostic[0].columnNumber : -1,
            logs: response.logs
        };
        /* eslint-emable @typescript-eslint/no-non-null-assertion */
        return formattedResponse;
    }
}
exports.default = Execute;
Execute.description = (0, utils_1.buildDescription)(messages.getMessage('commandDescription'), messages.getMessage('longDescription'));
Execute.longDescription = messages.getMessage('longDescription');
Execute.examples = [
    `$ sfdx force:apex:execute -u testusername@salesforce.org -f ~/test.apex`,
    `$ sfdx force:apex:execute -f ~/test.apex`,
    `$ sfdx force:apex:execute \nStart typing Apex code. Press the Enter key after each line, then press CTRL+D when finished.`
];
Execute.requiresUsername = true;
Execute.flagsConfig = {
    apexcodefile: command_1.flags.filepath({
        char: 'f',
        description: messages.getMessage('apexCodeFileDescription')
    }),
    loglevel: command_1.flags.enum({
        description: messages.getMessage('logLevelDescription'),
        longDescription: messages.getMessage('logLevelLongDescription'),
        default: 'warn',
        options: utils_1.logLevels
    }),
    apiversion: command_1.flags.builtin()
};
//# sourceMappingURL=execute.js.map