"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
// Needed this to ensure the "helpers" were declared before read in examples
/* eslint-disable @typescript-eslint/member-ordering */
const os = require("os");
const marked_1 = require("marked");
const TerminalRenderer = require("marked-terminal");
const kit_1 = require("@salesforce/kit");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const getInfoConfig_1 = require("../../../shared/getInfoConfig");
const getReleaseNotes_1 = require("../../../shared/getReleaseNotes");
const getDistTagVersion_1 = require("../../../shared/getDistTagVersion");
const parseReleaseNotes_1 = require("../../../shared/parseReleaseNotes");
// Initialize Messages with the current plugin directory
core_1.Messages.importMessagesDirectory(__dirname);
const HIDE_NOTES = 'SFDX_HIDE_RELEASE_NOTES';
const HIDE_FOOTER = 'SFDX_HIDE_RELEASE_NOTES_FOOTER';
// Load the specific messages for this file. Messages from @salesforce/command, @salesforce/core,
// or any library that is using the messages framework can also be loaded this way.
const messages = core_1.Messages.loadMessages('@salesforce/plugin-info', 'display');
class Display extends command_1.SfdxCommand {
    async run() {
        var _a;
        const env = new kit_1.Env();
        const isHook = !!this.flags.hook;
        if (env.getBoolean(HIDE_NOTES) && isHook) {
            // We don't ever want to exit the process for info:releasenotes:display (whatsnew)
            // In most cases we will log a message, but here we only trace log in case someone using stdout of the update command
            this.logger.trace(`release notes disabled via env var: ${HIDE_NOTES}`);
            this.logger.trace('exiting');
            await core_1.Lifecycle.getInstance().emitTelemetry({ eventName: 'NOTES_HIDDEN' });
            return;
        }
        try {
            const installedVersion = this.config.pjson.version;
            const infoConfig = await (0, getInfoConfig_1.getInfoConfig)(this.config.root);
            const { distTagUrl, releaseNotesPath, releaseNotesFilename } = infoConfig.releasenotes;
            let version = (_a = this.flags.version) !== null && _a !== void 0 ? _a : installedVersion;
            if (Display.helpers.includes(version)) {
                version = await (0, getDistTagVersion_1.getDistTagVersion)(distTagUrl, version);
            }
            const releaseNotes = await (0, getReleaseNotes_1.getReleaseNotes)(releaseNotesPath, releaseNotesFilename, version);
            const tokens = (0, parseReleaseNotes_1.parseReleaseNotes)(releaseNotes, version, releaseNotesPath);
            marked_1.marked.setOptions({
                renderer: new TerminalRenderer({ emoji: false }),
            });
            tokens.unshift(marked_1.marked.lexer(`# Release notes for '${this.config.bin}':`)[0]);
            if (this.flags.json) {
                const body = tokens.map((token) => token.raw).join(os.EOL);
                return { body, url: releaseNotesPath };
            }
            else {
                this.ux.log(marked_1.marked.parser(tokens));
            }
            if (isHook) {
                if (env.getBoolean(HIDE_FOOTER)) {
                    await core_1.Lifecycle.getInstance().emitTelemetry({ eventName: 'FOOTER_HIDDEN' });
                }
                else {
                    const footer = messages.getMessage('footer', [this.config.bin, releaseNotesPath, HIDE_NOTES, HIDE_FOOTER]);
                    this.ux.log(marked_1.marked.parse(footer));
                }
            }
        }
        catch (err) {
            if (isHook) {
                // Do not throw error if --hook is passed, just warn so we don't exit any processes.
                // --hook is passed in the post install/update scripts
                const { message, stack, name } = err;
                this.ux.warn(`${this.id} failed: ${message}`);
                this.logger.trace(stack);
                await core_1.Lifecycle.getInstance().emitTelemetry({
                    eventName: 'COMMAND_ERROR',
                    type: 'EXCEPTION',
                    errorName: name,
                    errorMessage: message,
                    Error: Object.assign({
                        name,
                        message,
                        stack,
                    }, err),
                });
                return;
            }
            throw err;
        }
    }
}
exports.default = Display;
Display.helpers = ['stable', 'stable-rc', 'latest', 'latest-rc', 'rc'];
Display.description = messages.getMessage('commandDescription');
Display.aliases = ['whatsnew'];
Display.examples = messages.getMessage('examples', [Display.helpers.join(', ')]).split(os.EOL);
Display.flagsConfig = {
    version: command_1.flags.string({
        char: 'v',
        description: messages.getMessage('flags.version'),
    }),
    hook: command_1.flags.boolean({
        hidden: true,
        description: messages.getMessage('flags.hook'),
    }),
};
//# sourceMappingURL=display.js.map