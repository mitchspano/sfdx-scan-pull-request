"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformDeployTestsResultsToTestResult = exports.transformCoverageToApexCoverage = exports.prepCoverageForDisplay = void 0;
const chalk = require("chalk");
const resultFormatter_1 = require("./formatters/resultFormatter");
function mapTestResults(testResults) {
    return testResults.map((successOrFailure) => {
        var _a;
        const testResult = successOrFailure;
        return {
            apexClass: { fullName: testResult.name, id: testResult.id, name: testResult.name, namespacePrefix: '' },
            apexLogId: '',
            asyncApexJobId: '',
            fullName: testResult.name,
            id: testResult.id,
            message: (_a = testResult.message) !== null && _a !== void 0 ? _a : '',
            methodName: testResult.methodName,
            outcome: !testResult.message ? "Pass" /* ApexTestResultOutcome.Pass */ : "Fail" /* ApexTestResultOutcome.Fail */,
            queueItemId: '',
            runTime: parseInt(testResult.time, 10),
            stackTrace: testResult.stackTrace || '',
            testTimestamp: '',
        };
    });
}
function prepCoverageForDisplay(codeCoverage) {
    const coverage = codeCoverage.sort((a, b) => (a.name.toUpperCase() > b.name.toUpperCase() ? 1 : -1));
    coverage.forEach((cov) => {
        const numLocationsNum = parseInt(cov.numLocations, 10);
        const numLocationsNotCovered = parseInt(cov.numLocationsNotCovered, 10);
        const color = numLocationsNotCovered > 0 ? chalk.red : chalk.green;
        const coverageDecimal = parseFloat(((numLocationsNum - numLocationsNotCovered) / numLocationsNum).toFixed(2));
        const pctCovered = numLocationsNum > 0 ? coverageDecimal * 100 : 100;
        cov.numLocations = color(`${pctCovered}%`);
        cov.lineNotCovered = cov.locationsNotCovered
            ? (0, resultFormatter_1.toArray)(cov.locationsNotCovered)
                .map((location) => location.line)
                .join(',')
            : '';
    });
    return coverage;
}
exports.prepCoverageForDisplay = prepCoverageForDisplay;
function generateCoveredLines(cov) {
    const numCovered = parseInt(cov.numLocations, 10);
    const numUncovered = parseInt(cov.numLocationsNotCovered, 10);
    const uncoveredLines = (0, resultFormatter_1.toArray)(cov.locationsNotCovered).map((location) => parseInt(location.line, 10));
    const minLineNumber = uncoveredLines.length ? Math.min(...uncoveredLines) : 1;
    const lines = [...Array(numCovered + numUncovered).keys()].map((i) => i + minLineNumber);
    const coveredLines = lines.filter((line) => !uncoveredLines.includes(line));
    return [uncoveredLines, coveredLines];
}
function transformCoverageToApexCoverage(mdCoverage) {
    const apexCoverage = mdCoverage.map((cov) => {
        const numCovered = parseInt(cov.numLocations, 10);
        const numUncovered = parseInt(cov.numLocationsNotCovered, 10);
        const [uncoveredLines, coveredLines] = generateCoveredLines(cov);
        const ac = {
            ApexClassOrTrigger: {
                Id: cov.id,
                Name: cov.name,
            },
            NumLinesCovered: numCovered,
            NumLinesUncovered: numUncovered,
            Coverage: {
                coveredLines,
                uncoveredLines,
            },
        };
        return ac;
    });
    return { done: true, totalSize: apexCoverage.length, records: apexCoverage };
}
exports.transformCoverageToApexCoverage = transformCoverageToApexCoverage;
function transformDeployTestsResultsToTestResult(connection, runTestResult) {
    const numTestsRun = parseInt(runTestResult.numTestsRun, 10);
    const numTestFailures = parseInt(runTestResult.numFailures, 10);
    const testResult = {
        summary: {
            commandTimeInMs: 0,
            failRate: ((numTestFailures / numTestsRun) * 100).toFixed(2) + '%',
            failing: numTestFailures,
            hostname: connection.getConnectionOptions().instanceUrl,
            orgId: connection.getAuthInfoFields().orgId,
            outcome: '',
            passRate: numTestFailures === 0 ? '100%' : ((1 - numTestFailures / numTestsRun) * 100).toFixed(2) + '%',
            passing: numTestsRun - numTestFailures,
            skipRate: '',
            skipped: 0,
            testExecutionTimeInMs: parseFloat(runTestResult.totalTime),
            testRunId: '',
            testStartTime: new Date().toISOString(),
            testTotalTimeInMs: parseFloat(runTestResult.totalTime),
            testsRan: numTestsRun,
            userId: connection.getConnectionOptions().userId,
            username: connection.getUsername(),
        },
        tests: [...mapTestResults((0, resultFormatter_1.toArray)(runTestResult.successes)), ...mapTestResults((0, resultFormatter_1.toArray)(runTestResult.failures))],
        codecoverage: (0, resultFormatter_1.toArray)(runTestResult === null || runTestResult === void 0 ? void 0 : runTestResult.codeCoverage).map((cov) => {
            const codeCoverageResult = {};
            codeCoverageResult.apexId = cov.id;
            codeCoverageResult.name = cov.name;
            codeCoverageResult.numLinesUncovered = parseInt(cov.numLocationsNotCovered, 10);
            codeCoverageResult.numLinesCovered = parseInt(cov.numLocations, 10) - codeCoverageResult.numLinesUncovered;
            const [uncoveredLines, coveredLines] = generateCoveredLines(cov);
            codeCoverageResult.coveredLines = coveredLines;
            codeCoverageResult.uncoveredLines = uncoveredLines;
            const numLocationsNum = parseInt(cov.numLocations, 10);
            const numLocationsNotCovered = parseInt(cov.numLocationsNotCovered, 10);
            codeCoverageResult.percentage =
                numLocationsNum > 0
                    ? (((numLocationsNum - numLocationsNotCovered) / numLocationsNum) * 100).toFixed() + '%'
                    : '';
            return codeCoverageResult;
        }),
    };
    return testResult;
}
exports.transformDeployTestsResultsToTestResult = transformDeployTestsResultsToTestResult;
//# sourceMappingURL=coverageUtils.js.map