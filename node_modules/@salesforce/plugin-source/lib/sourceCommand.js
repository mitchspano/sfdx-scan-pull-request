"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceCommand = void 0;
const path_1 = require("path");
const fs = require("fs");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
const core_2 = require("@oclif/core");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/plugin-source', 'flags.validation', [
    'InvalidFlagPath',
    'expectedDirectory',
    'expectedFile',
    'notFound',
]);
// TODO: use messages for tracking version compatibility errors
// Messages.importMessagesDirectory(__dirname);
// const messages = Messages.loadMessages('@salesforce/plugin-source', 'retrieve');
class SourceCommand extends command_1.SfdxCommand {
    constructor() {
        super(...arguments);
        this.lifecycle = core_1.Lifecycle.getInstance();
    }
    isJsonOutput() {
        return (0, ts_types_1.getBoolean)(this.flags, 'json', false);
    }
    getFlag(flagName, defaultVal) {
        return (0, ts_types_1.get)(this.flags, flagName, defaultVal);
    }
    initProgressBar() {
        this.logger.debug('initializing progress bar');
        this.progressBar = core_2.CliUx.ux.progress({
            format: 'SOURCE PROGRESS | {bar} | {value}/{total} Components',
            barCompleteChar: '\u2588',
            barIncompleteChar: '\u2591',
            linewrap: true,
        });
    }
    /**
     * Sets an exit code on the process that marks success or failure
     * after successful command execution.
     *
     * @param code The exit code to set on the process.
     */
    setExitCode(code) {
        process.exitCode = code;
    }
    getPackageDirs() {
        return this.project.getUniquePackageDirectories().map((pDir) => pDir.fullPath);
    }
    async getSourceApiVersion() {
        const projectConfig = await this.project.resolveProjectConfig();
        return (0, ts_types_1.getString)(projectConfig, 'sourceApiVersion');
    }
    /**
     * Ensures command flags that are file system paths are set properly before
     * continuing command execution.  Can also create directories that don't yet
     * exist in the path.
     *
     * @param options defines the path to resolve and the expectations
     * @returns the resolved flag path
     */
    ensureFlagPath(options) {
        const { flagName, path, type, throwOnENOENT } = options;
        const trimmedPath = path === null || path === void 0 ? void 0 : path.trim();
        let resolvedPath;
        if (trimmedPath === null || trimmedPath === void 0 ? void 0 : trimmedPath.length) {
            resolvedPath = (0, path_1.resolve)(trimmedPath);
        }
        try {
            const stats = fs.statSync(resolvedPath);
            if (type !== 'any') {
                const isDir = stats.isDirectory();
                if (type === 'dir' && !isDir) {
                    const msg = messages.getMessage('expectedDirectory');
                    throw new core_1.SfError(messages.getMessage('InvalidFlagPath', [flagName, path, msg]), 'InvalidFlagPath');
                }
                else if (type === 'file' && isDir) {
                    const msg = messages.getMessage('expectedFile');
                    throw new core_1.SfError(messages.getMessage('InvalidFlagPath', [flagName, path, msg]), 'InvalidFlagPath');
                }
            }
        }
        catch (error) {
            const err = error;
            if (err.code !== 'ENOENT') {
                throw err;
            }
            else {
                if (throwOnENOENT) {
                    const enoent = messages.getMessage('notFound');
                    throw new core_1.SfError(messages.getMessage('InvalidFlagPath', [flagName, path, enoent]), 'InvalidFlagPath');
                }
                const dir = type === 'dir' ? resolvedPath : (0, path_1.dirname)(resolvedPath);
                fs.mkdirSync(dir, { recursive: true });
            }
        }
        return resolvedPath;
    }
}
exports.SourceCommand = SourceCommand;
SourceCommand.DEFAULT_WAIT_MINUTES = 33;
//# sourceMappingURL=sourceCommand.js.map