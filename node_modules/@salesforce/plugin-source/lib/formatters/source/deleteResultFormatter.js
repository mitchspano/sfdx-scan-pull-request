"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeleteResultFormatter = void 0;
const chalk = require("chalk");
const deployResultFormatter_1 = require("../deployResultFormatter");
const resultFormatter_1 = require("../resultFormatter");
class DeleteResultFormatter extends deployResultFormatter_1.DeployResultFormatter {
    constructor(logger, ux, options, result) {
        super(logger, ux, options, result);
    }
    /**
     * Get the JSON output from the DeployResult.
     *
     * @returns a JSON formatted result matching the provided type.
     */
    getJson() {
        const json = this.getResponse();
        json.deletedSource = this.fileResponses; // to match toolbelt json output
        json.outboundFiles = []; // to match toolbelt version
        json.deletes = [Object.assign({}, this.getResponse())]; // to match toolbelt version
        return json;
    }
    displayNoResultsFound() {
        // matches toolbelt
        this.ux.styledHeader(chalk.blue('Deleted Source'));
        this.ux.log('No results found');
    }
    displaySuccesses() {
        var _a, _b, _c, _d;
        if (this.isSuccess()) {
            const successes = [];
            const fileResponseSuccesses = new Map();
            if ((_a = this.fileResponses) === null || _a === void 0 ? void 0 : _a.length) {
                const fileResponses = [];
                this.fileResponses.map((f) => {
                    fileResponses.push(f);
                    fileResponseSuccesses.set(`${f.type}#${f.fullName}`, f);
                });
                this.sortFileResponses(fileResponses);
                this.asRelativePaths(fileResponses);
                successes.push(...fileResponses);
            }
            const deployMessages = (0, resultFormatter_1.toArray)((_d = (_c = (_b = this.result) === null || _b === void 0 ? void 0 : _b.response) === null || _c === void 0 ? void 0 : _c.details) === null || _d === void 0 ? void 0 : _d.componentSuccesses).filter((item) => !item.fileName.includes('package.xml'));
            if (deployMessages.length >= successes.length) {
                // if there's additional successes in the API response, find the success and add it to the output
                deployMessages.map((deployMessage) => {
                    if (!fileResponseSuccesses.has(`${deployMessage.componentType}#${deployMessage.fullName}`)) {
                        successes.push(Object.assign(deployMessage, {
                            type: deployMessage.componentType,
                        }));
                    }
                });
            }
            this.ux.log('');
            this.ux.styledHeader(chalk.blue('Deleted Source'));
            this.ux.table(successes, {
                fullName: { header: 'FULL NAME' },
                type: { header: 'TYPE' },
                filePath: { header: 'PROJECT PATH' },
            });
        }
    }
}
exports.DeleteResultFormatter = DeleteResultFormatter;
//# sourceMappingURL=deleteResultFormatter.js.map