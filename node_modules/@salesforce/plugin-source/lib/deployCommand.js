"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getVersionMessage = exports.DeployCommand = exports.reportsFormatters = void 0;
const path = require("path");
const fs = require("fs");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const core_1 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
const kit_1 = require("@salesforce/kit");
const apex_node_1 = require("@salesforce/apex-node");
const sourceCommand_1 = require("./sourceCommand");
const stash_1 = require("./stash");
const coverageUtils_1 = require("./coverageUtils");
// TODO: this function needs to be moved to a shared location
const resultFormatter_1 = require("./formatters/resultFormatter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/plugin-source', 'deployCommand', [
    'invalidDeployId',
    'MissingDeployId',
    'resultsDirMissing',
]);
exports.reportsFormatters = Object.keys(apex_node_1.DefaultReportOptions);
class DeployCommand extends sourceCommand_1.SourceCommand {
    constructor() {
        super(...arguments);
        this.displayDeployId = (0, kit_1.once)((id) => {
            if (!this.isJsonOutput()) {
                this.ux.log(`Deploy ID: ${id}`);
            }
        });
        this.isRest = false;
        this.isAsync = false;
        this.updateDeployId = (0, kit_1.once)((id) => {
            this.displayDeployId(id);
            const stashKey = stash_1.Stash.getKey(this.id);
            stash_1.Stash.set(stashKey, { jobid: id });
        });
    }
    /**
     * Request a report of an in-progress or completed deployment.
     *
     * @param id the Deploy ID of a deployment request
     * @returns DeployResult
     */
    async report(id) {
        const deployId = this.resolveDeployId(id);
        this.displayDeployId(deployId);
        const res = await this.org.getConnection().metadata.checkDeployStatus(deployId, true);
        const deployStatus = res;
        const componentSet = this.componentSet || new source_deploy_retrieve_1.ComponentSet();
        return new source_deploy_retrieve_1.DeployResult(deployStatus, componentSet);
    }
    /**
     * Checks the response status to determine whether the deploy was successful.
     * Async deploys are successful unless an error is thrown, which resolves as
     * unsuccessful in oclif.
     */
    resolveSuccess() {
        var _a, _b;
        const StatusCodeMap = new Map([
            [source_deploy_retrieve_1.RequestStatus.Succeeded, 0],
            [source_deploy_retrieve_1.RequestStatus.Canceled, 1],
            [source_deploy_retrieve_1.RequestStatus.Failed, 1],
            [source_deploy_retrieve_1.RequestStatus.SucceededPartial, 68],
            [source_deploy_retrieve_1.RequestStatus.InProgress, 69],
            [source_deploy_retrieve_1.RequestStatus.Pending, 69],
            [source_deploy_retrieve_1.RequestStatus.Canceling, 69],
        ]);
        if (!this.isAsync) {
            this.setExitCode((_b = StatusCodeMap.get((_a = this.deployResult.response) === null || _a === void 0 ? void 0 : _a.status)) !== null && _b !== void 0 ? _b : 1);
        }
    }
    /**
     * This method is here to provide a workaround to stubbing a constructor in the tests.
     *
     * @param id
     */
    createDeploy(id) {
        return new source_deploy_retrieve_1.MetadataApiDeploy({ usernameOrConnection: this.org.getUsername(), id });
    }
    resolveDeployId(id) {
        if (id) {
            return id;
        }
        else {
            const stash = stash_1.Stash.get(stash_1.Stash.getKey(this.id));
            if (!stash) {
                throw new core_1.SfError(messages.getMessage('MissingDeployId'));
            }
            return stash.jobid;
        }
    }
    // SOAP is the default unless:
    //   1. SOAP is specified with the soapdeploy flag on the command
    //   2. The restDeploy SFDX config setting is explicitly true.
    isRestDeploy() {
        if ((0, ts_types_1.getBoolean)(this.flags, 'soapdeploy') === true) {
            this.logger.debug('soapdeploy flag === true.  Using SOAP');
            return false;
        }
        const restDeployConfig = this.configAggregator.getInfo(core_1.SfdxPropertyKeys.REST_DEPLOY).value;
        // aggregator property values are returned as strings
        if (restDeployConfig === 'false') {
            this.logger.debug('restDeploy SFDX config === false.  Using SOAP');
            return false;
        }
        else if (restDeployConfig === 'true') {
            this.logger.debug('restDeploy SFDX config === true.  Using REST');
            return true;
        }
        else {
            this.logger.debug('soapdeploy flag unset. restDeploy SFDX config unset.  Defaulting to SOAP');
        }
        return false;
    }
    async poll(deployId, options) {
        var _a, _b;
        const waitFlag = this.getFlag('wait');
        const waitDuration = waitFlag.minutes === -1 ? kit_1.Duration.days(7) : waitFlag;
        const defaultOptions = {
            frequency: (_a = options === null || options === void 0 ? void 0 : options.frequency) !== null && _a !== void 0 ? _a : kit_1.Duration.seconds(1),
            timeout: (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : waitDuration,
            poll: async () => {
                const deployResult = await this.report(deployId);
                return {
                    completed: (0, ts_types_1.getBoolean)(deployResult, 'response.done'),
                    payload: deployResult,
                };
            },
        };
        const pollingOptions = { ...defaultOptions, ...options };
        const pollingClient = await core_1.PollingClient.create(pollingOptions);
        return pollingClient.subscribe();
    }
    async deployRecentValidation() {
        const id = this.getFlag('validateddeployrequestid');
        const response = await this.org.getConnection().deployRecentValidation({ id, rest: this.isRest });
        // This is the deploy ID of the deployRecentValidation response, not
        // the already validated deploy ID (i.e., validateddeployrequestid).
        // REST returns an object with an ID, SOAP returns the id as a string.
        const validatedDeployId = (0, ts_types_1.isString)(response) ? response : response.id;
        this.updateDeployId(validatedDeployId);
        this.asyncDeployResult = { id: validatedDeployId };
        return this.isAsync ? this.report(validatedDeployId) : this.poll(validatedDeployId);
    }
    maybeCreateRequestedReports() {
        var _a;
        // only generate reports if test results are present
        if ((_a = this.deployResult.response) === null || _a === void 0 ? void 0 : _a.numberTestsTotal) {
            if (this.flags.coverageformatters) {
                this.createCoverageReport(this.deployResult, this.flags.coverageformatters, 'no-map', this.resultsDir);
            }
            if (this.flags.junit) {
                this.createJunitResults(this.deployResult);
            }
        }
    }
    createCoverageReport(deployResult, formatters, sourceDir, resultsDir) {
        var _a, _b, _c;
        const apexCoverage = (0, coverageUtils_1.transformCoverageToApexCoverage)((0, resultFormatter_1.toArray)((_c = (_b = (_a = deployResult.response) === null || _a === void 0 ? void 0 : _a.details) === null || _b === void 0 ? void 0 : _b.runTestResult) === null || _c === void 0 ? void 0 : _c.codeCoverage));
        fs.mkdirSync(resultsDir, { recursive: true });
        const options = this.getCoverageFormattersOptions(formatters);
        const coverageReport = new apex_node_1.CoverageReporter(apexCoverage, resultsDir, sourceDir, options);
        coverageReport.generateReports();
    }
    getCoverageFormattersOptions(formatters = []) {
        /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */
        const options = {};
        // set requested report formats
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        options.reportFormats = formatters;
        // set report options to default report options for each format
        options.reportOptions = Object.fromEntries(options.reportFormats.map((format) => {
            const reportOptions = (0, kit_1.cloneJson)(apex_node_1.DefaultReportOptions[format]);
            const keys = Object.keys(reportOptions);
            if (keys.includes('file')) {
                reportOptions['file'] = reportOptions['file'];
                if (!keys.includes('subdir')) {
                    reportOptions['file'] = path.join('coverage', reportOptions['file']);
                }
            }
            if (keys.includes('subdir')) {
                reportOptions['subdir'] = path.join('coverage', reportOptions['subdir']);
            }
            return [format, reportOptions];
        }));
        return options;
        /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */
    }
    createJunitResults(deployResult) {
        var _a, _b;
        const testResult = (0, coverageUtils_1.transformDeployTestsResultsToTestResult)(this.org.getConnection(), (_b = (_a = deployResult.response) === null || _a === void 0 ? void 0 : _a.details) === null || _b === void 0 ? void 0 : _b.runTestResult);
        if (testResult.summary.testsRan > 0) {
            const jUnitReporter = new apex_node_1.JUnitReporter();
            const junitResults = jUnitReporter.format(testResult);
            const junitReportPath = path.join(this.resultsDir, 'junit');
            fs.mkdirSync(junitReportPath, { recursive: true });
            fs.writeFileSync(path.join(junitReportPath, 'junit.xml'), junitResults, 'utf8');
        }
    }
    resolveOutputDir(coverageFormatters, junit, resultsDir, deployId, noThrow) {
        if (resultsDir) {
            return resultsDir;
        }
        if (coverageFormatters || junit) {
            if (deployId) {
                return deployId;
            }
            if (!noThrow) {
                throw new core_1.SfError(messages.getMessage('resultsDirMissing'));
            }
        }
        return undefined;
    }
}
exports.DeployCommand = DeployCommand;
// the basic sfdx flag is already making sure its of the correct length
DeployCommand.isValidDeployId = (id) => {
    if (id.startsWith('0Af')) {
        return true;
    }
    else {
        throw new core_1.SfError(messages.getMessage('invalidDeployId'), 'invalidDeployId');
    }
};
const getVersionMessage = (action, componentSet, isRest) => {
    var _a;
    // commands pass in the.componentSet, which may not exist in some tests or mdapi deploys
    if (!componentSet) {
        return `*** ${action} with ${isRest ? 'REST' : 'SOAP'} ***`;
    }
    // neither
    if (!componentSet.sourceApiVersion && !componentSet.apiVersion) {
        return `*** ${action} with ${isRest ? 'REST' : 'SOAP'} ***`;
    }
    // either OR both match (SDR will use either)
    if (!componentSet.sourceApiVersion ||
        !componentSet.apiVersion ||
        componentSet.sourceApiVersion === componentSet.apiVersion) {
        return `*** ${action} with ${isRest ? 'REST' : 'SOAP'} API v${(_a = componentSet.apiVersion) !== null && _a !== void 0 ? _a : componentSet.sourceApiVersion} ***`;
    }
    // has both but they don't match
    return `*** ${action} v${componentSet.sourceApiVersion} metadata with ${isRest ? 'REST' : 'SOAP'} API v${componentSet.apiVersion} connection ***`;
};
exports.getVersionMessage = getVersionMessage;
//# sourceMappingURL=deployCommand.js.map