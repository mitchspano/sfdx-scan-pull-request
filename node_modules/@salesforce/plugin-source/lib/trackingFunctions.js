"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateTracking = exports.trackingSetup = exports.filterConflictsByComponentSet = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path = require("path");
const source_tracking_1 = require("@salesforce/source-tracking");
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'tracking');
/**
 * Check if any conflicts exist in a specific component set.
 * If conflicts exist, this will output the table and throw
 */
const filterConflictsByComponentSet = async ({ tracking, components, ux, }) => {
    const filteredConflicts = (await tracking.getConflicts()).filter((cr) => components.has({ fullName: cr.name, type: cr.type }));
    processConflicts(filteredConflicts, ux, messages.getMessage('conflictMsg'));
    return filteredConflicts;
};
exports.filterConflictsByComponentSet = filterConflictsByComponentSet;
/**
 * Init SourceTracking (STL) and do conflict detection
 *
 * @param options
 * @returns SourceTracking
 */
const trackingSetup = async (options) => {
    const { ux, org, ignoreConflicts, commandName, ...createOptions } = options;
    const projectPath = options.project.getPath();
    // 3 commands use throwIfInvalid
    if (commandName.endsWith('push') || commandName.endsWith('pull') || commandName.endsWith('status')) {
        (0, source_tracking_1.throwIfInvalid)({
            org,
            projectPath,
            toValidate: 'plugin-source',
            command: commandName,
        });
    }
    else {
        // confirm tracking file version is plugin-source for all --tracksource flags (deploy, retrieve, delete)
        if ((0, source_tracking_1.getTrackingFileVersion)(org, projectPath) === 'toolbelt') {
            throw new core_1.SfError('You cannot use the "tracksource" flag with the old version of the tracking files', 'sourceTrackingFileVersionMismatch', [
                'Clear the old version of the tracking files with "sfdx force:source:legacy:tracking:clear"',
                'Create a new org to use the new tracking files',
            ]);
        }
    }
    const tracking = await source_tracking_1.SourceTracking.create({ org, ...createOptions });
    if (!ignoreConflicts) {
        processConflicts(await tracking.getConflicts(), ux, messages.getMessage('conflictMsg'));
    }
    return tracking;
};
exports.trackingSetup = trackingSetup;
/**
 * Shared function for taking a Deploy/Retrieve result and handle the source tracking updates
 *
 * @param options
 */
const updateTracking = async ({ tracking, result, ux, fileResponses }) => {
    // might not exist if we exited from the operation early
    if (!result) {
        return;
    }
    ux.startSpinner('Updating source tracking');
    const successes = (fileResponses !== null && fileResponses !== void 0 ? fileResponses : result.getFileResponses()).filter((fileResponse) => fileResponse.state !== source_deploy_retrieve_1.ComponentStatus.Failed);
    if (!successes.length) {
        ux.stopSpinner();
        return;
    }
    await Promise.all([
        tracking.updateLocalTracking(result instanceof source_deploy_retrieve_1.RetrieveResult
            ? { files: successes.map((fileResponse) => fileResponse.filePath).filter(Boolean) }
            : {
                files: successes
                    .filter((fileResponse) => fileResponse.state !== source_deploy_retrieve_1.ComponentStatus.Deleted)
                    .map((fileResponse) => fileResponse.filePath),
                deletedFiles: successes
                    .filter((fileResponse) => fileResponse.state === source_deploy_retrieve_1.ComponentStatus.Deleted)
                    .map((fileResponse) => fileResponse.filePath),
            }),
        tracking.updateRemoteTracking(successes.map(({ state, fullName, type, filePath }) => ({ state, fullName, type, filePath })), result instanceof source_deploy_retrieve_1.RetrieveResult),
    ]);
    ux.stopSpinner();
};
exports.updateTracking = updateTracking;
const writeConflictTable = (conflicts, ux) => {
    ux.table(conflicts, {
        state: { header: 'STATE' },
        fullName: { header: 'FULL NAME' },
        type: { header: 'TYPE' },
        filePath: { header: 'FILE PATH' },
    });
};
/**
 * Write a table (if not json) and throw an error that includes a custom message and the conflict data
 *
 * @param conflicts
 * @param ux
 * @param message
 */
const processConflicts = (conflicts, ux, message) => {
    if (conflicts.length === 0) {
        return;
    }
    // map do dedupe by name-type-filename
    const conflictMap = new Map();
    conflicts.forEach((c) => {
        var _a;
        (_a = c.filenames) === null || _a === void 0 ? void 0 : _a.forEach((f) => {
            conflictMap.set(`${c.name}#${c.type}#${f}`, {
                state: 'Conflict',
                fullName: c.name,
                type: c.type,
                filePath: path.resolve(f),
            });
        });
    });
    const reformattedConflicts = Array.from(conflictMap.values());
    writeConflictTable(reformattedConflicts, ux);
    const err = new core_1.SfError(message, 'sourceConflictDetected');
    err.setData(reformattedConflicts);
    throw err;
};
//# sourceMappingURL=trackingFunctions.js.map