"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@salesforce/command");
const kit_1 = require("@salesforce/kit");
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const ts_types_1 = require("@salesforce/ts-types");
const deployCommand_1 = require("../../../deployCommand");
const pushResultFormatter_1 = require("../../../formatters/source/pushResultFormatter");
const deployProgressBarFormatter_1 = require("../../../formatters/deployProgressBarFormatter");
const deployProgressStatusFormatter_1 = require("../../../formatters/deployProgressStatusFormatter");
const trackingFunctions_1 = require("../../../trackingFunctions");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'push');
class Push extends deployCommand_1.DeployCommand {
    constructor() {
        super(...arguments);
        this.lifecycleEventNames = ['predeploy', 'postdeploy'];
        this.deployResults = [];
    }
    async run() {
        await this.prechecks();
        await this.deploy();
        this.resolveSuccess();
        await this.updateTracking();
        return this.formatResult();
    }
    async prechecks() {
        this.tracking = await (0, trackingFunctions_1.trackingSetup)({
            commandName: 'force:source:push',
            ignoreConflicts: this.getFlag('forceoverwrite', false),
            org: this.org,
            project: this.project,
            ux: this.ux,
        });
        // we need these later to show deletes in results
        this.deletes = await this.tracking.getChanges({ origin: 'local', state: 'delete', format: 'string' });
    }
    async deploy() {
        const isSequentialDeploy = (0, ts_types_1.getBoolean)(await this.project.resolveProjectConfig(), 'pushPackageDirectoriesSequentially', false);
        const [componentSets, sourceApiVersion, isRest] = await Promise.all([
            this.tracking.localChangesAsComponentSet(isSequentialDeploy),
            this.getSourceApiVersion(),
            this.isRestDeploy(),
        ]);
        for (const componentSet of componentSets) {
            if (sourceApiVersion) {
                componentSet.sourceApiVersion = sourceApiVersion;
            }
            // there might have been components in local tracking, but they might be ignored by SDR or unresolvable.
            // SDR will throw when you try to resolve them, so don't
            if (componentSet.size === 0) {
                this.logger.warn('There are no changes to deploy');
                continue;
            }
            // fire predeploy event for sync and async deploys
            await this.lifecycle.emit('predeploy', componentSet.toArray());
            this.ux.log((0, deployCommand_1.getVersionMessage)('Pushing', componentSet, isRest));
            const deploy = await componentSet.deploy({
                usernameOrConnection: this.org.getUsername(),
                apiOptions: {
                    ignoreWarnings: this.getFlag('ignorewarnings', false),
                    rest: isRest,
                    testLevel: 'NoTestRun',
                },
            });
            // we're not print JSON output
            if (!this.isJsonOutput()) {
                const progressFormatter = kit_1.env.getBoolean('SFDX_USE_PROGRESS_BAR', true)
                    ? new deployProgressBarFormatter_1.DeployProgressBarFormatter(this.logger, this.ux)
                    : new deployProgressStatusFormatter_1.DeployProgressStatusFormatter(this.logger, this.ux);
                progressFormatter.progress(deploy);
            }
            const result = await deploy.pollStatus({ timeout: this.getFlag('wait') });
            if (result) {
                // Only fire the postdeploy event when we have results. I.e., not async.
                await this.lifecycle.emit('postdeploy', result);
                this.deployResults.push(result);
                if (result.response.status !== source_deploy_retrieve_1.RequestStatus.Succeeded &&
                    isSequentialDeploy &&
                    this.project.hasMultiplePackages()) {
                    this.ux.log(messages.getMessage('sequentialFail'));
                    break;
                }
            }
        }
    }
    async updateTracking() {
        // there can be multiple deploy results for sequential deploys
        if (process.exitCode !== 0 || !this.deployResults.length) {
            return;
        }
        await (0, trackingFunctions_1.updateTracking)({
            ux: this.ux,
            result: this.deployResults[0],
            tracking: this.tracking,
            // since we're going to poll source members, we want them all in one transaction
            fileResponses: this.deployResults.flatMap((result) => result.getFileResponses()),
        });
    }
    resolveSuccess() {
        const StatusCodeMap = new Map([
            [source_deploy_retrieve_1.RequestStatus.Succeeded, 0],
            [source_deploy_retrieve_1.RequestStatus.Canceled, 1],
            [source_deploy_retrieve_1.RequestStatus.Failed, 1],
            [source_deploy_retrieve_1.RequestStatus.InProgress, 69],
            [source_deploy_retrieve_1.RequestStatus.Pending, 69],
            [source_deploy_retrieve_1.RequestStatus.Canceling, 69],
        ]);
        // there might be no results if we exited early (ex: nothing to push)
        if (!this.deployResults.length) {
            return this.setExitCode(0);
        }
        // any incomplete means incomplete
        if (this.deployResults.some((result) => StatusCodeMap.get(result.response.status) === 69)) {
            return this.setExitCode(69);
        }
        const isSuccessLike = (result) => {
            return (result.response.status === source_deploy_retrieve_1.RequestStatus.Succeeded ||
                // successful-ish  (only warnings about deleted things that are already deleted)
                (result.response.status === source_deploy_retrieve_1.RequestStatus.Failed &&
                    result.getFileResponses().every((fr) => fr.state !== 'Failed')));
        };
        // all successes
        if (this.deployResults.every((result) => isSuccessLike(result))) {
            return this.setExitCode(0);
        }
        // 1 and 0 === 68 "partial success"
        if (this.deployResults.some((result) => isSuccessLike(result)) &&
            this.deployResults.some((result) => StatusCodeMap.get(result.response.status) === 1)) {
            return this.setExitCode(68);
        }
        // all fails
        if (this.deployResults.every((result) => StatusCodeMap.get(result.response.status) === 1)) {
            return this.setExitCode(1);
        }
        this.logger.warn('Unexpected exit code', this.deployResults.map((result) => result.response));
        this.setExitCode(1);
    }
    formatResult() {
        if (!this.deployResults.length) {
            this.ux.log('No results found');
        }
        const formatterOptions = {
            quiet: this.getFlag('quiet', false),
        };
        const formatter = new pushResultFormatter_1.PushResultFormatter(this.logger, this.ux, formatterOptions, this.deployResults, this.deletes);
        // Only display results to console when JSON flag is unset.
        if (!this.isJsonOutput()) {
            formatter.display();
        }
        return formatter.getJson();
    }
}
exports.default = Push;
Push.aliases = ['force:source:beta:push'];
Push.description = messages.getMessage('description');
Push.help = messages.getMessage('help');
Push.flagsConfig = {
    forceoverwrite: command_1.flags.boolean({
        char: 'f',
        description: messages.getMessage('flags.forceoverwrite'),
        longDescription: messages.getMessage('flags.forceoverwriteLong'),
    }),
    wait: command_1.flags.minutes({
        char: 'w',
        default: kit_1.Duration.minutes(deployCommand_1.DeployCommand.DEFAULT_WAIT_MINUTES),
        min: kit_1.Duration.minutes(1),
        description: messages.getMessage('flags.waitLong'),
        longDescription: messages.getMessage('flags.waitLong'),
    }),
    ignorewarnings: command_1.flags.boolean({
        char: 'g',
        description: messages.getMessage('flags.ignorewarnings'),
        longDescription: messages.getMessage('flags.ignorewarningsLong'),
    }),
    quiet: command_1.flags.builtin({
        description: messages.getMessage('flags.quiet'),
    }),
};
Push.requiresUsername = true;
Push.requiresProject = true;
//# sourceMappingURL=push.js.map