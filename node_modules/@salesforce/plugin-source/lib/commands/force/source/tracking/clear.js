"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Clear = void 0;
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const chalk = require("chalk");
const source_tracking_1 = require("@salesforce/source-tracking");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'tracking');
class Clear extends command_1.SfdxCommand {
    async run() {
        (0, source_tracking_1.throwIfInvalid)({
            org: this.org,
            projectPath: this.project.getPath(),
            toValidate: 'plugin-source',
            command: 'force:source:tracking:clear',
        });
        let clearedFiles = [];
        if (this.flags.noprompt || (await this.ux.confirm(chalk.dim(messages.getMessage('promptMessage'))))) {
            const sourceTracking = await source_tracking_1.SourceTracking.create({
                project: this.project,
                org: this.org,
            });
            clearedFiles = await Promise.all([sourceTracking.clearLocalTracking(), sourceTracking.clearRemoteTracking()]);
            this.ux.log('Cleared local tracking files.');
        }
        return { clearedFiles };
    }
}
exports.Clear = Clear;
Clear.aliases = ['force:source:beta:tracking:clear'];
Clear.description = messages.getMessage('clearDescription');
Clear.requiresProject = true;
Clear.requiresUsername = true;
Clear.flagsConfig = {
    noprompt: command_1.flags.boolean({
        char: 'p',
        description: messages.getMessage('nopromptDescription'),
        required: false,
    }),
};
//# sourceMappingURL=clear.js.map