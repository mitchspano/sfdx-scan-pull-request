"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Delete = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os = require("os");
const fs = require("fs");
const path = require("path");
const core_1 = require("@oclif/core");
const command_1 = require("@salesforce/command");
const core_2 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const kit_1 = require("@salesforce/kit");
const deployCommand_1 = require("../../../deployCommand");
const deployResultFormatter_1 = require("../../../formatters/deployResultFormatter");
const deleteResultFormatter_1 = require("../../../formatters/source/deleteResultFormatter");
const deployProgressBarFormatter_1 = require("../../../formatters/deployProgressBarFormatter");
const deployProgressStatusFormatter_1 = require("../../../formatters/deployProgressStatusFormatter");
const trackingFunctions_1 = require("../../../trackingFunctions");
const fsPromises = fs.promises;
core_2.Messages.importMessagesDirectory(__dirname);
const messages = core_2.Messages.loadMessages('@salesforce/plugin-source', 'delete');
const xorFlags = ['metadata', 'sourcepath'];
class Delete extends deployCommand_1.DeployCommand {
    constructor() {
        super(...arguments);
        this.lifecycleEventNames = ['predeploy', 'postdeploy'];
        this.aborted = false;
        // create the delete FileResponse as we're parsing the comp. set to use in the output
        this.mixedDeployDelete = { delete: [], deploy: [] };
        // map of component in project, to where it is stashed
        this.stashPath = new Map();
        this.tempDir = path.join(os.tmpdir(), 'source_delete');
    }
    async run() {
        await this.preChecks();
        await this.delete();
        await this.resolveSuccess();
        const result = this.formatResult();
        // The DeleteResultFormatter will use SDR and scan the directory, if the files have been deleted, it will throw an error
        // so we'll delete the files locally now
        await this.deleteFilesLocally();
        // makes sure files are deleted before updating tracking files
        await this.maybeUpdateTracking();
        return result;
    }
    async preChecks() {
        if (this.getFlag('tracksource')) {
            this.tracking = await (0, trackingFunctions_1.trackingSetup)({
                commandName: 'force:source:delete',
                ignoreConflicts: true,
                org: this.org,
                project: this.project,
                ux: this.ux,
            });
        }
    }
    async delete() {
        var _a, _b;
        this.deleteResultFormatter = new deleteResultFormatter_1.DeleteResultFormatter(this.logger, this.ux, {});
        const sourcepaths = this.getFlag('sourcepath');
        this.componentSet = await source_deploy_retrieve_1.ComponentSetBuilder.build({
            apiversion: this.getFlag('apiversion'),
            sourceapiversion: await this.getSourceApiVersion(),
            sourcepath: sourcepaths,
            metadata: this.flags.metadata && {
                metadataEntries: this.getFlag('metadata'),
                directoryPaths: this.getPackageDirs(),
            },
        });
        if (this.getFlag('tracksource') && !this.getFlag('forceoverwrite')) {
            await (0, trackingFunctions_1.filterConflictsByComponentSet)({ tracking: this.tracking, components: this.componentSet, ux: this.ux });
        }
        this.components = this.componentSet.toArray();
        if (!this.components.length) {
            // if we didn't find any components to delete, let the user know and exit
            this.deleteResultFormatter.displayNoResultsFound();
            return;
        }
        // create a new ComponentSet and mark everything for deletion
        const cs = new source_deploy_retrieve_1.ComponentSet([]);
        cs.apiVersion = (_a = this.getFlag('apiversion')) !== null && _a !== void 0 ? _a : (await this.org.retrieveMaxApiVersion());
        cs.sourceApiVersion = (_b = this.getFlag('apiversion')) !== null && _b !== void 0 ? _b : (await this.getSourceApiVersion());
        this.components.map((component) => {
            if (component instanceof source_deploy_retrieve_1.SourceComponent) {
                cs.add(component, source_deploy_retrieve_1.DestructiveChangesType.POST);
            }
            else {
                // a remote-only delete
                cs.add(new source_deploy_retrieve_1.SourceComponent({ name: component.fullName, type: component.type }), source_deploy_retrieve_1.DestructiveChangesType.POST);
            }
        });
        this.componentSet = cs;
        if (sourcepaths) {
            // determine if user is trying to delete a single file from a bundle, which is actually just an fs delete operation
            // and then a constructive deploy on the "new" bundle
            this.components
                .filter((comp) => { var _a; return ((_a = comp.type.strategies) === null || _a === void 0 ? void 0 : _a.adapter) === 'bundle' && comp instanceof source_deploy_retrieve_1.SourceComponent; })
                .map((bundle) => {
                sourcepaths.map(async (sourcepath) => {
                    // walkContent returns absolute paths while sourcepath will usually be relative
                    if (bundle.walkContent().find((content) => content.endsWith(sourcepath))) {
                        await this.moveBundleToManifest(bundle, sourcepath);
                    }
                });
            });
        }
        this.aborted = !(await this.handlePrompt());
        if (this.aborted)
            return;
        // fire predeploy event for the delete
        await this.lifecycle.emit('predeploy', this.components);
        this.isRest = this.isRestDeploy();
        this.ux.log(`*** Deleting with ${this.isRest ? 'REST' : 'SOAP'} API ***`);
        const deploy = await this.componentSet.deploy({
            usernameOrConnection: this.org.getUsername(),
            apiOptions: {
                rest: this.isRest,
                checkOnly: this.getFlag('checkonly', false),
                testLevel: this.getFlag('testlevel'),
            },
        });
        this.updateDeployId(deploy.id);
        if (!this.isJsonOutput()) {
            const progressFormatter = kit_1.env.getBoolean('SFDX_USE_PROGRESS_BAR', true)
                ? new deployProgressBarFormatter_1.DeployProgressBarFormatter(this.logger, this.ux)
                : new deployProgressStatusFormatter_1.DeployProgressStatusFormatter(this.logger, this.ux);
            progressFormatter.progress(deploy);
        }
        this.deployResult = await deploy.pollStatus({ timeout: this.getFlag('wait') });
        await this.lifecycle.emit('postdeploy', this.deployResult);
        // result.getFileResponses() will crawl the tree, but that would throw after the delete occurs.
        // Extract them here for updateTracking to use later
        this.fileResponses = this.mixedDeployDelete.delete.length
            ? this.mixedDeployDelete.delete
            : this.deployResult.getFileResponses();
    }
    /**
     * Checks the response status to determine whether the delete was successful.
     */
    async resolveSuccess() {
        var _a, _b;
        const status = (_b = (_a = this.deployResult) === null || _a === void 0 ? void 0 : _a.response) === null || _b === void 0 ? void 0 : _b.status;
        if (status !== source_deploy_retrieve_1.RequestStatus.Succeeded && !this.aborted) {
            this.setExitCode(1);
        }
        // if deploy failed OR the operation was cancelled, restore the stashed files if they exist
        else if (status !== source_deploy_retrieve_1.RequestStatus.Succeeded || this.aborted) {
            await Promise.all(this.mixedDeployDelete.delete.map(async (file) => {
                await this.restoreFileFromStash(file.filePath);
            }));
        }
        else if (this.mixedDeployDelete.delete.length) {
            // successful delete -> delete the stashed file
            await this.deleteStash();
        }
    }
    formatResult() {
        const formatterOptions = {
            verbose: this.getFlag('verbose', false),
        };
        this.deleteResultFormatter = this.mixedDeployDelete.deploy.length
            ? new deployResultFormatter_1.DeployResultFormatter(this.logger, this.ux, formatterOptions, this.deployResult)
            : new deleteResultFormatter_1.DeleteResultFormatter(this.logger, this.ux, formatterOptions, this.deployResult);
        // Only display results to console when JSON flag is unset.
        if (!this.isJsonOutput()) {
            this.deleteResultFormatter.display();
        }
        if (this.mixedDeployDelete.deploy.length && !this.aborted) {
            // override JSON output when we actually deployed
            const json = this.deleteResultFormatter.getJson();
            json.deletedSource = this.mixedDeployDelete.delete; // to match toolbelt json output
            json.outboundFiles = []; // to match toolbelt version
            json.deletes = json.deploys; // to match toolbelt version
            delete json.deploys;
            return json;
        }
        if (this.aborted) {
            return {
                status: 0,
                result: {
                    deletedSource: [],
                    outboundFiles: [],
                    deletes: [{}],
                },
            };
        }
        return this.deleteResultFormatter.getJson();
    }
    async maybeUpdateTracking() {
        if (this.getFlag('tracksource', false)) {
            return (0, trackingFunctions_1.updateTracking)({
                ux: this.ux,
                result: this.deployResult,
                tracking: this.tracking,
                fileResponses: this.fileResponses,
            });
        }
    }
    async deleteFilesLocally() {
        var _a, _b;
        if (!this.getFlag('checkonly') && ((_b = (_a = this.deployResult) === null || _a === void 0 ? void 0 : _a.response) === null || _b === void 0 ? void 0 : _b.status) === source_deploy_retrieve_1.RequestStatus.Succeeded) {
            const promises = [];
            this.components.map((component) => {
                // mixed delete/deploy operations have already been deleted and stashed
                if (!this.mixedDeployDelete.delete.length) {
                    if (component.content) {
                        const stats = fs.statSync(component.content);
                        if (stats.isDirectory()) {
                            promises.push(fsPromises.rm(component.content, { recursive: true }));
                        }
                        else {
                            promises.push(fsPromises.unlink(component.content));
                        }
                    }
                    if (component.xml) {
                        promises.push(fsPromises.unlink(component.xml));
                    }
                }
            });
            await Promise.all(promises);
        }
    }
    async moveFileToStash(file) {
        await fsPromises.mkdir(path.dirname(this.stashPath.get(file)), { recursive: true });
        await fsPromises.copyFile(file, this.stashPath.get(file));
        await fsPromises.unlink(file);
    }
    async restoreFileFromStash(file) {
        await fsPromises.rename(this.stashPath.get(file), file);
    }
    async deleteStash() {
        await fsPromises.rm(this.tempDir, { recursive: true, force: true });
    }
    async moveBundleToManifest(bundle, sourcepath) {
        // if one of the passed in sourcepaths is to a bundle component
        const fileName = path.basename(sourcepath);
        const fullName = path.join(bundle.name, fileName);
        this.mixedDeployDelete.delete.push({
            state: source_deploy_retrieve_1.ComponentStatus.Deleted,
            fullName,
            type: bundle.type.name,
            filePath: sourcepath,
        });
        // stash the file in case we need to restore it due to failed deploy/aborted command
        this.stashPath.set(sourcepath, path.join(this.tempDir, fullName));
        await this.moveFileToStash(sourcepath);
        // re-walk the directory to avoid picking up the deleted file
        this.mixedDeployDelete.deploy.push(...bundle.walkContent());
        // now remove the bundle from destructive changes and add to manifest
        // set the bundle as NOT marked for delete
        this.componentSet.destructiveChangesPost.delete(`${bundle.type.id}#${bundle.fullName}`);
        bundle.setMarkedForDelete(false);
        this.componentSet.add(bundle);
    }
    async handlePrompt() {
        if (!this.getFlag('noprompt')) {
            const remote = [];
            let local = [];
            const message = [];
            this.components.flatMap((component) => {
                if (component instanceof source_deploy_retrieve_1.SourceComponent) {
                    local.push(component.xml, ...component.walkContent());
                }
                else {
                    // remote only metadata
                    remote.push(`${component.type.name}:${component.fullName}`);
                }
            });
            if (this.mixedDeployDelete.delete.length) {
                local = this.mixedDeployDelete.delete.map((fr) => fr.fullName);
            }
            if (this.mixedDeployDelete.deploy.length) {
                message.push(messages.getMessage('deployPrompt', [[...new Set(this.mixedDeployDelete.deploy)].join('\n')]));
            }
            if (remote.length) {
                message.push(messages.getMessage('remotePrompt', [[...new Set(remote)].join('\n')]));
            }
            if (local.length) {
                if (message.length) {
                    // add a whitespace between remote and local
                    message.push('\n');
                }
                message.push('\n', messages.getMessage('localPrompt', [[...new Set(local)].join('\n')]));
            }
            message.push(this.getFlag('checkonly', false)
                ? messages.getMessage('areYouSureCheckOnly')
                : messages.getMessage('areYouSure'));
            return core_1.CliUx.ux.confirm(message.join(''));
        }
        return true;
    }
}
exports.Delete = Delete;
Delete.description = messages.getMessage('description');
Delete.examples = messages.getMessage('examples').split(os.EOL);
Delete.requiresProject = true;
Delete.requiresUsername = true;
Delete.flagsConfig = {
    checkonly: command_1.flags.boolean({
        char: 'c',
        description: messages.getMessage('flags.checkonly'),
        longDescription: messages.getMessage('flagsLong.checkonly'),
    }),
    wait: command_1.flags.minutes({
        char: 'w',
        default: kit_1.Duration.minutes(Delete.DEFAULT_WAIT_MINUTES),
        min: kit_1.Duration.minutes(1),
        description: messages.getMessage('flags.wait'),
        longDescription: messages.getMessage('flagsLong.wait'),
    }),
    testlevel: command_1.flags.enum({
        char: 'l',
        description: messages.getMessage('flags.testLevel'),
        longDescription: messages.getMessage('flagsLong.testLevel'),
        options: ['NoTestRun', 'RunLocalTests', 'RunAllTestsInOrg'],
        default: 'NoTestRun',
    }),
    noprompt: command_1.flags.boolean({
        char: 'r',
        description: messages.getMessage('flags.noprompt'),
    }),
    metadata: command_1.flags.array({
        char: 'm',
        description: messages.getMessage('flags.metadata'),
        longDescription: messages.getMessage('flagsLong.metadata'),
        exactlyOne: xorFlags,
    }),
    sourcepath: command_1.flags.array({
        char: 'p',
        description: messages.getMessage('flags.sourcepath'),
        longDescription: messages.getMessage('flagsLong.sourcepath'),
        exactlyOne: xorFlags,
    }),
    tracksource: command_1.flags.boolean({
        char: 't',
        description: messages.getMessage('flags.tracksource'),
        exclusive: ['checkonly'],
    }),
    forceoverwrite: command_1.flags.boolean({
        char: 'f',
        description: messages.getMessage('flags.forceoverwrite'),
        dependsOn: ['tracksource'],
    }),
    verbose: command_1.flags.builtin({
        description: messages.getMessage('flags.verbose'),
    }),
};
//# sourceMappingURL=delete.js.map