"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@salesforce/command");
const kit_1 = require("@salesforce/kit");
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const sourceCommand_1 = require("../../../sourceCommand");
const pullFormatter_1 = require("../../../formatters/source/pullFormatter");
const trackingFunctions_1 = require("../../../trackingFunctions");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/plugin-source', 'pull', [
    'flags.forceoverwrite',
    'description',
    'help',
    'flags.waitLong',
]);
class Pull extends sourceCommand_1.SourceCommand {
    constructor() {
        super(...arguments);
        this.lifecycleEventNames = ['preretrieve', 'postretrieve'];
    }
    async run() {
        await this.preChecks();
        await this.retrieve();
        // do not parallelize delete and retrieve...we only get to delete IF retrieve was successful
        await this.doDeletes(); // deletes includes its tracking file operations
        await (0, trackingFunctions_1.updateTracking)({
            result: this.retrieveResult,
            ux: this.ux,
            tracking: this.tracking,
        });
        this.ux.stopSpinner();
        return this.formatResult();
    }
    async preChecks() {
        this.ux.startSpinner('Loading source tracking information');
        this.tracking = await (0, trackingFunctions_1.trackingSetup)({
            commandName: 'force:source:pull',
            ignoreConflicts: this.getFlag('forceoverwrite', false),
            org: this.org,
            project: this.project,
            ux: this.ux,
        });
    }
    async doDeletes() {
        this.ux.setSpinnerStatus('Checking for deletes from the org and updating source tracking files');
        const changesToDelete = await this.tracking.getChanges({
            origin: 'remote',
            state: 'delete',
            format: 'SourceComponent',
        });
        this.deleteFileResponses = await this.tracking.deleteFilesAndUpdateTracking(changesToDelete);
    }
    async retrieve() {
        const componentSet = await this.tracking.remoteNonDeletesAsComponentSet();
        // if it is't local, add it as a
        if (componentSet.size === 0) {
            return;
        }
        componentSet.sourceApiVersion = await this.getSourceApiVersion();
        if (this.getFlag('apiversion')) {
            componentSet.apiVersion = this.getFlag('apiversion');
        }
        const mdapiRetrieve = await componentSet.retrieve({
            usernameOrConnection: this.org.getUsername(),
            merge: true,
            output: this.project.getDefaultPackage().fullPath,
        });
        this.ux.setSpinnerStatus('Retrieving metadata from the org');
        // assume: remote deletes that get deleted locally don't fire hooks?
        await this.lifecycle.emit('preretrieve', componentSet.toArray());
        this.retrieveResult = await mdapiRetrieve.pollStatus({ timeout: this.getFlag('wait') });
        // Assume: remote deletes that get deleted locally don't fire hooks.
        await this.lifecycle.emit('postretrieve', this.retrieveResult.getFileResponses());
    }
    resolveSuccess() {
        var _a;
        const StatusCodeMap = new Map([
            [source_deploy_retrieve_1.RequestStatus.Succeeded, 0],
            [source_deploy_retrieve_1.RequestStatus.Canceled, 1],
            [source_deploy_retrieve_1.RequestStatus.Failed, 1],
            [source_deploy_retrieve_1.RequestStatus.InProgress, 69],
            [source_deploy_retrieve_1.RequestStatus.Pending, 69],
            [source_deploy_retrieve_1.RequestStatus.Canceling, 69],
        ]);
        // there might not be a retrieveResult if we don't have anything to retrieve
        if (this.retrieveResult && this.retrieveResult.response.status) {
            this.setExitCode((_a = StatusCodeMap.get(this.retrieveResult.response.status)) !== null && _a !== void 0 ? _a : 1);
        }
    }
    formatResult() {
        const formatterOptions = {
            verbose: this.getFlag('verbose', false),
        };
        const formatter = new pullFormatter_1.PullResultFormatter(this.logger, this.ux, formatterOptions, this.retrieveResult, this.deleteFileResponses);
        // Only display results to console when JSON flag is unset.
        if (!this.isJsonOutput()) {
            formatter.display();
        }
        return formatter.getJson();
    }
}
exports.default = Pull;
Pull.aliases = ['force:source:beta:pull'];
Pull.description = messages.getMessage('description');
Pull.help = messages.getMessage('help');
Pull.flagsConfig = {
    forceoverwrite: command_1.flags.boolean({
        char: 'f',
        description: messages.getMessage('flags.forceoverwrite'),
    }),
    // TODO: use shared flags from plugin-source
    wait: command_1.flags.minutes({
        char: 'w',
        default: kit_1.Duration.minutes(33),
        min: kit_1.Duration.minutes(0),
        description: messages.getMessage('flags.waitLong'),
    }),
};
Pull.requiresUsername = true;
Pull.requiresProject = true;
//# sourceMappingURL=pull.js.map