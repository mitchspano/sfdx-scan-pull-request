"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Retrieve = void 0;
const os = require("os");
const path_1 = require("path");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const sourceCommand_1 = require("../../../sourceCommand");
const retrieveResultFormatter_1 = require("../../../formatters/retrieveResultFormatter");
const trackingFunctions_1 = require("../../../trackingFunctions");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'retrieve');
const spinnerMessages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'spinner');
class Retrieve extends sourceCommand_1.SourceCommand {
    constructor() {
        super(...arguments);
        this.lifecycleEventNames = ['preretrieve', 'postretrieve'];
    }
    async run() {
        await this.preChecks();
        await this.retrieve();
        this.resolveSuccess();
        await this.maybeUpdateTracking();
        return this.formatResult();
    }
    async preChecks() {
        // we need something to retrieve
        const retrieveInputs = [this.flags.manifest, this.flags.metadata, this.flags.sourcepath, this.flags.packagenames];
        if (!retrieveInputs.some((x) => x)) {
            throw new core_1.SfError(messages.getMessage('nothingToRetrieve'));
        }
        if (this.flags.tracksource) {
            this.tracking = await (0, trackingFunctions_1.trackingSetup)({
                ux: this.ux,
                org: this.org,
                project: this.project,
                ignoreConflicts: true,
                commandName: 'force:source:retrieve',
            });
        }
    }
    async retrieve() {
        this.ux.startSpinner(spinnerMessages.getMessage('retrieve.componentSetBuild'));
        this.componentSet = await source_deploy_retrieve_1.ComponentSetBuilder.build({
            apiversion: this.getFlag('apiversion'),
            sourceapiversion: await this.getSourceApiVersion(),
            packagenames: this.getFlag('packagenames'),
            sourcepath: this.getFlag('sourcepath'),
            manifest: this.flags.manifest && {
                manifestPath: this.getFlag('manifest'),
                directoryPaths: this.getPackageDirs(),
            },
            metadata: this.flags.metadata && {
                metadataEntries: this.getFlag('metadata'),
                directoryPaths: this.getPackageDirs(),
            },
        });
        if (this.getFlag('manifest') || this.getFlag('metadata')) {
            if (this.wantsToRetrieveCustomFields()) {
                this.ux.warn(messages.getMessage('wantsToRetrieveCustomFields'));
                this.componentSet.add({ fullName: source_deploy_retrieve_1.ComponentSet.WILDCARD, type: { id: 'customobject', name: 'CustomObject' } });
            }
        }
        if (this.getFlag('tracksource')) {
            // will throw if conflicts exist
            if (!this.getFlag('forceoverwrite')) {
                await (0, trackingFunctions_1.filterConflictsByComponentSet)({ tracking: this.tracking, components: this.componentSet, ux: this.ux });
            }
            const remoteDeletes = await this.tracking.getChanges({
                origin: 'remote',
                state: 'delete',
                format: 'string',
            });
            if (remoteDeletes.length) {
                this.ux.warn(messages.getMessage('retrieveWontDelete'));
            }
        }
        await this.lifecycle.emit('preretrieve', this.componentSet.toArray());
        this.ux.setSpinnerStatus(spinnerMessages.getMessage('retrieve.sendingRequest', [
            this.componentSet.sourceApiVersion || this.componentSet.apiVersion,
        ]));
        const mdapiRetrieve = await this.componentSet.retrieve({
            usernameOrConnection: this.org.getUsername(),
            merge: true,
            output: this.project.getDefaultPackage().fullPath,
            packageOptions: this.getFlag('packagenames'),
        });
        this.ux.setSpinnerStatus(spinnerMessages.getMessage('retrieve.polling'));
        this.retrieveResult = await mdapiRetrieve.pollStatus({ timeout: this.getFlag('wait') });
        await this.lifecycle.emit('postretrieve', this.retrieveResult.getFileResponses());
        this.ux.stopSpinner();
    }
    resolveSuccess() {
        var _a;
        const StatusCodeMap = new Map([
            [source_deploy_retrieve_1.RequestStatus.Succeeded, 0],
            [source_deploy_retrieve_1.RequestStatus.Canceled, 1],
            [source_deploy_retrieve_1.RequestStatus.Failed, 1],
            [source_deploy_retrieve_1.RequestStatus.InProgress, 69],
            [source_deploy_retrieve_1.RequestStatus.Pending, 69],
            [source_deploy_retrieve_1.RequestStatus.Canceling, 69],
        ]);
        this.setExitCode((_a = StatusCodeMap.get(this.retrieveResult.response.status)) !== null && _a !== void 0 ? _a : 1);
    }
    async formatResult() {
        const packages = [];
        const projectPath = await core_1.SfProject.resolveProjectPath();
        this.getFlag('packagenames', []).forEach((name) => {
            packages.push({ name, path: (0, path_1.join)(projectPath, name) });
        });
        const formatterOptions = {
            waitTime: this.getFlag('wait').quantity,
            verbose: this.getFlag('verbose', false),
            packages,
        };
        const formatter = new retrieveResultFormatter_1.RetrieveResultFormatter(this.logger, this.ux, formatterOptions, this.retrieveResult);
        // Only display results to console when JSON flag is unset.
        if (!this.isJsonOutput()) {
            formatter.display();
        }
        return formatter.getJson();
    }
    async maybeUpdateTracking() {
        if (this.getFlag('tracksource', false)) {
            return (0, trackingFunctions_1.updateTracking)({ tracking: this.tracking, result: this.retrieveResult, ux: this.ux });
        }
    }
    wantsToRetrieveCustomFields() {
        const hasCustomField = this.componentSet.has({
            type: { name: 'CustomField', id: 'customfield' },
            fullName: source_deploy_retrieve_1.ComponentSet.WILDCARD,
        });
        const hasCustomObject = this.componentSet.has({
            type: { name: 'CustomObject', id: 'customobject' },
            fullName: source_deploy_retrieve_1.ComponentSet.WILDCARD,
        });
        return hasCustomField && !hasCustomObject;
    }
}
exports.Retrieve = Retrieve;
Retrieve.description = messages.getMessage('description');
Retrieve.examples = messages.getMessage('examples').split(os.EOL);
Retrieve.requiresProject = true;
Retrieve.requiresUsername = true;
Retrieve.flagsConfig = {
    apiversion: command_1.flags.builtin({
        /* eslint-disable-next-line @typescript-eslint/ban-ts-comment */
        // @ts-ignore force char override for backward compat
        char: 'a',
    }),
    sourcepath: command_1.flags.array({
        char: 'p',
        description: messages.getMessage('flags.sourcePath'),
        longDescription: messages.getMessage('flagsLong.sourcePath'),
        exclusive: ['manifest', 'metadata'],
    }),
    wait: command_1.flags.minutes({
        char: 'w',
        default: kit_1.Duration.minutes(sourceCommand_1.SourceCommand.DEFAULT_WAIT_MINUTES),
        min: kit_1.Duration.minutes(1),
        description: messages.getMessage('flags.wait'),
        longDescription: messages.getMessage('flagsLong.wait'),
    }),
    manifest: command_1.flags.filepath({
        char: 'x',
        description: messages.getMessage('flags.manifest'),
        longDescription: messages.getMessage('flagsLong.manifest'),
        exclusive: ['metadata', 'sourcepath'],
    }),
    metadata: command_1.flags.array({
        char: 'm',
        description: messages.getMessage('flags.metadata'),
        longDescription: messages.getMessage('flagsLong.metadata'),
        exclusive: ['manifest', 'sourcepath'],
    }),
    packagenames: command_1.flags.array({
        char: 'n',
        description: messages.getMessage('flags.packagename'),
    }),
    tracksource: command_1.flags.boolean({
        char: 't',
        description: messages.getMessage('flags.tracksource'),
    }),
    forceoverwrite: command_1.flags.boolean({
        char: 'f',
        description: messages.getMessage('flags.forceoverwrite'),
        dependsOn: ['tracksource'],
    }),
    verbose: command_1.flags.builtin({
        description: messages.getMessage('flags.verbose'),
    }),
};
//# sourceMappingURL=retrieve.js.map