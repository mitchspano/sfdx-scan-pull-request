"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Report = void 0;
const os = require("os");
const path_1 = require("path");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const sourceCommand_1 = require("../../../../sourceCommand");
const stash_1 = require("../../../../stash");
const retrieveResultFormatter_1 = require("../../../../formatters/mdapi/retrieveResultFormatter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'md.retrieve');
const spinnerMessages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'spinner');
class Report extends sourceCommand_1.SourceCommand {
    async run() {
        await this.report();
        this.resolveSuccess();
        return this.formatResult();
    }
    async report() {
        let retrieveId = this.getFlag('jobid');
        if (!retrieveId) {
            // Get stashed retrieve data
            const mdRetrieveStash = stash_1.Stash.get('MDAPI_RETRIEVE');
            // throw if no Retrieve ID in stash either
            if (!(mdRetrieveStash === null || mdRetrieveStash === void 0 ? void 0 : mdRetrieveStash.jobid)) {
                throw new core_1.SfError(messages.getMessage('MissingRetrieveId'), 'MissingRetrieveId');
            }
            retrieveId = mdRetrieveStash.jobid;
            this.retrieveTargetDir = this.resolveOutputDir(mdRetrieveStash === null || mdRetrieveStash === void 0 ? void 0 : mdRetrieveStash.retrievetargetdir);
            this.zipFileName = this.resolveZipFileName(mdRetrieveStash === null || mdRetrieveStash === void 0 ? void 0 : mdRetrieveStash.zipfilename);
            this.unzip = mdRetrieveStash === null || mdRetrieveStash === void 0 ? void 0 : mdRetrieveStash.unzip;
        }
        else {
            this.retrieveTargetDir = this.resolveOutputDir(this.getFlag('retrievetargetdir'));
            this.zipFileName = this.resolveZipFileName(this.getFlag('zipfilename'));
            this.unzip = this.getFlag('unzip');
        }
        const waitFlag = this.getFlag('wait');
        this.wait = waitFlag.minutes === -1 ? kit_1.Duration.days(7) : waitFlag;
        this.isAsync = this.wait.quantity === 0;
        this.ux.startSpinner(spinnerMessages.getMessage('retrieve.main', [this.org.getUsername()]));
        this.mdapiRetrieve = new source_deploy_retrieve_1.MetadataApiRetrieve({
            id: retrieveId,
            usernameOrConnection: this.org.getUsername(),
            output: this.retrieveTargetDir,
            format: 'metadata',
            zipFileName: this.zipFileName,
            unzip: this.unzip,
        });
        if (this.isAsync) {
            // For async reports (wait == 0) we just check the status and call post()
            // to write the zip file if it's done.
            this.retrieveStatus = await this.mdapiRetrieve.checkStatus();
            if (this.retrieveStatus.done) {
                this.retrieveResult = await this.mdapiRetrieve.post(this.retrieveStatus);
            }
        }
        else {
            this.ux.setSpinnerStatus(spinnerMessages.getMessage('retrieve.polling'));
            this.retrieveResult = await this.mdapiRetrieve.pollStatus(1000, this.wait.seconds);
        }
        this.ux.stopSpinner();
    }
    // No-op implementation since any RetrieveResult status would be a success.
    // The only time this command would report an error is if it failed
    // flag parsing or some error during the request, and those are captured
    // by the command framework.
    /* eslint-disable-next-line @typescript-eslint/no-empty-function */
    resolveSuccess() { }
    formatResult() {
        if (this.isAsync && !this.retrieveResult) {
            this.ux.log('');
            this.ux.log(`Retrieve Status: ${this.retrieveStatus.status}`);
            return {
                done: this.retrieveStatus.done,
                id: this.retrieveStatus.id,
                state: this.retrieveStatus.status,
                status: this.retrieveStatus.status,
                timedOut: true,
            };
        }
        const formatterOptions = {
            waitTime: this.wait.quantity,
            verbose: this.getFlag('verbose', false),
            retrieveTargetDir: this.retrieveTargetDir,
            zipFileName: this.zipFileName,
            unzip: this.unzip,
        };
        const formatter = new retrieveResultFormatter_1.RetrieveResultFormatter(this.logger, this.ux, formatterOptions, this.retrieveResult);
        if (!this.isJsonOutput()) {
            formatter.display();
        }
        return formatter.getJson();
    }
    resolveZipFileName(zipFileName) {
        // If no file extension was provided append, '.zip'
        if (zipFileName && !(0, path_1.extname)(zipFileName)) {
            zipFileName += '.zip';
        }
        return zipFileName || 'unpackaged.zip';
    }
    resolveOutputDir(dirPath) {
        return this.ensureFlagPath({
            flagName: 'retrievetargetdir',
            path: dirPath,
            type: 'dir',
        });
    }
}
exports.Report = Report;
Report.aliases = ['force:mdapi:beta:retrieve:report'];
Report.description = messages.getMessage('reportCmd.description');
Report.examples = messages.getMessage('reportCmd.examples').split(os.EOL);
Report.requiresUsername = true;
Report.flagsConfig = {
    // NOTE: this flag is not required because the value is stashed
    // from the force:mdapi:retrieve command.
    retrievetargetdir: command_1.flags.directory({
        char: 'r',
        description: messages.getMessage('flags.retrievetargetdir'),
        longDescription: messages.getMessage('flagsLong.retrievetargetdir'),
    }),
    jobid: command_1.flags.id({
        char: 'i',
        description: messages.getMessage('flags.jobid'),
        longDescription: messages.getMessage('flagsLong.jobid'),
    }),
    zipfilename: command_1.flags.string({
        char: 'n',
        description: messages.getMessage('flags.zipfilename'),
        longDescription: messages.getMessage('flagsLong.zipfilename'),
    }),
    unzip: command_1.flags.boolean({
        char: 'z',
        description: messages.getMessage('flags.unzip'),
        longDescription: messages.getMessage('flagsLong.unzip'),
    }),
    wait: command_1.flags.minutes({
        char: 'w',
        description: messages.getMessage('flags.wait'),
        longDescription: messages.getMessage('flagsLong.wait'),
        min: -1,
        default: kit_1.Duration.minutes(1440), // 24 hours is a reasonable default versus -1 (no timeout)
    }),
    verbose: command_1.flags.builtin({
        description: messages.getMessage('flags.verbose'),
        longDescription: messages.getMessage('flagsLong.verbose'),
    }),
};
//# sourceMappingURL=report.js.map