"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Deploy = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os_1 = require("os");
const command_1 = require("@salesforce/command");
const kit_1 = require("@salesforce/kit");
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const deployCommand_1 = require("../../../deployCommand");
const mdDeployResultFormatter_1 = require("../../../formatters/mdapi/mdDeployResultFormatter");
const deployProgressBarFormatter_1 = require("../../../formatters/deployProgressBarFormatter");
const deployProgressStatusFormatter_1 = require("../../../formatters/deployProgressStatusFormatter");
const mdDeployAsyncResultFormatter_1 = require("../../../formatters/mdapi/mdDeployAsyncResultFormatter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'md.deploy');
const xorFlags = ['zipfile', 'validateddeployrequestid', 'deploydir'];
class Deploy extends deployCommand_1.DeployCommand {
    async run() {
        await this.deploy();
        this.resolveSuccess();
        return this.formatResult();
    }
    async deploy() {
        const waitFlag = this.getFlag('wait');
        const waitDuration = waitFlag.minutes === -1 ? kit_1.Duration.days(7) : waitFlag;
        this.isAsync = waitDuration.quantity === 0;
        this.isRest = this.isRestDeploy();
        if (this.isAsync && (this.flags.coverageformatters || this.flags.junit)) {
            this.warn(messages.getMessage('asyncCoverageJunitWarning'));
        }
        if (this.flags.validateddeployrequestid) {
            this.deployResult = await this.deployRecentValidation();
            return;
        }
        const deploymentOptions = this.flags.zipfile
            ? { zipPath: this.flags.zipfile }
            : { mdapiPath: this.flags.deploydir };
        // still here?  we need to deploy a zip file then
        const deploy = new source_deploy_retrieve_1.MetadataApiDeploy({
            usernameOrConnection: this.org.getUsername(),
            ...deploymentOptions,
            apiOptions: {
                // properties that will always have values
                ...{
                    purgeOnDelete: this.getFlag('purgeondelete', false),
                    ignoreWarnings: this.getFlag('ignorewarnings', false),
                    rollbackOnError: !this.getFlag('ignoreerrors', false),
                    checkOnly: this.getFlag('checkonly', false),
                    singlePackage: this.getFlag('singlepackage', false),
                    rest: this.isRest,
                },
                // if runTests is defaulted as 'NoTestRun' and deploying to prod, you'll get this error
                // https://github.com/forcedotcom/cli/issues/1542
                // add additional properties conditionally ()
                ...(this.getFlag('testlevel') ? { testLevel: this.getFlag('testlevel') } : {}),
                ...(this.getFlag('runtests') ? { runTests: this.getFlag('runtests') } : {}),
            },
        });
        await deploy.start();
        this.asyncDeployResult = { id: deploy.id };
        this.updateDeployId(deploy.id);
        // we might not know the source api version without unzipping a zip file, so we don't use componentSet
        this.ux.log((0, deployCommand_1.getVersionMessage)('Deploying', undefined, this.isRest));
        if (!this.isAsync) {
            if (!this.isJsonOutput()) {
                const progressFormatter = kit_1.env.getBoolean('SFDX_USE_PROGRESS_BAR', true)
                    ? new deployProgressBarFormatter_1.DeployProgressBarFormatter(this.logger, this.ux)
                    : new deployProgressStatusFormatter_1.DeployProgressStatusFormatter(this.logger, this.ux);
                progressFormatter.progress(deploy);
            }
            this.displayDeployId(deploy.id);
            this.deployResult = await deploy.pollStatus({ frequency: kit_1.Duration.milliseconds(500), timeout: waitDuration });
        }
    }
    formatResult() {
        var _a, _b;
        this.resultsDir = this.resolveOutputDir(this.getFlag('coverageformatters', undefined), this.getFlag('junit'), this.getFlag('resultsdir'), (_b = (_a = this.deployResult) === null || _a === void 0 ? void 0 : _a.response) === null || _b === void 0 ? void 0 : _b.id, true);
        const formatterOptions = {
            concise: this.getFlag('concise', false),
            verbose: this.getFlag('verbose', false),
            username: this.org.getUsername(),
            coverageOptions: this.getCoverageFormattersOptions(this.getFlag('coverageformatters', undefined)),
            junitTestResults: this.flags.junit,
            resultsDir: this.resultsDir,
            testsRan: this.getFlag('testlevel', 'NoTestRun') !== 'NoTestRun',
        };
        const formatter = this.isAsync
            ? new mdDeployAsyncResultFormatter_1.MdDeployAsyncResultFormatter(this.logger, this.ux, formatterOptions, this.asyncDeployResult)
            : new mdDeployResultFormatter_1.MdDeployResultFormatter(this.logger, this.ux, formatterOptions, this.deployResult);
        if (!this.isAsync) {
            this.maybeCreateRequestedReports();
        }
        // Only display results to console when JSON flag is unset.
        if (!this.isJsonOutput()) {
            formatter.display();
        }
        return formatter.getJson();
    }
}
exports.Deploy = Deploy;
Deploy.aliases = ['force:mdapi:beta:deploy'];
Deploy.description = messages.getMessage('description');
Deploy.examples = messages.getMessage('examples').split(os_1.EOL);
Deploy.requiresUsername = true;
Deploy.flagsConfig = {
    checkonly: command_1.flags.boolean({
        char: 'c',
        description: messages.getMessage('flags.checkOnly'),
        longDescription: messages.getMessage('flagsLong.checkOnly'),
    }),
    deploydir: command_1.flags.directory({
        char: 'd',
        description: messages.getMessage('flags.deployDir'),
        longDescription: messages.getMessage('flagsLong.deployDir'),
        exactlyOne: xorFlags,
    }),
    wait: command_1.flags.minutes({
        char: 'w',
        description: messages.getMessage('flags.wait', [0]),
        longDescription: messages.getMessage('flagsLong.wait', [0]),
        default: kit_1.Duration.minutes(0),
        min: -1,
    }),
    testlevel: command_1.flags.enum({
        char: 'l',
        description: messages.getMessage('flags.testLevel'),
        longDescription: messages.getMessage('flagsLong.testLevel'),
        options: ['NoTestRun', 'RunSpecifiedTests', 'RunLocalTests', 'RunAllTestsInOrg'],
    }),
    runtests: command_1.flags.array({
        char: 'r',
        description: messages.getMessage('flags.runTests'),
        longDescription: messages.getMessage('flagsLong.runTests'),
    }),
    ignoreerrors: command_1.flags.boolean({
        char: 'o',
        description: messages.getMessage('flags.ignoreErrors'),
        longDescription: messages.getMessage('flagsLong.ignoreErrors'),
    }),
    ignorewarnings: command_1.flags.boolean({
        char: 'g',
        description: messages.getMessage('flags.ignoreWarnings'),
        longDescription: messages.getMessage('flagsLong.ignoreWarnings'),
    }),
    validateddeployrequestid: command_1.flags.id({
        char: 'q',
        description: messages.getMessage('flags.validatedDeployRequestId'),
        longDescription: messages.getMessage('flagsLong.validatedDeployRequestId'),
        exactlyOne: xorFlags,
        exclusive: ['testlevel', 'runtests', 'checkonly'],
        validate: deployCommand_1.DeployCommand.isValidDeployId,
    }),
    verbose: command_1.flags.builtin({
        description: messages.getMessage('flags.verbose'),
        longDescription: messages.getMessage('flagsLong.verbose'),
    }),
    zipfile: command_1.flags.filepath({
        char: 'f',
        description: messages.getMessage('flags.zipFile'),
        longDescription: messages.getMessage('flagsLong.zipFile'),
        exactlyOne: xorFlags,
    }),
    singlepackage: command_1.flags.boolean({
        char: 's',
        description: messages.getMessage('flags.singlePackage'),
        longDescription: messages.getMessage('flagsLong.singlePackage'),
    }),
    soapdeploy: command_1.flags.boolean({
        description: messages.getMessage('flags.soapDeploy'),
        longDescription: messages.getMessage('flagsLong.soapDeploy'),
    }),
    purgeondelete: command_1.flags.boolean({
        description: messages.getMessage('flags.purgeOnDelete'),
    }),
    concise: command_1.flags.builtin({
        description: messages.getMessage('flags.concise'),
    }),
    resultsdir: command_1.flags.directory({
        description: messages.getMessage('flags.resultsDir'),
    }),
    coverageformatters: command_1.flags.array({
        description: messages.getMessage('flags.coverageFormatters'),
        options: deployCommand_1.reportsFormatters,
        helpValue: deployCommand_1.reportsFormatters.join(','),
    }),
    junit: command_1.flags.boolean({ description: messages.getMessage('flags.junit') }),
};
//# sourceMappingURL=deploy.js.map