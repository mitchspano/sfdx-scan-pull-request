"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Convert = void 0;
const os = require("os");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const sourceCommand_1 = require("../../../sourceCommand");
const convertResultFormatter_1 = require("../../../formatters/mdapi/convertResultFormatter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'md.convert');
class Convert extends sourceCommand_1.SourceCommand {
    async run() {
        await this.convert();
        this.resolveSuccess();
        return this.formatResult();
    }
    async convert() {
        this.rootDir = this.resolveRootDir(this.getFlag('rootdir'));
        this.outputDir = this.resolveOutputDir(this.getFlag('outputdir'));
        const metadatapath = this.resolveMetadataPaths(this.getFlag('metadatapath'));
        const manifest = this.resolveManifest(this.getFlag('manifest'));
        const metadata = this.getFlag('metadata');
        let paths;
        if (metadatapath) {
            paths = metadatapath;
        }
        else if (!manifest && !metadata) {
            paths = [this.rootDir];
        }
        this.componentSet = await source_deploy_retrieve_1.ComponentSetBuilder.build({
            sourcepath: paths,
            manifest: manifest && {
                manifestPath: manifest,
                directoryPaths: [this.rootDir],
            },
            metadata: metadata && {
                metadataEntries: metadata,
                directoryPaths: [this.rootDir],
            },
        });
        const numOfComponents = this.componentSet.getSourceComponents().toArray().length;
        if (numOfComponents > 0) {
            this.ux.startSpinner(`Converting ${numOfComponents} metadata components`);
            const converter = new source_deploy_retrieve_1.MetadataConverter();
            this.convertResult = await converter.convert(this.componentSet, 'source', {
                type: 'directory',
                outputDirectory: this.outputDir,
                genUniqueDir: false,
            });
            this.ux.stopSpinner();
        }
    }
    // No-op.  Any failure would throw an error.  If no error, it's successful.
    // The framework provides this behavior.
    /* eslint-disable-next-line @typescript-eslint/no-empty-function */
    resolveSuccess() { }
    formatResult() {
        const formatter = new convertResultFormatter_1.ConvertResultFormatter(this.logger, this.ux, this.convertResult);
        if (!this.isJsonOutput()) {
            formatter.display();
        }
        return formatter.getJson();
    }
    resolveRootDir(rootDir) {
        return this.ensureFlagPath({
            flagName: 'rootdir',
            path: rootDir,
            type: 'dir',
            throwOnENOENT: true,
        });
    }
    resolveOutputDir(outputDir) {
        return this.ensureFlagPath({
            flagName: 'outputdir',
            path: outputDir || this.project.getDefaultPackage().path,
            type: 'dir',
        });
    }
    resolveManifest(manifestPath) {
        if (manifestPath === null || manifestPath === void 0 ? void 0 : manifestPath.length) {
            return this.ensureFlagPath({
                flagName: 'manifest',
                path: manifestPath,
                type: 'file',
                throwOnENOENT: true,
            });
        }
    }
    resolveMetadataPaths(metadataPaths) {
        const resolvedMetadataPaths = [];
        if (metadataPaths === null || metadataPaths === void 0 ? void 0 : metadataPaths.length) {
            metadataPaths.forEach((mdPath) => {
                if (mdPath === null || mdPath === void 0 ? void 0 : mdPath.length) {
                    resolvedMetadataPaths.push(this.ensureFlagPath({
                        flagName: 'metadatapath',
                        path: mdPath,
                        type: 'any',
                        throwOnENOENT: true,
                    }));
                }
            });
        }
        return resolvedMetadataPaths.length ? resolvedMetadataPaths : undefined;
    }
}
exports.Convert = Convert;
Convert.aliases = ['force:mdapi:beta:convert'];
Convert.description = messages.getMessage('description');
Convert.examples = messages.getMessage('examples').split(os.EOL);
Convert.requiresProject = true;
Convert.flagsConfig = {
    rootdir: command_1.flags.directory({
        char: 'r',
        description: messages.getMessage('flags.rootdir'),
        longDescription: messages.getMessage('flagsLong.rootdir'),
        required: true,
    }),
    outputdir: command_1.flags.directory({
        char: 'd',
        description: messages.getMessage('flags.outputdir'),
        longDescription: messages.getMessage('flagsLong.outputdir'),
    }),
    manifest: command_1.flags.string({
        char: 'x',
        description: messages.getMessage('flags.manifest'),
        longDescription: messages.getMessage('flagsLong.manifest'),
    }),
    metadatapath: command_1.flags.array({
        char: 'p',
        description: messages.getMessage('flags.metadatapath'),
        longDescription: messages.getMessage('flagsLong.metadatapath'),
        exclusive: ['manifest', 'metadata'],
    }),
    metadata: command_1.flags.array({
        char: 'm',
        description: messages.getMessage('flags.metadata'),
        longDescription: messages.getMessage('flagsLong.metadata'),
        exclusive: ['manifest', 'metadatapath'],
    }),
};
//# sourceMappingURL=convert.js.map