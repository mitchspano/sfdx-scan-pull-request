"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Retrieve = void 0;
const os = require("os");
const path_1 = require("path");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const sourceCommand_1 = require("../../../sourceCommand");
const stash_1 = require("../../../stash");
const retrieveResultFormatter_1 = require("../../../formatters/mdapi/retrieveResultFormatter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'md.retrieve');
const spinnerMessages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'spinner');
class Retrieve extends sourceCommand_1.SourceCommand {
    async run() {
        await this.retrieve();
        this.resolveSuccess();
        return this.formatResult();
    }
    async retrieve() {
        var _a;
        const packagenames = this.getFlag('packagenames');
        if (!packagenames) {
            this.sourceDir = this.resolveRootDir(this.getFlag('sourcedir'));
        }
        this.retrieveTargetDir = this.resolveOutputDir(this.getFlag('retrievetargetdir'));
        const manifest = this.resolveManifest(this.getFlag('unpackaged'));
        const singlePackage = this.getFlag('singlepackage');
        this.zipFileName = this.resolveZipFileName(this.getFlag('zipfilename'));
        this.unzip = this.getFlag('unzip');
        const waitFlag = this.getFlag('wait');
        this.wait = waitFlag.minutes === -1 ? kit_1.Duration.days(7) : waitFlag;
        this.isAsync = this.wait.quantity === 0;
        if (singlePackage && (packagenames === null || packagenames === void 0 ? void 0 : packagenames.length) > 1) {
            throw new core_1.SfError(messages.getMessage('InvalidPackageNames', [packagenames.toString()]), 'InvalidPackageNames');
        }
        this.ux.startSpinner(spinnerMessages.getMessage('retrieve.main', [this.org.getUsername()]));
        this.ux.setSpinnerStatus(spinnerMessages.getMessage('retrieve.componentSetBuild'));
        this.componentSet = await source_deploy_retrieve_1.ComponentSetBuilder.build({
            apiversion: (_a = this.getFlag('apiversion')) !== null && _a !== void 0 ? _a : (await this.org.retrieveMaxApiVersion()),
            packagenames,
            sourcepath: this.sourceDir ? [this.sourceDir] : undefined,
            manifest: manifest && {
                manifestPath: manifest,
                directoryPaths: [],
            },
        });
        await this.lifecycle.emit('preretrieve', { packageXmlPath: manifest });
        this.ux.setSpinnerStatus(spinnerMessages.getMessage('retrieve.sendingRequest', [this.componentSet.apiVersion]));
        this.mdapiRetrieve = await this.componentSet.retrieve({
            usernameOrConnection: this.org.getUsername(),
            output: this.retrieveTargetDir,
            packageOptions: this.getFlag('packagenames'),
            format: 'metadata',
            singlePackage,
            zipFileName: this.zipFileName,
            unzip: this.unzip,
        });
        stash_1.Stash.set('MDAPI_RETRIEVE', {
            jobid: this.mdapiRetrieve.id,
            retrievetargetdir: this.retrieveTargetDir,
            zipfilename: this.zipFileName,
            unzip: this.unzip,
        });
        this.ux.log(`Retrieve ID: ${this.mdapiRetrieve.id}`);
        if (this.isAsync) {
            this.ux.stopSpinner('queued');
        }
        else {
            this.ux.setSpinnerStatus(spinnerMessages.getMessage('retrieve.polling'));
            this.retrieveResult = await this.mdapiRetrieve.pollStatus({
                frequency: kit_1.Duration.milliseconds(1000),
                timeout: this.wait,
            });
            this.ux.stopSpinner();
        }
    }
    resolveSuccess() {
        var _a;
        const StatusCodeMap = new Map([
            [source_deploy_retrieve_1.RequestStatus.Succeeded, 0],
            [source_deploy_retrieve_1.RequestStatus.Canceled, 1],
            [source_deploy_retrieve_1.RequestStatus.Failed, 1],
            [source_deploy_retrieve_1.RequestStatus.InProgress, 69],
            [source_deploy_retrieve_1.RequestStatus.Pending, 69],
            [source_deploy_retrieve_1.RequestStatus.Canceling, 69],
        ]);
        if (!this.isAsync) {
            this.setExitCode((_a = StatusCodeMap.get(this.retrieveResult.response.status)) !== null && _a !== void 0 ? _a : 1);
        }
    }
    formatResult() {
        // async result
        if (this.isAsync) {
            let cmdFlags = `--jobid ${this.mdapiRetrieve.id} --retrievetargetdir ${this.retrieveTargetDir}`;
            const targetusernameFlag = this.getFlag('targetusername');
            if (targetusernameFlag) {
                cmdFlags += ` --targetusername ${targetusernameFlag}`;
            }
            this.ux.log('');
            this.ux.log(messages.getMessage('checkStatus', [cmdFlags]));
            return {
                done: false,
                id: this.mdapiRetrieve.id,
                state: 'Queued',
                status: 'Queued',
                timedOut: true,
            };
        }
        else {
            const formatterOptions = {
                waitTime: this.wait.quantity,
                verbose: this.getFlag('verbose', false),
                retrieveTargetDir: this.retrieveTargetDir,
                zipFileName: this.zipFileName,
                unzip: this.unzip,
            };
            const formatter = new retrieveResultFormatter_1.RetrieveResultFormatter(this.logger, this.ux, formatterOptions, this.retrieveResult);
            if (!this.isJsonOutput()) {
                formatter.display();
            }
            return formatter.getJson();
        }
    }
    resolveZipFileName(zipFileName) {
        // If no file extension was provided append, '.zip'
        if (zipFileName && !(0, path_1.extname)(zipFileName)) {
            zipFileName += '.zip';
        }
        return zipFileName || 'unpackaged.zip';
    }
    resolveProjectPath() {
        try {
            return core_1.SfProject.getInstance().getDefaultPackage().fullPath;
        }
        catch (error) {
            this.logger.debug('No SFDX project found for default package directory');
        }
    }
    resolveRootDir(rootDir) {
        return rootDir
            ? this.ensureFlagPath({
                flagName: 'sourcedir',
                path: rootDir,
                type: 'dir',
                throwOnENOENT: true,
            })
            : this.resolveProjectPath();
    }
    resolveOutputDir(outputDir) {
        return this.ensureFlagPath({
            flagName: 'retrievetargetdir',
            path: outputDir,
            type: 'dir',
        });
    }
    resolveManifest(manifestPath) {
        if (manifestPath === null || manifestPath === void 0 ? void 0 : manifestPath.length) {
            return this.ensureFlagPath({
                flagName: 'unpackaged',
                path: manifestPath,
                type: 'file',
                throwOnENOENT: true,
            });
        }
    }
}
exports.Retrieve = Retrieve;
Retrieve.aliases = ['force:mdapi:beta:retrieve'];
Retrieve.description = messages.getMessage('retrieveCmd.description');
Retrieve.examples = messages.getMessage('retrieveCmd.examples').split(os.EOL);
Retrieve.requiresUsername = true;
Retrieve.flagsConfig = {
    retrievetargetdir: command_1.flags.directory({
        char: 'r',
        description: messages.getMessage('flags.retrievetargetdir'),
        longDescription: messages.getMessage('flagsLong.retrievetargetdir'),
        required: true,
    }),
    unpackaged: command_1.flags.filepath({
        char: 'k',
        description: messages.getMessage('flags.unpackaged'),
        longDescription: messages.getMessage('flagsLong.unpackaged'),
        exclusive: ['sourcedir', 'packagenames'],
    }),
    sourcedir: command_1.flags.directory({
        char: 'd',
        description: messages.getMessage('flags.sourcedir'),
        longDescription: messages.getMessage('flagsLong.sourcedir'),
        exclusive: ['unpackaged', 'packagenames'],
    }),
    packagenames: command_1.flags.array({
        char: 'p',
        description: messages.getMessage('flags.packagenames'),
        longDescription: messages.getMessage('flagsLong.packagenames'),
        exclusive: ['sourcedir', 'unpackaged'],
    }),
    singlepackage: command_1.flags.boolean({
        char: 's',
        description: messages.getMessage('flags.singlepackage'),
        longDescription: messages.getMessage('flagsLong.singlepackage'),
    }),
    zipfilename: command_1.flags.string({
        char: 'n',
        description: messages.getMessage('flags.zipfilename'),
        longDescription: messages.getMessage('flagsLong.zipfilename'),
    }),
    unzip: command_1.flags.boolean({
        char: 'z',
        description: messages.getMessage('flags.unzip'),
        longDescription: messages.getMessage('flagsLong.unzip'),
    }),
    wait: command_1.flags.minutes({
        char: 'w',
        description: messages.getMessage('flags.wait'),
        longDescription: messages.getMessage('flagsLong.wait'),
        default: kit_1.Duration.minutes(1440), // 24 hours is a reasonable default versus -1 (no timeout)
    }),
    apiversion: command_1.flags.builtin({
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore force char override for backward compat
        char: 'a',
        description: messages.getMessage('flags.apiversion'),
        longDescription: messages.getMessage('flagsLong.apiversion'),
    }),
    verbose: command_1.flags.builtin({
        description: messages.getMessage('flags.verbose'),
        longDescription: messages.getMessage('flagsLong.verbose'),
    }),
};
//# sourceMappingURL=retrieve.js.map