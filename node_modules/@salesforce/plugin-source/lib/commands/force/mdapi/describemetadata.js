"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DescribeMetadata = void 0;
const os = require("os");
const fs = require("fs");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const sourceCommand_1 = require("../../../sourceCommand");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'md.describe');
class DescribeMetadata extends sourceCommand_1.SourceCommand {
    async run() {
        await this.describe();
        this.resolveSuccess();
        return this.formatResult();
    }
    async describe() {
        const apiversion = this.getFlag('apiversion');
        const resultfile = this.getFlag('resultfile');
        if (resultfile) {
            this.targetFilePath = this.ensureFlagPath({ flagName: 'resultfile', path: resultfile, type: 'file' });
        }
        const connection = this.org.getConnection();
        this.describeResult = await connection.metadata.describe(apiversion);
        if (this.flags.filterknown) {
            this.logger.debug('Filtering for only metadata types unregistered in the CLI');
            const registry = new source_deploy_retrieve_1.RegistryAccess();
            this.describeResult.metadataObjects = this.describeResult.metadataObjects.filter((md) => {
                try {
                    // An error is thrown when a type can't be found by name, and we want
                    // the ones that can't be found.
                    registry.getTypeByName(md.xmlName);
                    return false;
                }
                catch (e) {
                    return true;
                }
            });
        }
    }
    // No-op implementation since any describe metadata status would be a success.
    // The only time this command would report an error is if it failed
    // flag parsing or some error during the request, and those are captured
    // by the command framework.
    /* eslint-disable-next-line @typescript-eslint/no-empty-function */
    resolveSuccess() { }
    formatResult() {
        if (this.targetFilePath) {
            fs.writeFileSync(this.targetFilePath, JSON.stringify(this.describeResult, null, 2));
            this.ux.log(`Wrote result file to ${this.targetFilePath}.`);
        }
        else if (!this.isJsonOutput()) {
            this.ux.styledJSON(this.describeResult);
        }
        return this.describeResult;
    }
}
exports.DescribeMetadata = DescribeMetadata;
DescribeMetadata.description = messages.getMessage('description');
DescribeMetadata.examples = messages.getMessage('examples').split(os.EOL);
DescribeMetadata.requiresUsername = true;
DescribeMetadata.flagsConfig = {
    apiversion: command_1.flags.builtin({
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore force char override for backward compat
        char: 'a',
        description: messages.getMessage('flags.apiversion'),
        longDescription: messages.getMessage('flagsLong.apiversion'),
    }),
    resultfile: command_1.flags.filepath({
        char: 'f',
        description: messages.getMessage('flags.resultfile'),
        longDescription: messages.getMessage('flagsLong.resultfile'),
    }),
    filterknown: command_1.flags.boolean({
        char: 'k',
        description: messages.getMessage('flags.filterknown'),
        longDescription: messages.getMessage('flagsLong.filterknown'),
        hidden: true,
    }),
};
//# sourceMappingURL=describemetadata.js.map