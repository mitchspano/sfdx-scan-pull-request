"use strict";

var _context4;

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _Object$defineProperties = require("@babel/runtime-corejs3/core-js-stable/object/define-properties");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors");

var _forEachInstanceProperty = require("@babel/runtime-corejs3/core-js-stable/instance/for-each");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor");

var _filterInstanceProperty = require("@babel/runtime-corejs3/core-js-stable/instance/filter");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols");

var _Object$keys = require("@babel/runtime-corejs3/core-js-stable/object/keys");

require("core-js/modules/es.promise");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

var _exportNames = {
  MetadataApi: true,
  AsyncResultLocator: true,
  RetrieveResultLocator: true,
  DeployResultLocator: true
};
exports.default = exports.DeployResultLocator = exports.RetrieveResultLocator = exports.AsyncResultLocator = exports.MetadataApi = void 0;

var _setTimeout2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set-timeout"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/json/stringify"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/is-array"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/objectWithoutProperties"));

var _events = require("events");

var _stream = require("stream");

var _formData = _interopRequireDefault(require("form-data"));

var _jsforce = require("../jsforce");

var _soap = _interopRequireDefault(require("../soap"));

var _function = require("../util/function");

var _schema = require("./metadata/schema");

_forEachInstanceProperty(_context4 = _Object$keys(_schema)).call(_context4, function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _schema[key]) return;

  _Object$defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _schema[key];
    }
  });
});

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context2; _forEachInstanceProperty(_context2 = ownKeys(Object(source), true)).call(_context2, function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { var _context3; _forEachInstanceProperty(_context3 = ownKeys(Object(source))).call(_context3, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 *
 */
function deallocateTypeWithMetadata(metadata) {
  const _ref = metadata,
        {
    $
  } = _ref,
        md = (0, _objectWithoutProperties2.default)(_ref, ["$"]);
  return md;
}

function assignTypeWithMetadata(metadata, type) {
  const convert = md => _objectSpread({
    ['@xsi:type']: type
  }, md);

  return (0, _isArray.default)(metadata) ? (0, _map.default)(metadata).call(metadata, convert) : convert(metadata);
}
/**
 * Class for Salesforce Metadata API
 */


class MetadataApi {
  /**
   * Polling interval in milliseconds
   */

  /**
   * Polling timeout in milliseconds
   */

  /**
   *
   */
  constructor(conn) {
    (0, _defineProperty2.default)(this, "_conn", void 0);
    (0, _defineProperty2.default)(this, "pollInterval", 1000);
    (0, _defineProperty2.default)(this, "pollTimeout", 10000);
    this._conn = conn;
  }
  /**
   * Call Metadata API SOAP endpoint
   *
   * @private
   */


  async _invoke(method, message, schema) {
    const soapEndpoint = new _soap.default(this._conn, {
      xmlns: 'http://soap.sforce.com/2006/04/metadata',
      endpointUrl: `${this._conn.instanceUrl}/services/Soap/m/${this._conn.version}`
    });
    const res = await soapEndpoint.invoke(method, message, schema ? {
      result: schema
    } : undefined, _schema.ApiSchemas);
    return res.result;
  }
  /**
   * Add one or more new metadata components to the organization.
   */


  create(type, metadata) {
    const isArray = (0, _isArray.default)(metadata);
    metadata = assignTypeWithMetadata(metadata, type);
    const schema = isArray ? [_schema.ApiSchemas.SaveResult] : _schema.ApiSchemas.SaveResult;
    return this._invoke('createMetadata', {
      metadata
    }, schema);
  }
  /**
   * Read specified metadata components in the organization.
   */


  async read(type, fullNames) {
    var _context;

    const ReadResultSchema = type in _schema.ApiSchemas ? {
      type: _schema.ApiSchemas.ReadResult.type,
      props: {
        records: [type]
      }
    } : _schema.ApiSchemas.ReadResult;
    const res = await this._invoke('readMetadata', {
      type,
      fullNames
    }, ReadResultSchema);
    return (0, _isArray.default)(fullNames) ? (0, _map.default)(_context = res.records).call(_context, deallocateTypeWithMetadata) : deallocateTypeWithMetadata(res.records[0]);
  }
  /**
   * Update one or more metadata components in the organization.
   */


  update(type, metadata) {
    const isArray = (0, _isArray.default)(metadata);
    metadata = assignTypeWithMetadata(metadata, type);
    const schema = isArray ? [_schema.ApiSchemas.SaveResult] : _schema.ApiSchemas.SaveResult;
    return this._invoke('updateMetadata', {
      metadata
    }, schema);
  }
  /**
   * Upsert one or more components in your organization's data.
   */


  upsert(type, metadata) {
    const isArray = (0, _isArray.default)(metadata);
    metadata = assignTypeWithMetadata(metadata, type);
    const schema = isArray ? [_schema.ApiSchemas.UpsertResult] : _schema.ApiSchemas.UpsertResult;
    return this._invoke('upsertMetadata', {
      metadata
    }, schema);
  }
  /**
   * Deletes specified metadata components in the organization.
   */


  delete(type, fullNames) {
    const schema = (0, _isArray.default)(fullNames) ? [_schema.ApiSchemas.SaveResult] : _schema.ApiSchemas.SaveResult;
    return this._invoke('deleteMetadata', {
      type,
      fullNames
    }, schema);
  }
  /**
   * Rename fullname of a metadata component in the organization
   */


  rename(type, oldFullName, newFullName) {
    return this._invoke('renameMetadata', {
      type,
      oldFullName,
      newFullName
    }, _schema.ApiSchemas.SaveResult);
  }
  /**
   * Retrieves the metadata which describes your organization, including Apex classes and triggers,
   * custom objects, custom fields on standard objects, tab sets that define an app,
   * and many other components.
   */


  describe(asOfVersion) {
    if (!asOfVersion) {
      asOfVersion = this._conn.version;
    }

    return this._invoke('describeMetadata', {
      asOfVersion
    }, _schema.ApiSchemas.DescribeMetadataResult);
  }
  /**
   * Retrieves property information about metadata components in your organization
   */


  list(queries, asOfVersion) {
    if (!asOfVersion) {
      asOfVersion = this._conn.version;
    }

    return this._invoke('listMetadata', {
      queries,
      asOfVersion
    }, [_schema.ApiSchemas.FileProperties]);
  }
  /**
   * Checks the status of asynchronous metadata calls
   */


  checkStatus(asyncProcessId) {
    const res = this._invoke('checkStatus', {
      asyncProcessId
    }, _schema.ApiSchemas.AsyncResult);

    return new AsyncResultLocator(this, res);
  }
  /**
   * Retrieves XML file representations of components in an organization
   */


  retrieve(request) {
    const res = this._invoke('retrieve', {
      request
    }, _schema.ApiSchemas.RetrieveResult);

    return new RetrieveResultLocator(this, res);
  }
  /**
   * Checks the status of declarative metadata call retrieve() and returns the zip file contents
   */


  checkRetrieveStatus(asyncProcessId) {
    return this._invoke('checkRetrieveStatus', {
      asyncProcessId
    }, _schema.ApiSchemas.RetrieveResult);
  }
  /**
   * Deploy components into an organization using zipped file representations
   * using the REST Metadata API instead of SOAP
   */


  deployRest(zipInput, options = {}) {
    const form = new _formData.default();
    form.append('file', zipInput, {
      contentType: 'application/zip',
      filename: 'package.xml'
    }); // Add the deploy options

    form.append('entity_content', (0, _stringify.default)({
      deployOptions: options
    }), {
      contentType: 'application/json'
    });
    const request = {
      url: '/metadata/deployRequest',
      method: 'POST',
      headers: _objectSpread({}, form.getHeaders()),
      body: form.getBuffer()
    };

    const res = this._conn.request(request);

    return new DeployResultLocator(this, res);
  }
  /**
   * Deploy components into an organization using zipped file representations
   */


  deploy(zipInput, options = {}) {
    const res = (async () => {
      const zipContentB64 = await new _promise.default((resolve, reject) => {
        if ((0, _function.isObject)(zipInput) && 'pipe' in zipInput && typeof zipInput.pipe === 'function') {
          const bufs = [];
          zipInput.on('data', d => bufs.push(d));
          zipInput.on('error', reject);
          zipInput.on('end', () => {
            resolve((0, _concat.default)(Buffer).call(Buffer, bufs).toString('base64'));
          }); // zipInput.resume();
        } else if (zipInput instanceof Buffer) {
          resolve(zipInput.toString('base64'));
        } else if (zipInput instanceof String || typeof zipInput === 'string') {
          resolve(zipInput);
        } else {
          throw 'Unexpected zipInput type';
        }
      });
      return this._invoke('deploy', {
        ZipFile: zipContentB64,
        DeployOptions: options
      }, _schema.ApiSchemas.DeployResult);
    })();

    return new DeployResultLocator(this, res);
  }
  /**
   * Checks the status of declarative metadata call deploy()
   */


  checkDeployStatus(asyncProcessId, includeDetails = false) {
    return this._invoke('checkDeployStatus', {
      asyncProcessId,
      includeDetails
    }, _schema.ApiSchemas.DeployResult);
  }

}
/*--------------------------------------------*/

/**
 * The locator class for Metadata API asynchronous call result
 */


exports.MetadataApi = MetadataApi;

class AsyncResultLocator extends _events.EventEmitter {
  /**
   *
   */
  constructor(meta, promise) {
    super();
    (0, _defineProperty2.default)(this, "_meta", void 0);
    (0, _defineProperty2.default)(this, "_promise", void 0);
    (0, _defineProperty2.default)(this, "_id", void 0);
    this._meta = meta;
    this._promise = promise;
  }
  /**
   * Promise/A+ interface
   * http://promises-aplus.github.io/promises-spec/
   *
   * @method Metadata~AsyncResultLocator#then
   */


  then(onResolve, onReject) {
    return this._promise.then(onResolve, onReject);
  }
  /**
   * Check the status of async request
   */


  async check() {
    const result = await this._promise;
    this._id = result.id;
    return await this._meta.checkStatus(result.id);
  }
  /**
   * Polling until async call status becomes complete or error
   */


  poll(interval, timeout) {
    const startTime = new Date().getTime();

    const poll = async () => {
      try {
        const now = new Date().getTime();

        if (startTime + timeout < now) {
          let errMsg = 'Polling time out.';

          if (this._id) {
            errMsg += ' Process Id = ' + this._id;
          }

          this.emit('error', new Error(errMsg));
          return;
        }

        const result = await this.check();

        if (result.done) {
          this.emit('complete', result);
        } else {
          this.emit('progress', result);
          (0, _setTimeout2.default)(poll, interval);
        }
      } catch (err) {
        this.emit('error', err);
      }
    };

    (0, _setTimeout2.default)(poll, interval);
  }
  /**
   * Check and wait until the async requests become in completed status
   */


  complete() {
    return new _promise.default((resolve, reject) => {
      this.on('complete', resolve);
      this.on('error', reject);
      this.poll(this._meta.pollInterval, this._meta.pollTimeout);
    });
  }

}
/*--------------------------------------------*/

/**
 * The locator class to track retreive() Metadata API call result
 */


exports.AsyncResultLocator = AsyncResultLocator;

class RetrieveResultLocator extends AsyncResultLocator {
  /**
   * Check and wait until the async request becomes in completed status,
   * and retrieve the result data.
   */
  async complete() {
    const result = await super.complete();
    return this._meta.checkRetrieveStatus(result.id);
  }
  /**
   * Change the retrieved result to Node.js readable stream
   */


  stream() {
    const resultStream = new _stream.Readable();
    let reading = false;

    resultStream._read = async () => {
      if (reading) {
        return;
      }

      reading = true;

      try {
        const result = await this.complete();
        resultStream.push(Buffer.from(result.zipFile, 'base64'));
        resultStream.push(null);
      } catch (e) {
        resultStream.emit('error', e);
      }
    };

    return resultStream;
  }

}
/*--------------------------------------------*/

/**
 * The locator class to track deploy() Metadata API call result
 *
 * @protected
 * @class Metadata~DeployResultLocator
 * @extends Metadata~AsyncResultLocator
 * @param {Metadata} meta - Metadata API object
 * @param {Promise.<Metadata~AsyncResult>} result - Promise object for async result of deploy() call
 */


exports.RetrieveResultLocator = RetrieveResultLocator;

class DeployResultLocator extends AsyncResultLocator {
  /**
   * Check and wait until the async request becomes in completed status,
   * and retrieve the result data.
   */
  async complete(includeDetails) {
    const result = await super.complete();
    return this._meta.checkDeployStatus(result.id, includeDetails);
  }

}
/*--------------------------------------------*/

/*
 * Register hook in connection instantiation for dynamically adding this API module features
 */


exports.DeployResultLocator = DeployResultLocator;
(0, _jsforce.registerModule)('metadata', conn => new MetadataApi(conn));
var _default = MetadataApi;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvbWV0YWRhdGEudHMiXSwibmFtZXMiOlsiZGVhbGxvY2F0ZVR5cGVXaXRoTWV0YWRhdGEiLCJtZXRhZGF0YSIsIiQiLCJtZCIsImFzc2lnblR5cGVXaXRoTWV0YWRhdGEiLCJ0eXBlIiwiY29udmVydCIsIk1ldGFkYXRhQXBpIiwiY29uc3RydWN0b3IiLCJjb25uIiwiX2Nvbm4iLCJfaW52b2tlIiwibWV0aG9kIiwibWVzc2FnZSIsInNjaGVtYSIsInNvYXBFbmRwb2ludCIsIlNPQVAiLCJ4bWxucyIsImVuZHBvaW50VXJsIiwiaW5zdGFuY2VVcmwiLCJ2ZXJzaW9uIiwicmVzIiwiaW52b2tlIiwicmVzdWx0IiwidW5kZWZpbmVkIiwiQXBpU2NoZW1hcyIsImNyZWF0ZSIsImlzQXJyYXkiLCJTYXZlUmVzdWx0IiwicmVhZCIsImZ1bGxOYW1lcyIsIlJlYWRSZXN1bHRTY2hlbWEiLCJSZWFkUmVzdWx0IiwicHJvcHMiLCJyZWNvcmRzIiwidXBkYXRlIiwidXBzZXJ0IiwiVXBzZXJ0UmVzdWx0IiwiZGVsZXRlIiwicmVuYW1lIiwib2xkRnVsbE5hbWUiLCJuZXdGdWxsTmFtZSIsImRlc2NyaWJlIiwiYXNPZlZlcnNpb24iLCJEZXNjcmliZU1ldGFkYXRhUmVzdWx0IiwibGlzdCIsInF1ZXJpZXMiLCJGaWxlUHJvcGVydGllcyIsImNoZWNrU3RhdHVzIiwiYXN5bmNQcm9jZXNzSWQiLCJBc3luY1Jlc3VsdCIsIkFzeW5jUmVzdWx0TG9jYXRvciIsInJldHJpZXZlIiwicmVxdWVzdCIsIlJldHJpZXZlUmVzdWx0IiwiUmV0cmlldmVSZXN1bHRMb2NhdG9yIiwiY2hlY2tSZXRyaWV2ZVN0YXR1cyIsImRlcGxveVJlc3QiLCJ6aXBJbnB1dCIsIm9wdGlvbnMiLCJmb3JtIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJjb250ZW50VHlwZSIsImZpbGVuYW1lIiwiZGVwbG95T3B0aW9ucyIsInVybCIsImhlYWRlcnMiLCJnZXRIZWFkZXJzIiwiYm9keSIsImdldEJ1ZmZlciIsIkRlcGxveVJlc3VsdExvY2F0b3IiLCJkZXBsb3kiLCJ6aXBDb250ZW50QjY0IiwicmVzb2x2ZSIsInJlamVjdCIsInBpcGUiLCJidWZzIiwib24iLCJkIiwicHVzaCIsIkJ1ZmZlciIsInRvU3RyaW5nIiwiU3RyaW5nIiwiWmlwRmlsZSIsIkRlcGxveU9wdGlvbnMiLCJEZXBsb3lSZXN1bHQiLCJjaGVja0RlcGxveVN0YXR1cyIsImluY2x1ZGVEZXRhaWxzIiwiRXZlbnRFbWl0dGVyIiwibWV0YSIsInByb21pc2UiLCJfbWV0YSIsIl9wcm9taXNlIiwidGhlbiIsIm9uUmVzb2x2ZSIsIm9uUmVqZWN0IiwiY2hlY2siLCJfaWQiLCJpZCIsInBvbGwiLCJpbnRlcnZhbCIsInRpbWVvdXQiLCJzdGFydFRpbWUiLCJEYXRlIiwiZ2V0VGltZSIsIm5vdyIsImVyck1zZyIsImVtaXQiLCJFcnJvciIsImRvbmUiLCJlcnIiLCJjb21wbGV0ZSIsInBvbGxJbnRlcnZhbCIsInBvbGxUaW1lb3V0Iiwic3RyZWFtIiwicmVzdWx0U3RyZWFtIiwiUmVhZGFibGUiLCJyZWFkaW5nIiwiX3JlYWQiLCJmcm9tIiwiemlwRmlsZSIsImUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFFQTs7QUFnQkE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7OztBQXFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQSwwQkFBVCxDQUF3REMsUUFBeEQsRUFBd0U7QUFDdEUsZUFBcUJBLFFBQXJCO0FBQUEsUUFBTTtBQUFFQyxJQUFBQTtBQUFGLEdBQU47QUFBQSxRQUFjQyxFQUFkO0FBQ0EsU0FBT0EsRUFBUDtBQUNEOztBQUVELFNBQVNDLHNCQUFULENBQWdDSCxRQUFoQyxFQUFpRUksSUFBakUsRUFBK0U7QUFDN0UsUUFB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Q0Q7O0FBOUJEO0FBaUNGOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDTyxNQUFNN0MsbUJBQU4sU0FBb0RwQixrQkFBcEQsQ0FHTDtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0UsUUFBTTZELFFBQU4sQ0FBZXhCLGNBQWYsRUFBeUM7QUFDdkMsVUFBTWpFLE1BQU0sR0FBRyxNQUFNLE1BQU15RixRQUFOLEVBQXJCO0FBQ0EsV0FBTyxLQUFLcEIsS0FBTCxDQUFXTCxpQkFBWCxDQUE2QmhFLE1BQU0sQ0FBQzRFLEVBQXBDLEVBQXdDWCxjQUF4QyxDQUFQO0FBQ0Q7O0FBUkQ7QUFXRjs7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQSw2QkFBZSxVQUFmLEVBQTRCL0UsSUFBRCxJQUFVLElBQUlGLFdBQUosQ0FBZ0JFLElBQWhCLENBQXJDO2VBRWVGLFciLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIE1hbmFnZXMgU2FsZXNmb3JjZSBNZXRhZGF0YSBBUElcbiAqIEBhdXRob3IgU2hpbmljaGkgVG9taXRhIDxzaGluaWNoaS50b21pdGFAZ21haWwuY29tPlxuICovXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgUmVhZGFibGUgfSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IEZvcm1EYXRhIGZyb20gJ2Zvcm0tZGF0YSc7XG5pbXBvcnQgeyByZWdpc3Rlck1vZHVsZSB9IGZyb20gJy4uL2pzZm9yY2UnO1xuaW1wb3J0IENvbm5lY3Rpb24gZnJvbSAnLi4vY29ubmVjdGlvbic7XG5pbXBvcnQgU09BUCBmcm9tICcuLi9zb2FwJztcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnLi4vdXRpbC9mdW5jdGlvbic7XG5pbXBvcnQgeyBTY2hlbWEsIFNvYXBTY2hlbWFEZWYsIFNvYXBTY2hlbWEsIEh0dHBSZXF1ZXN0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgQXBpU2NoZW1hcyxcbiAgTWV0YWRhdGEsXG4gIFJlYWRSZXN1bHQsXG4gIFNhdmVSZXN1bHQsXG4gIFVwc2VydFJlc3VsdCxcbiAgTGlzdE1ldGFkYXRhUXVlcnksXG4gIEZpbGVQcm9wZXJ0aWVzLFxuICBEZXNjcmliZU1ldGFkYXRhUmVzdWx0LFxuICBSZXRyaWV2ZVJlcXVlc3QsXG4gIERlcGxveU9wdGlvbnMsXG4gIFJldHJpZXZlUmVzdWx0LFxuICBEZXBsb3lSZXN1bHQsXG4gIEFzeW5jUmVzdWx0LFxuICBBcGlTY2hlbWFUeXBlcyxcbn0gZnJvbSAnLi9tZXRhZGF0YS9zY2hlbWEnO1xuZXhwb3J0ICogZnJvbSAnLi9tZXRhZGF0YS9zY2hlbWEnO1xuXG4vKipcbiAqXG4gKi9cbnR5cGUgTWV0YWRhdGFUeXBlXzxcbiAgSyBleHRlbmRzIGtleW9mIEFwaVNjaGVtYVR5cGVzID0ga2V5b2YgQXBpU2NoZW1hVHlwZXNcbj4gPSBLIGV4dGVuZHMga2V5b2YgQXBpU2NoZW1hVHlwZXNcbiAgPyBBcGlTY2hlbWFUeXBlc1tLXSBleHRlbmRzIE1ldGFkYXRhXG4gICAgPyBLXG4gICAgOiBuZXZlclxuICA6IG5ldmVyO1xuXG5leHBvcnQgdHlwZSBNZXRhZGF0YVR5cGUgPSBNZXRhZGF0YVR5cGVfO1xuXG5leHBvcnQgdHlwZSBNZXRhZGF0YURlZmluaXRpb248XG4gIFQgZXh0ZW5kcyBzdHJpbmcsXG4gIE0gZXh0ZW5kcyBNZXRhZGF0YSA9IE1ldGFkYXRhXG4+ID0gTWV0YWRhdGEgZXh0ZW5kcyBNXG4gID8gVCBleHRlbmRzIGtleW9mIEFwaVNjaGVtYVR5cGVzICYgTWV0YWRhdGFUeXBlXG4gICAgPyBBcGlTY2hlbWFUeXBlc1tUXSBleHRlbmRzIE1ldGFkYXRhXG4gICAgICA/IEFwaVNjaGVtYVR5cGVzW1RdXG4gICAgICA6IE1ldGFkYXRhXG4gICAgOiBNZXRhZGF0YVxuICA6IE07XG5cbnR5cGUgRGVlcFBhcnRpYWw8VD4gPSBUIGV4dGVuZHMgYW55W11cbiAgPyBEZWVwUGFydGlhbDxUW251bWJlcl0+W11cbiAgOiBUIGV4dGVuZHMgb2JqZWN0XG4gID8geyBbSyBpbiBrZXlvZiBUXT86IERlZXBQYXJ0aWFsPFRbS10+IH1cbiAgOiBUO1xuXG5leHBvcnQgdHlwZSBJbnB1dE1ldGFkYXRhRGVmaW5pdGlvbjxcbiAgVCBleHRlbmRzIHN0cmluZyxcbiAgTSBleHRlbmRzIE1ldGFkYXRhID0gTWV0YWRhdGFcbj4gPSBEZWVwUGFydGlhbDxNZXRhZGF0YURlZmluaXRpb248VCwgTT4+O1xuXG4vKipcbiAqXG4gKi9cbmZ1bmN0aW9uIGRlYWxsb2NhdGVUeXBlV2l0aE1ldGFkYXRhPE0gZXh0ZW5kcyBNZXRhZGF0YT4obWV0YWRhdGE6IE0pOiBNIHtcbiAgY29uc3QgeyAkLCAuLi5tZCB9ID0gbWV0YWRhdGEgYXMgYW55O1xuICByZXR1cm4gbWQ7XG59XG5cbmZ1bmN0aW9uIGFzc2lnblR5cGVXaXRoTWV0YWRhdGEobWV0YWRhdGE6IE1ldGFkYXRhIHwgTWV0YWRhdGFbXSwgdHlwZTogc3RyaW5nKSB7XG4gIGNvbnN0IGNvbnZlcnQgPSAobWQ6IE1ldGFkYXRhKSA9PiAoeyBbJ0B4c2k6dHlwZSddOiB0eXBlLCAuLi5tZCB9KTtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobWV0YWRhdGEpID8gbWV0YWRhdGEubWFwKGNvbnZlcnQpIDogY29udmVydChtZXRhZGF0YSk7XG59XG5cbi8qKlxuICogQ2xhc3MgZm9yIFNhbGVzZm9yY2UgTWV0YWRhdGEgQVBJXG4gKi9cbmV4cG9ydCBjbGFzcyBNZXRhZGF0YUFwaTxTIGV4dGVuZHMgU2NoZW1hPiB7XG4gIF9jb25uOiBDb25uZWN0aW9uPFM+O1xuXG4gIC8qKlxuICAgKiBQb2xsaW5nIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuICAgKi9cbiAgcG9sbEludGVydmFsOiBudW1iZXIgPSAxMDAwO1xuXG4gIC8qKlxuICAgKiBQb2xsaW5nIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gICAqL1xuICBwb2xsVGltZW91dDogbnVtYmVyID0gMTAwMDA7XG5cbiAgLyoqXG4gICAqXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25uOiBDb25uZWN0aW9uPFM+KSB7XG4gICAgdGhpcy5fY29ubiA9IGNvbm47XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBNZXRhZGF0YSBBUEkgU09BUCBlbmRwb2ludFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgX2ludm9rZShcbiAgICBtZXRob2Q6IHN0cmluZyxcbiAgICBtZXNzYWdlOiBvYmplY3QsXG4gICAgc2NoZW1hPzogU29hcFNjaGVtYSB8IFNvYXBTY2hlbWFEZWYsXG4gICkge1xuICAgIGNvbnN0IHNvYXBFbmRwb2ludCA9IG5ldyBTT0FQKHRoaXMuX2Nvbm4sIHtcbiAgICAgIHhtbG5zOiAnaHR0cDovL3NvYXAuc2ZvcmNlLmNvbS8yMDA2LzA0L21ldGFkYXRhJyxcbiAgICAgIGVuZHBvaW50VXJsOiBgJHt0aGlzLl9jb25uLmluc3RhbmNlVXJsfS9zZXJ2aWNlcy9Tb2FwL20vJHt0aGlzLl9jb25uLnZlcnNpb259YCxcbiAgICB9KTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBzb2FwRW5kcG9pbnQuaW52b2tlKFxuICAgICAgbWV0aG9kLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNjaGVtYSA/ICh7IHJlc3VsdDogc2NoZW1hIH0gYXMgU29hcFNjaGVtYSkgOiB1bmRlZmluZWQsXG4gICAgICBBcGlTY2hlbWFzLFxuICAgICk7XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQWRkIG9uZSBvciBtb3JlIG5ldyBtZXRhZGF0YSBjb21wb25lbnRzIHRvIHRoZSBvcmdhbml6YXRpb24uXG4gICAqL1xuICBjcmVhdGU8XG4gICAgTSBleHRlbmRzIE1ldGFkYXRhID0gTWV0YWRhdGEsXG4gICAgVCBleHRlbmRzIE1ldGFkYXRhVHlwZSA9IE1ldGFkYXRhVHlwZSxcbiAgICBNRCBleHRlbmRzIElucHV0TWV0YWRhdGFEZWZpbml0aW9uPFQsIE0+ID0gSW5wdXRNZXRhZGF0YURlZmluaXRpb248VCwgTT5cbiAgPih0eXBlOiBULCBtZXRhZGF0YTogTURbXSk6IFByb21pc2U8U2F2ZVJlc3VsdFtdPjtcbiAgY3JlYXRlPFxuICAgIE0gZXh0ZW5kcyBNZXRhZGF0YSA9IE1ldGFkYXRhLFxuICAgIFQgZXh0ZW5kcyBNZXRhZGF0YVR5cGUgPSBNZXRhZGF0YVR5cGUsXG4gICAgTUQgZXh0ZW5kcyBJbnB1dE1ldGFkYXRhRGVmaW5pdGlvbjxULCBNPiA9IElucHV0TWV0YWRhdGFEZWZpbml0aW9uPFQsIE0+XG4gID4odHlwZTogVCwgbWV0YWRhdGE6IE1EKTogUHJvbWlzZTxTYXZlUmVzdWx0PjtcbiAgY3JlYXRlPFxuICAgIE0gZXh0ZW5kcyBNZXRhZGF0YSA9IE1ldGFkYXRhLFxuICAgIFQgZXh0ZW5kcyBNZXRhZGF0YVR5cGUgPSBNZXRhZGF0YVR5cGUsXG4gICAgTUQgZXh0ZW5kcyBJbnB1dE1ldGFkYXRhRGVmaW5pdGlvbjxULCBNPiA9IElucHV0TWV0YWRhdGFEZWZpbml0aW9uPFQsIE0+XG4gID4odHlwZTogVCwgbWV0YWRhdGE6IE1EIHwgTURbXSk6IFByb21pc2U8U2F2ZVJlc3VsdCB8IFNhdmVSZXN1bHRbXT47XG4gIGNyZWF0ZSh0eXBlOiBzdHJpbmcsIG1ldGFkYXRhOiBNZXRhZGF0YSB8IE1ldGFkYXRhW10pIHtcbiAgICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShtZXRhZGF0YSk7XG4gICAgbWV0YWRhdGEgPSBhc3NpZ25UeXBlV2l0aE1ldGFkYXRhKG1ldGFkYXRhLCB0eXBlKTtcbiAgICBjb25zdCBzY2hlbWEgPSBpc0FycmF5ID8gW0FwaVNjaGVtYXMuU2F2ZVJlc3VsdF0gOiBBcGlTY2hlbWFzLlNhdmVSZXN1bHQ7XG4gICAgcmV0dXJuIHRoaXMuX2ludm9rZSgnY3JlYXRlTWV0YWRhdGEnLCB7IG1ldGFkYXRhIH0sIHNjaGVtYSk7XG4gIH1cblxuICAvKipcbiAgICogUmVhZCBzcGVjaWZpZWQgbWV0YWRhdGEgY29tcG9uZW50cyBpbiB0aGUgb3JnYW5pemF0aW9uLlxuICAgKi9cbiAgcmVhZDxcbiAgICBNIGV4dGVuZHMgTWV0YWRhdGEgPSBNZXRhZGF0YSxcbiAgICBUIGV4dGVuZHMgTWV0YWRhdGFUeXBlID0gTWV0YWRhdGFUeXBlLFxuICAgIE1EIGV4dGVuZHMgTWV0YWRhdGFEZWZpbml0aW9uPFQsIE0+ID0gTWV0YWRhdGFEZWZpbml0aW9uPFQsIE0+XG4gID4odHlwZTogVCwgZnVsbE5hbWVzOiBzdHJpbmdbXSk6IFByb21pc2U8TURbXT47XG4gIHJlYWQ8XG4gICAgTSBleHRlbmRzIE1ldGFkYXRhID0gTWV0YWRhdGEsXG4gICAgVCBleHRlbmRzIE1ldGFkYXRhVHlwZSA9IE1ldGFkYXRhVHlwZSxcbiAgICBNRCBleHRlbmRzIE1ldGFkYXRhRGVmaW5pdGlvbjxULCBNPiA9IE1ldGFkYXRhRGVmaW5pdGlvbjxULCBNPlxuICA+KHR5cGU6IFQsIGZ1bGxOYW1lczogc3RyaW5nKTogUHJvbWlzZTxNRD47XG4gIHJlYWQ8XG4gICAgTSBleHRlbmRzIE1ldGFkYXRhID0gTWV0YWRhdGEsXG4gICAgVCBleHRlbmRzIE1ldGFkYXRhVHlwZSA9IE1ldGFkYXRhVHlwZSxcbiAgICBNRCBleHRlbmRzIE1ldGFkYXRhRGVmaW5pdGlvbjxULCBNPiA9IE1ldGFkYXRhRGVmaW5pdGlvbjxULCBNPlxuICA+KHR5cGU6IFQsIGZ1bGxOYW1lczogc3RyaW5nIHwgc3RyaW5nW10pOiBQcm9taXNlPE1EIHwgTURbXT47XG4gIGFzeW5jIHJlYWQodHlwZTogc3RyaW5nLCBmdWxsTmFtZXM6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gICAgY29uc3QgUmVhZFJlc3VsdFNjaGVtYSA9XG4gICAgICB0eXBlIGluIEFwaVNjaGVtYXNcbiAgICAgICAgPyAoe1xuICAgICAgICAgICAgdHlwZTogQXBpU2NoZW1hcy5SZWFkUmVzdWx0LnR5cGUsXG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICByZWNvcmRzOiBbdHlwZV0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0gYXMgY29uc3QpXG4gICAgICAgIDogQXBpU2NoZW1hcy5SZWFkUmVzdWx0O1xuICAgIGNvbnN0IHJlczogUmVhZFJlc3VsdCA9IGF3YWl0IHRoaXMuX2ludm9rZShcbiAgICAgICdyZWFkTWV0YWRhdGEnLFxuICAgICAgeyB0eXBlLCBmdWxsTmFtZXMgfSxcbiAgICAgIFJlYWRSZXN1bHRTY2hlbWEsXG4gICAgKTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShmdWxsTmFtZXMpXG4gICAgICA/IHJlcy5yZWNvcmRzLm1hcChkZWFsbG9jYXRlVHlwZVdpdGhNZXRhZGF0YSlcbiAgICAgIDogZGVhbGxvY2F0ZVR5cGVXaXRoTWV0YWRhdGEocmVzLnJlY29yZHNbMF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBvbmUgb3IgbW9yZSBtZXRhZGF0YSBjb21wb25lbnRzIGluIHRoZSBvcmdhbml6YXRpb24uXG4gICAqL1xuICB1cGRhdGU8XG4gICAgTSBleHRlbmRzIE1ldGFkYXRhID0gTWV0YWRhdGEsXG4gICAgVCBleHRlbmRzIHN0cmluZyA9IHN0cmluZyxcbiAgICBNRCBleHRlbmRzIElucHV0TWV0YWRhdGFEZWZpbml0aW9uPFQsIE0+ID0gSW5wdXRNZXRhZGF0YURlZmluaXRpb248VCwgTT5cbiAgPih0eXBlOiBULCBtZXRhZGF0YTogUGFydGlhbDxNRD5bXSk6IFByb21pc2U8U2F2ZVJlc3VsdFtdPjtcbiAgdXBkYXRlPFxuICAgIE0gZXh0ZW5kcyBNZXRhZGF0YSA9IE1ldGFkYXRhLFxuICAgIFQgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsXG4gICAgTUQgZXh0ZW5kcyBJbnB1dE1ldGFkYXRhRGVmaW5pdGlvbjxULCBNPiA9IElucHV0TWV0YWRhdGFEZWZpbml0aW9uPFQsIE0+XG4gID4odHlwZTogVCwgbWV0YWRhdGE6IFBhcnRpYWw8TUQ+KTogUHJvbWlzZTxTYXZlUmVzdWx0PjtcbiAgdXBkYXRlPFxuICAgIE0gZXh0ZW5kcyBNZXRhZGF0YSA9IE1ldGFkYXRhLFxuICAgIFQgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsXG4gICAgTUQgZXh0ZW5kcyBJbnB1dE1ldGFkYXRhRGVmaW5pdGlvbjxULCBNPiA9IElucHV0TWV0YWRhdGFEZWZpbml0aW9uPFQsIE0+XG4gID4oXG4gICAgdHlwZTogVCxcbiAgICBtZXRhZGF0YTogUGFydGlhbDxNRD4gfCBQYXJ0aWFsPE1EPltdLFxuICApOiBQcm9taXNlPFNhdmVSZXN1bHQgfCBTYXZlUmVzdWx0W10+O1xuICB1cGRhdGUodHlwZTogc3RyaW5nLCBtZXRhZGF0YTogTWV0YWRhdGEgfCBNZXRhZGF0YVtdKSB7XG4gICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkobWV0YWRhdGEpO1xuICAgIG1ldGFkYXRhID0gYXNzaWduVHlwZVdpdGhNZXRhZGF0YShtZXRhZGF0YSwgdHlwZSk7XG4gICAgY29uc3Qgc2NoZW1hID0gaXNBcnJheSA/IFtBcGlTY2hlbWFzLlNhdmVSZXN1bHRdIDogQXBpU2NoZW1hcy5TYXZlUmVzdWx0O1xuICAgIHJldHVybiB0aGlzLl9pbnZva2UoJ3VwZGF0ZU1ldGFkYXRhJywgeyBtZXRhZGF0YSB9LCBzY2hlbWEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwc2VydCBvbmUgb3IgbW9yZSBjb21wb25lbnRzIGluIHlvdXIgb3JnYW5pemF0aW9uJ3MgZGF0YS5cbiAgICovXG4gIHVwc2VydDxcbiAgICBNIGV4dGVuZHMgTWV0YWRhdGEgPSBNZXRhZGF0YSxcbiAgICBUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nLFxuICAgIE1EIGV4dGVuZHMgSW5wdXRNZXRhZGF0YURlZmluaXRpb248VCwgTT4gPSBJbnB1dE1ldGFkYXRhRGVmaW5pdGlvbjxULCBNPlxuICA+KHR5cGU6IFQsIG1ldGFkYXRhOiBNRFtdKTogUHJvbWlzZTxVcHNlcnRSZXN1bHRbXT47XG4gIHVwc2VydDxcbiAgICBNIGV4dGVuZHMgTWV0YWRhdGEgPSBNZXRhZGF0YSxcbiAgICBUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nLFxuICAgIE1EIGV4dGVuZHMgSW5wdXRNZXRhZGF0YURlZmluaXRpb248VCwgTT4gPSBJbnB1dE1ldGFkYXRhRGVmaW5pdGlvbjxULCBNPlxuICA+KHR5cGU6IFQsIG1ldGFkYXRhOiBNRCk6IFByb21pc2U8VXBzZXJ0UmVzdWx0PjtcbiAgdXBzZXJ0PFxuICAgIE0gZXh0ZW5kcyBNZXRhZGF0YSA9IE1ldGFkYXRhLFxuICAgIFQgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsXG4gICAgTUQgZXh0ZW5kcyBJbnB1dE1ldGFkYXRhRGVmaW5pdGlvbjxULCBNPiA9IElucHV0TWV0YWRhdGFEZWZpbml0aW9uPFQsIE0+XG4gID4odHlwZTogVCwgbWV0YWRhdGE6IE1EIHwgTURbXSk6IFByb21pc2U8VXBzZXJ0UmVzdWx0IHwgVXBzZXJ0UmVzdWx0W10+O1xuICB1cHNlcnQodHlwZTogc3RyaW5nLCBtZXRhZGF0YTogTWV0YWRhdGEgfCBNZXRhZGF0YVtdKSB7XG4gICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkobWV0YWRhdGEpO1xuICAgIG1ldGFkYXRhID0gYXNzaWduVHlwZVdpdGhNZXRhZGF0YShtZXRhZGF0YSwgdHlwZSk7XG4gICAgY29uc3Qgc2NoZW1hID0gaXNBcnJheVxuICAgICAgPyBbQXBpU2NoZW1hcy5VcHNlcnRSZXN1bHRdXG4gICAgICA6IEFwaVNjaGVtYXMuVXBzZXJ0UmVzdWx0O1xuICAgIHJldHVybiB0aGlzLl9pbnZva2UoJ3Vwc2VydE1ldGFkYXRhJywgeyBtZXRhZGF0YSB9LCBzY2hlbWEpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgc3BlY2lmaWVkIG1ldGFkYXRhIGNvbXBvbmVudHMgaW4gdGhlIG9yZ2FuaXphdGlvbi5cbiAgICovXG4gIGRlbGV0ZSh0eXBlOiBzdHJpbmcsIGZ1bGxOYW1lczogc3RyaW5nW10pOiBQcm9taXNlPFNhdmVSZXN1bHRbXT47XG4gIGRlbGV0ZSh0eXBlOiBzdHJpbmcsIGZ1bGxOYW1lczogc3RyaW5nKTogUHJvbWlzZTxTYXZlUmVzdWx0PjtcbiAgZGVsZXRlKFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBmdWxsTmFtZXM6IHN0cmluZyB8IHN0cmluZ1tdLFxuICApOiBQcm9taXNlPFNhdmVSZXN1bHQgfCBTYXZlUmVzdWx0W10+O1xuICBkZWxldGUodHlwZTogc3RyaW5nLCBmdWxsTmFtZXM6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gICAgY29uc3Qgc2NoZW1hID0gQXJyYXkuaXNBcnJheShmdWxsTmFtZXMpXG4gICAgICA/IFtBcGlTY2hlbWFzLlNhdmVSZXN1bHRdXG4gICAgICA6IEFwaVNjaGVtYXMuU2F2ZVJlc3VsdDtcbiAgICByZXR1cm4gdGhpcy5faW52b2tlKCdkZWxldGVNZXRhZGF0YScsIHsgdHlwZSwgZnVsbE5hbWVzIH0sIHNjaGVtYSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuYW1lIGZ1bGxuYW1lIG9mIGEgbWV0YWRhdGEgY29tcG9uZW50IGluIHRoZSBvcmdhbml6YXRpb25cbiAgICovXG4gIHJlbmFtZShcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgb2xkRnVsbE5hbWU6IHN0cmluZyxcbiAgICBuZXdGdWxsTmFtZTogc3RyaW5nLFxuICApOiBQcm9taXNlPFNhdmVSZXN1bHQ+IHtcbiAgICByZXR1cm4gdGhpcy5faW52b2tlKFxuICAgICAgJ3JlbmFtZU1ldGFkYXRhJyxcbiAgICAgIHsgdHlwZSwgb2xkRnVsbE5hbWUsIG5ld0Z1bGxOYW1lIH0sXG4gICAgICBBcGlTY2hlbWFzLlNhdmVSZXN1bHQsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIG1ldGFkYXRhIHdoaWNoIGRlc2NyaWJlcyB5b3VyIG9yZ2FuaXphdGlvbiwgaW5jbHVkaW5nIEFwZXggY2xhc3NlcyBhbmQgdHJpZ2dlcnMsXG4gICAqIGN1c3RvbSBvYmplY3RzLCBjdXN0b20gZmllbGRzIG9uIHN0YW5kYXJkIG9iamVjdHMsIHRhYiBzZXRzIHRoYXQgZGVmaW5lIGFuIGFwcCxcbiAgICogYW5kIG1hbnkgb3RoZXIgY29tcG9uZW50cy5cbiAgICovXG4gIGRlc2NyaWJlKGFzT2ZWZXJzaW9uPzogc3RyaW5nKTogUHJvbWlzZTxEZXNjcmliZU1ldGFkYXRhUmVzdWx0PiB7XG4gICAgaWYgKCFhc09mVmVyc2lvbikge1xuICAgICAgYXNPZlZlcnNpb24gPSB0aGlzLl9jb25uLnZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pbnZva2UoXG4gICAgICAnZGVzY3JpYmVNZXRhZGF0YScsXG4gICAgICB7IGFzT2ZWZXJzaW9uIH0sXG4gICAgICBBcGlTY2hlbWFzLkRlc2NyaWJlTWV0YWRhdGFSZXN1bHQsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgcHJvcGVydHkgaW5mb3JtYXRpb24gYWJvdXQgbWV0YWRhdGEgY29tcG9uZW50cyBpbiB5b3VyIG9yZ2FuaXphdGlvblxuICAgKi9cbiAgbGlzdChcbiAgICBxdWVyaWVzOiBMaXN0TWV0YWRhdGFRdWVyeSB8IExpc3RNZXRhZGF0YVF1ZXJ5W10sXG4gICAgYXNPZlZlcnNpb24/OiBzdHJpbmcsXG4gICk6IFByb21pc2U8RmlsZVByb3BlcnRpZXNbXT4ge1xuICAgIGlmICghYXNPZlZlcnNpb24pIHtcbiAgICAgIGFzT2ZWZXJzaW9uID0gdGhpcy5fY29ubi52ZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faW52b2tlKCdsaXN0TWV0YWRhdGEnLCB7IHF1ZXJpZXMsIGFzT2ZWZXJzaW9uIH0sIFtcbiAgICAgIEFwaVNjaGVtYXMuRmlsZVByb3BlcnRpZXMsXG4gICAgXSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHRoZSBzdGF0dXMgb2YgYXN5bmNocm9ub3VzIG1ldGFkYXRhIGNhbGxzXG4gICAqL1xuICBjaGVja1N0YXR1cyhhc3luY1Byb2Nlc3NJZDogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVzID0gdGhpcy5faW52b2tlKFxuICAgICAgJ2NoZWNrU3RhdHVzJyxcbiAgICAgIHsgYXN5bmNQcm9jZXNzSWQgfSxcbiAgICAgIEFwaVNjaGVtYXMuQXN5bmNSZXN1bHQsXG4gICAgKTtcbiAgICByZXR1cm4gbmV3IEFzeW5jUmVzdWx0TG9jYXRvcih0aGlzLCByZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBYTUwgZmlsZSByZXByZXNlbnRhdGlvbnMgb2YgY29tcG9uZW50cyBpbiBhbiBvcmdhbml6YXRpb25cbiAgICovXG4gIHJldHJpZXZlKHJlcXVlc3Q6IFBhcnRpYWw8UmV0cmlldmVSZXF1ZXN0Pikge1xuICAgIGNvbnN0IHJlcyA9IHRoaXMuX2ludm9rZShcbiAgICAgICdyZXRyaWV2ZScsXG4gICAgICB7IHJlcXVlc3QgfSxcbiAgICAgIEFwaVNjaGVtYXMuUmV0cmlldmVSZXN1bHQsXG4gICAgKTtcbiAgICByZXR1cm4gbmV3IFJldHJpZXZlUmVzdWx0TG9jYXRvcih0aGlzLCByZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB0aGUgc3RhdHVzIG9mIGRlY2xhcmF0aXZlIG1ldGFkYXRhIGNhbGwgcmV0cmlldmUoKSBhbmQgcmV0dXJucyB0aGUgemlwIGZpbGUgY29udGVudHNcbiAgICovXG4gIGNoZWNrUmV0cmlldmVTdGF0dXMoYXN5bmNQcm9jZXNzSWQ6IHN0cmluZyk6IFByb21pc2U8UmV0cmlldmVSZXN1bHQ+IHtcbiAgICByZXR1cm4gdGhpcy5faW52b2tlKFxuICAgICAgJ2NoZWNrUmV0cmlldmVTdGF0dXMnLFxuICAgICAgeyBhc3luY1Byb2Nlc3NJZCB9LFxuICAgICAgQXBpU2NoZW1hcy5SZXRyaWV2ZVJlc3VsdCxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcGxveSBjb21wb25lbnRzIGludG8gYW4gb3JnYW5pemF0aW9uIHVzaW5nIHppcHBlZCBmaWxlIHJlcHJlc2VudGF0aW9uc1xuICAgKiB1c2luZyB0aGUgUkVTVCBNZXRhZGF0YSBBUEkgaW5zdGVhZCBvZiBTT0FQXG4gICAqL1xuICBkZXBsb3lSZXN0KFxuICAgIHppcElucHV0OiBCdWZmZXIsXG4gICAgb3B0aW9uczogUGFydGlhbDxEZXBsb3lPcHRpb25zPiA9IHt9LFxuICApOiBEZXBsb3lSZXN1bHRMb2NhdG9yPFM+IHtcbiAgICBjb25zdCBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgZm9ybS5hcHBlbmQoJ2ZpbGUnLCB6aXBJbnB1dCwge1xuICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi96aXAnLFxuICAgICAgZmlsZW5hbWU6ICdwYWNrYWdlLnhtbCcsXG4gICAgfSk7XG5cbiAgICAvLyBBZGQgdGhlIGRlcGxveSBvcHRpb25zXG4gICAgZm9ybS5hcHBlbmQoJ2VudGl0eV9jb250ZW50JywgSlNPTi5zdHJpbmdpZnkoeyBkZXBsb3lPcHRpb25zOiBvcHRpb25zIH0pLCB7XG4gICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVxdWVzdDogSHR0cFJlcXVlc3QgPSB7XG4gICAgICB1cmw6ICcvbWV0YWRhdGEvZGVwbG95UmVxdWVzdCcsXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHsgLi4uZm9ybS5nZXRIZWFkZXJzKCkgfSxcbiAgICAgIGJvZHk6IGZvcm0uZ2V0QnVmZmVyKCksXG4gICAgfTtcbiAgICBjb25zdCByZXMgPSB0aGlzLl9jb25uLnJlcXVlc3Q8QXN5bmNSZXN1bHQ+KHJlcXVlc3QpO1xuXG4gICAgcmV0dXJuIG5ldyBEZXBsb3lSZXN1bHRMb2NhdG9yKHRoaXMsIHJlcyk7XG4gIH1cblxuICAvKipcbiAgICogRGVwbG95IGNvbXBvbmVudHMgaW50byBhbiBvcmdhbml6YXRpb24gdXNpbmcgemlwcGVkIGZpbGUgcmVwcmVzZW50YXRpb25zXG4gICAqL1xuICBkZXBsb3koXG4gICAgemlwSW5wdXQ6IFJlYWRhYmxlIHwgQnVmZmVyIHwgc3RyaW5nLFxuICAgIG9wdGlvbnM6IFBhcnRpYWw8RGVwbG95T3B0aW9ucz4gPSB7fSxcbiAgKTogRGVwbG95UmVzdWx0TG9jYXRvcjxTPiB7XG4gICAgY29uc3QgcmVzID0gKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHppcENvbnRlbnRCNjQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBpc09iamVjdCh6aXBJbnB1dCkgJiZcbiAgICAgICAgICAncGlwZScgaW4gemlwSW5wdXQgJiZcbiAgICAgICAgICB0eXBlb2YgemlwSW5wdXQucGlwZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBidWZzOiBCdWZmZXJbXSA9IFtdO1xuICAgICAgICAgIHppcElucHV0Lm9uKCdkYXRhJywgKGQpID0+IGJ1ZnMucHVzaChkKSk7XG4gICAgICAgICAgemlwSW5wdXQub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgICB6aXBJbnB1dC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShCdWZmZXIuY29uY2F0KGJ1ZnMpLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gemlwSW5wdXQucmVzdW1lKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoemlwSW5wdXQgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgICByZXNvbHZlKHppcElucHV0LnRvU3RyaW5nKCdiYXNlNjQnKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoemlwSW5wdXQgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIHppcElucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJlc29sdmUoemlwSW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93ICdVbmV4cGVjdGVkIHppcElucHV0IHR5cGUnO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShcbiAgICAgICAgJ2RlcGxveScsXG4gICAgICAgIHtcbiAgICAgICAgICBaaXBGaWxlOiB6aXBDb250ZW50QjY0LFxuICAgICAgICAgIERlcGxveU9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIH0sXG4gICAgICAgIEFwaVNjaGVtYXMuRGVwbG95UmVzdWx0LFxuICAgICAgKTtcbiAgICB9KSgpO1xuXG4gICAgcmV0dXJuIG5ldyBEZXBsb3lSZXN1bHRMb2NhdG9yKHRoaXMsIHJlcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHRoZSBzdGF0dXMgb2YgZGVjbGFyYXRpdmUgbWV0YWRhdGEgY2FsbCBkZXBsb3koKVxuICAgKi9cbiAgY2hlY2tEZXBsb3lTdGF0dXMoXG4gICAgYXN5bmNQcm9jZXNzSWQ6IHN0cmluZyxcbiAgICBpbmNsdWRlRGV0YWlsczogYm9vbGVhbiA9IGZhbHNlLFxuICApOiBQcm9taXNlPERlcGxveVJlc3VsdD4ge1xuICAgIHJldHVybiB0aGlzLl9pbnZva2UoXG4gICAgICAnY2hlY2tEZXBsb3lTdGF0dXMnLFxuICAgICAge1xuICAgICAgICBhc3luY1Byb2Nlc3NJZCxcbiAgICAgICAgaW5jbHVkZURldGFpbHMsXG4gICAgICB9LFxuICAgICAgQXBpU2NoZW1hcy5EZXBsb3lSZXN1bHQsXG4gICAgKTtcbiAgfVxufVxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBUaGUgbG9jYXRvciBjbGFzcyBmb3IgTWV0YWRhdGEgQVBJIGFzeW5jaHJvbm91cyBjYWxsIHJlc3VsdFxuICovXG5leHBvcnQgY2xhc3MgQXN5bmNSZXN1bHRMb2NhdG9yPFxuICBTIGV4dGVuZHMgU2NoZW1hLFxuICBSIGV4dGVuZHMge30gPSBBc3luY1Jlc3VsdFxuPiBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIF9tZXRhOiBNZXRhZGF0YUFwaTxTPjtcbiAgX3Byb21pc2U6IFByb21pc2U8QXN5bmNSZXN1bHQ+O1xuICBfaWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICpcbiAgICovXG4gIGNvbnN0cnVjdG9yKG1ldGE6IE1ldGFkYXRhQXBpPFM+LCBwcm9taXNlOiBQcm9taXNlPEFzeW5jUmVzdWx0Pikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fbWV0YSA9IG1ldGE7XG4gICAgdGhpcy5fcHJvbWlzZSA9IHByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogUHJvbWlzZS9BKyBpbnRlcmZhY2VcbiAgICogaHR0cDovL3Byb21pc2VzLWFwbHVzLmdpdGh1Yi5pby9wcm9taXNlcy1zcGVjL1xuICAgKlxuICAgKiBAbWV0aG9kIE1ldGFkYXRhfkFzeW5jUmVzdWx0TG9jYXRvciN0aGVuXG4gICAqL1xuICB0aGVuPFUsIFY+KFxuICAgIG9uUmVzb2x2ZT86ICgocmVzdWx0OiBBc3luY1Jlc3VsdCkgPT4gVSB8IFByb21pc2U8VT4pIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBvblJlamVjdD86ICgoZXJyOiBFcnJvcikgPT4gViB8IFByb21pc2U8Vj4pIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgKTogUHJvbWlzZTxVIHwgVj4ge1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlLnRoZW4ob25SZXNvbHZlLCBvblJlamVjdCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdGhlIHN0YXR1cyBvZiBhc3luYyByZXF1ZXN0XG4gICAqL1xuICBhc3luYyBjaGVjaygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9wcm9taXNlO1xuICAgIHRoaXMuX2lkID0gcmVzdWx0LmlkO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9tZXRhLmNoZWNrU3RhdHVzKHJlc3VsdC5pZCk7XG4gIH1cblxuICAvKipcbiAgICogUG9sbGluZyB1bnRpbCBhc3luYyBjYWxsIHN0YXR1cyBiZWNvbWVzIGNvbXBsZXRlIG9yIGVycm9yXG4gICAqL1xuICBwb2xsKGludGVydmFsOiBudW1iZXIsIHRpbWVvdXQ6IG51bWJlcikge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGNvbnN0IHBvbGwgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgaWYgKHN0YXJ0VGltZSArIHRpbWVvdXQgPCBub3cpIHtcbiAgICAgICAgICBsZXQgZXJyTXNnID0gJ1BvbGxpbmcgdGltZSBvdXQuJztcbiAgICAgICAgICBpZiAodGhpcy5faWQpIHtcbiAgICAgICAgICAgIGVyck1zZyArPSAnIFByb2Nlc3MgSWQgPSAnICsgdGhpcy5faWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoZXJyTXNnKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2hlY2soKTtcbiAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdjb21wbGV0ZScsIHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHJlc3VsdCk7XG4gICAgICAgICAgc2V0VGltZW91dChwb2xsLCBpbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHNldFRpbWVvdXQocG9sbCwgaW50ZXJ2YWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGFuZCB3YWl0IHVudGlsIHRoZSBhc3luYyByZXF1ZXN0cyBiZWNvbWUgaW4gY29tcGxldGVkIHN0YXR1c1xuICAgKi9cbiAgY29tcGxldGUoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFI+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMub24oJ2NvbXBsZXRlJywgcmVzb2x2ZSk7XG4gICAgICB0aGlzLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICB0aGlzLnBvbGwodGhpcy5fbWV0YS5wb2xsSW50ZXJ2YWwsIHRoaXMuX21ldGEucG9sbFRpbWVvdXQpO1xuICAgIH0pO1xuICB9XG59XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLyoqXG4gKiBUaGUgbG9jYXRvciBjbGFzcyB0byB0cmFjayByZXRyZWl2ZSgpIE1ldGFkYXRhIEFQSSBjYWxsIHJlc3VsdFxuICovXG5leHBvcnQgY2xhc3MgUmV0cmlldmVSZXN1bHRMb2NhdG9yPFMgZXh0ZW5kcyBTY2hlbWE+IGV4dGVuZHMgQXN5bmNSZXN1bHRMb2NhdG9yPFxuICBTLFxuICBSZXRyaWV2ZVJlc3VsdFxuPiB7XG4gIC8qKlxuICAgKiBDaGVjayBhbmQgd2FpdCB1bnRpbCB0aGUgYXN5bmMgcmVxdWVzdCBiZWNvbWVzIGluIGNvbXBsZXRlZCBzdGF0dXMsXG4gICAqIGFuZCByZXRyaWV2ZSB0aGUgcmVzdWx0IGRhdGEuXG4gICAqL1xuICBhc3luYyBjb21wbGV0ZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdXBlci5jb21wbGV0ZSgpO1xuICAgIHJldHVybiB0aGlzLl9tZXRhLmNoZWNrUmV0cmlldmVTdGF0dXMocmVzdWx0LmlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIHJldHJpZXZlZCByZXN1bHQgdG8gTm9kZS5qcyByZWFkYWJsZSBzdHJlYW1cbiAgICovXG4gIHN0cmVhbSgpIHtcbiAgICBjb25zdCByZXN1bHRTdHJlYW0gPSBuZXcgUmVhZGFibGUoKTtcbiAgICBsZXQgcmVhZGluZyA9IGZhbHNlO1xuICAgIHJlc3VsdFN0cmVhbS5fcmVhZCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChyZWFkaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlYWRpbmcgPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jb21wbGV0ZSgpO1xuICAgICAgICByZXN1bHRTdHJlYW0ucHVzaChCdWZmZXIuZnJvbShyZXN1bHQuemlwRmlsZSwgJ2Jhc2U2NCcpKTtcbiAgICAgICAgcmVzdWx0U3RyZWFtLnB1c2gobnVsbCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlc3VsdFN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdFN0cmVhbTtcbiAgfVxufVxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qKlxuICogVGhlIGxvY2F0b3IgY2xhc3MgdG8gdHJhY2sgZGVwbG95KCkgTWV0YWRhdGEgQVBJIGNhbGwgcmVzdWx0XG4gKlxuICogQHByb3RlY3RlZFxuICogQGNsYXNzIE1ldGFkYXRhfkRlcGxveVJlc3VsdExvY2F0b3JcbiAqIEBleHRlbmRzIE1ldGFkYXRhfkFzeW5jUmVzdWx0TG9jYXRvclxuICogQHBhcmFtIHtNZXRhZGF0YX0gbWV0YSAtIE1ldGFkYXRhIEFQSSBvYmplY3RcbiAqIEBwYXJhbSB7UHJvbWlzZS48TWV0YWRhdGF+QXN5bmNSZXN1bHQ+fSByZXN1bHQgLSBQcm9taXNlIG9iamVjdCBmb3IgYXN5bmMgcmVzdWx0IG9mIGRlcGxveSgpIGNhbGxcbiAqL1xuZXhwb3J0IGNsYXNzIERlcGxveVJlc3VsdExvY2F0b3I8UyBleHRlbmRzIFNjaGVtYT4gZXh0ZW5kcyBBc3luY1Jlc3VsdExvY2F0b3I8XG4gIFMsXG4gIERlcGxveVJlc3VsdFxuPiB7XG4gIC8qKlxuICAgKiBDaGVjayBhbmQgd2FpdCB1bnRpbCB0aGUgYXN5bmMgcmVxdWVzdCBiZWNvbWVzIGluIGNvbXBsZXRlZCBzdGF0dXMsXG4gICAqIGFuZCByZXRyaWV2ZSB0aGUgcmVzdWx0IGRhdGEuXG4gICAqL1xuICBhc3luYyBjb21wbGV0ZShpbmNsdWRlRGV0YWlscz86IGJvb2xlYW4pIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdXBlci5jb21wbGV0ZSgpO1xuICAgIHJldHVybiB0aGlzLl9tZXRhLmNoZWNrRGVwbG95U3RhdHVzKHJlc3VsdC5pZCwgaW5jbHVkZURldGFpbHMpO1xuICB9XG59XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLypcbiAqIFJlZ2lzdGVyIGhvb2sgaW4gY29ubmVjdGlvbiBpbnN0YW50aWF0aW9uIGZvciBkeW5hbWljYWxseSBhZGRpbmcgdGhpcyBBUEkgbW9kdWxlIGZlYXR1cmVzXG4gKi9cbnJlZ2lzdGVyTW9kdWxlKCdtZXRhZGF0YScsIChjb25uKSA9PiBuZXcgTWV0YWRhdGFBcGkoY29ubikpO1xuXG5leHBvcnQgZGVmYXVsdCBNZXRhZGF0YUFwaTtcbiJdfQ==