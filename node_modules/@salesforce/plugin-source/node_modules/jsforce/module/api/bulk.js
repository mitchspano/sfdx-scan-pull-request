import _Object$defineProperty from "@babel/runtime-corejs3/core-js-stable/object/define-property";
import _Object$defineProperties from "@babel/runtime-corejs3/core-js-stable/object/define-properties";
import _Object$getOwnPropertyDescriptors from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _Object$getOwnPropertyDescriptor from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _Object$getOwnPropertySymbols from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols";
import "core-js/modules/es.array.iterator";
import "core-js/modules/es.promise";
import "core-js/modules/es.string.replace";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _setTimeout from "@babel/runtime-corejs3/core-js-stable/set-timeout";
import _parseInt from "@babel/runtime-corejs3/core-js-stable/parse-int";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _objectWithoutProperties from "@babel/runtime-corejs3/helpers/objectWithoutProperties";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _Promise from "@babel/runtime-corejs3/core-js-stable/promise";
import _trimInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/trim";
import _defineProperty from "@babel/runtime-corejs3/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context4; _forEachInstanceProperty(_context4 = ownKeys(Object(source), true)).call(_context4, function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { var _context5; _forEachInstanceProperty(_context5 = ownKeys(Object(source))).call(_context5, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * @file Manages Salesforce Bulk API related operations
 * @author Shinichi Tomita <shinichi.tomita@gmail.com>
 */
import { EventEmitter } from 'events';
import { Writable } from 'stream';
import joinStreams from 'multistream';
import { Serializable, Parsable } from '../record-stream';
import HttpApi from '../http-api';
import { registerModule } from '../jsforce';
import { concatStreamsAsDuplex } from '../util/stream';
import { isFunction, isObject } from '../util/function';
/*--------------------------------------------*/

/**
 * Class for Bulk API Job
 */
export class Job extends EventEmitter {
  /**
   *
   */
  constructor(bulk, type, operation, options, jobId) {
    super();

    _defineProperty(this, "type", void 0);

    _defineProperty(this, "operation", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "id", void 0);

    _defineProperty(this, "state", void 0);

    _defineProperty(this, "_bulk", void 0);

    _defineProperty(this, "_batches", void 0);

    _defineProperty(this, "_jobInfo", void 0);

    _defineProperty(this, "_error", void 0);

    this._bulk = bulk;
    this.type = type;
    this.operation = operation;
    this.options = options || {};
    this.id = jobId !== null && jobId !== void 0 ? jobId : null;
    this.state = this.id ? 'Open' : 'Unknown';
    this._batches = {}; // default error handler to keep the latest error

    this.on('error', error => this._error = error);
  }
  /**
   * Return latest jobInfo from cache
   */


  info() {
    // if cache is not available, check the latest
    if (!this._jobInfo) {
      this._jobInfo = this.check();
    }

    return this._jobInfo;
  }
  /**
   * Open new job and get jobinfo
   */


  open() {
    const bulk = this._bulk;
    const options = this.options; // if sobject type / operation is not provided

    if (!this.type || !this.operation) {
      throw new Error('type / operation is required to open a new job');
    } // if not requested opening job


    if (!this._jobInfo) {
      var _context;

      let operation = this.operation.toLowerCase();

      if (operation === 'harddelete') {
        operation = 'hardDelete';
      }

      if (operation === 'queryall') {
        operation = 'queryAll';
      }

      const body = _trimInstanceProperty(_context = `
<?xml version="1.0" encoding="UTF-8"?>
<jobInfo  xmlns="http://www.force.com/2009/06/asyncapi/dataload">
  <operation>${operation}</operation>
  <object>${this.type}</object>
  ${options.extIdField ? `<externalIdFieldName>${options.extIdField}</externalIdFieldName>` : ''}
  ${options.concurrencyMode ? `<concurrencyMode>${options.concurrencyMode}</concurrencyMode>` : ''}
  ${options.assignmentRuleId ? `<assignmentRuleId>${options.assignmentRuleId}</assignmentRuleId>` : ''}
  <contentType>CSV</contentType>
</jobInfo>
      `).call(_context);

      this._jobInfo = (async () => {
        try {
          const res = await bulk._request({
            method: 'POST',
            path: '/job',
            body,
            headers: {
              'Content-Type': 'application/xml; charset=utf-8'
            },
            responseType: 'application/xml'
          });
          this.emit('open', res.jobInfo);
          this.id = res.jobInfo.id;
          this.state = res.jobInfo.state;
          return res.jobInfo;
        } catch (err) {
          this.emit('error', err);
          throw err;
        }
      })();
    }

    return this._jobInfo;
  }
  /**
   * Create a new batch instance in the job
   */


  createBatch() {
    const batch = new Batch(this);
    batch.on('queue', () => {
      this._batches[batch.id] = batch;
    });
    return batch;
  }
  /**
   * Get a batch instance specified by given batch ID
   */


  batch(batchId) {
    let batch = this._batches[batchId];

    if (!batch) {
      batch = new Batch(this, batchId);
      this._batches[batchId] = batch;
    }

    return batch;
  }
  /**
   * Check the latest job status from server
   */


  check() {
    const bulk = this._bulk;
    const logger = bulk._logger;

    this._jobInfo = (async () => {
      const jobId = await this.ready();
      const res = await bulk._request({
        method: 'GET',
        path: '/job/' + jobId,
        responseType: 'application/xml'
      });
      logger.debug(res.jobInfo);
      this.id = res.jobInfo.id;
      this.type = res.jobInfo.object;
      this.operation = res.jobInfo.operation;
      this.state = res.jobInfo.state;
      return res.jobInfo;
    })();

    return this._jobInfo;
  }
  /**
   * Wait till the job is assigned to server
   */


  ready() {
    return this.id ? _Promise.resolve(this.id) : this.open().then(({
      id
    }) => id);
  }
  /**
   * List all registered batch info in job
   */


  async list() {
    const bulk = this._bulk;
    const logger = bulk._logger;
    const jobId = await this.ready();
    const res = await bulk._request({
      method: 'GET',
      path: '/job/' + jobId + '/batch',
      responseType: 'application/xml'
    });
    logger.debug(res.batchInfoList.batchInfo);
    const batchInfoList = _Array$isArray(res.batchInfoList.batchInfo) ? res.batchInfoList.batchInfo : [res.batchInfoList.batchInfo];
    return batchInfoList;
  }
  /**
   * Close opened job
   */


  async close() {
    if (!this.id) {
      return;
    }

    try {
      const jobInfo = await this._changeState('Closed');
      this.id = null;
      this.emit('close', jobInfo);
      return jobInfo;
    } catch (err) {
      this.emit('error', err);
      throw err;
    }
  }
  /**
   * Set the status to abort
   */


  async abort() {
    if (!this.id) {
      return;
    }

    try {
      const jobInfo = await this._changeState('Aborted');
      this.id = null;
      this.emit('abort', jobInfo);
      return jobInfo;
    } catch (err) {
      this.emit('error', err);
      throw err;
    }
  }
  /**
   * @private
   */


  async _changeState(state) {
    const bulk = this._bulk;
    const logger = bulk._logger;

    this._jobInfo = (async () => {
      var _context2;

      const jobId = await this.ready();

      const body = _trimInstanceProperty(_context2 = ` 
<?xml version="1.0" encoding="UTF-8"?>
  <jobInfo xmlns="http://www.force.com/2009/06/asyncapi/dataload">
  <state>${state}</state>
</jobInfo>
      `).call(_context2);

      const res = await bulk._request({
        method: 'POST',
        path: '/job/' + jobId,
        body: body,
        headers: {
          'Content-Type': 'application/xml; charset=utf-8'
        },
        responseType: 'application/xml'
      });
      logger.debug(res.jobInfo);
      this.state = res.jobInfo.state;
      return res.jobInfo;
    })();

    return this._jobInfo;
  }

}
/*--------------------------------------------*/

class PollingTimeoutError extends Error {
  /**
   *
   */
  constructor(message, jobId, batchId) {
    super(message);

    _defineProperty(this, "jobId", void 0);

    _defineProperty(this, "batchId", void 0);

    this.name = 'PollingTimeout';
    this.jobId = jobId;
    this.batchId = batchId;
  }

}
/*--------------------------------------------*/

/**
 * Batch (extends Writable)
 */


export class Batch extends Writable {
  /**
   *
   */
  constructor(job, id) {
    super({
      objectMode: true
    });

    _defineProperty(this, "job", void 0);

    _defineProperty(this, "id", void 0);

    _defineProperty(this, "_bulk", void 0);

    _defineProperty(this, "_uploadStream", void 0);

    _defineProperty(this, "_downloadStream", void 0);

    _defineProperty(this, "_dataStream", void 0);

    _defineProperty(this, "_result", void 0);

    _defineProperty(this, "_error", void 0);

    _defineProperty(this, "run", this.execute);

    _defineProperty(this, "exec", this.execute);

    this.job = job;
    this.id = id;
    this._bulk = job._bulk; // default error handler to keep the latest error

    this.on('error', error => this._error = error); //
    // setup data streams
    //

    const converterOptions = {
      nullValue: '#N/A'
    };
    const uploadStream = this._uploadStream = new Serializable();
    const uploadDataStream = uploadStream.stream('csv', converterOptions);
    const downloadStream = this._downloadStream = new Parsable();
    const downloadDataStream = downloadStream.stream('csv', converterOptions);
    this.on('finish', () => uploadStream.end());
    uploadDataStream.once('readable', async () => {
      try {
        // ensure the job is opened in server or job id is already assigned
        await this.job.ready(); // pipe upload data to batch API request stream

        uploadDataStream.pipe(this._createRequestStream());
      } catch (err) {
        this.emit('error', err);
      }
    }); // duplex data stream, opened access to API programmers by Batch#stream()

    this._dataStream = concatStreamsAsDuplex(uploadDataStream, downloadDataStream);
  }
  /**
   * Connect batch API and create stream instance of request/response
   *
   * @private
   */


  _createRequestStream() {
    const bulk = this._bulk;
    const logger = bulk._logger;

    const req = bulk._request({
      method: 'POST',
      path: '/job/' + this.job.id + '/batch',
      headers: {
        'Content-Type': 'text/csv'
      },
      responseType: 'application/xml'
    });

    (async () => {
      try {
        const res = await req;
        logger.debug(res.batchInfo);
        this.id = res.batchInfo.id;
        this.emit('queue', res.batchInfo);
      } catch (err) {
        this.emit('error', err);
      }
    })();

    return req.stream();
  }
  /**
   * Implementation of Writable
   */


  _write(record_, enc, cb) {
    const {
      Id,
      type,
      attributes
    } = record_,
          rrec = _objectWithoutProperties(record_, ["Id", "type", "attributes"]);

    let record;

    switch (this.job.operation) {
      case 'insert':
        record = rrec;
        break;

      case 'delete':
      case 'hardDelete':
        record = {
          Id
        };
        break;

      default:
        record = _objectSpread({
          Id
        }, rrec);
    }

    this._uploadStream.write(record, enc, cb);
  }
  /**
   * Returns duplex stream which accepts CSV data input and batch result output
   */


  stream() {
    return this._dataStream;
  }
  /**
   * Execute batch operation
   */


  execute(input) {
    // if batch is already executed
    if (this._result) {
      throw new Error('Batch already executed.');
    }

    this._result = new _Promise((resolve, reject) => {
      this.once('response', resolve);
      this.once('error', reject);
    });

    if (isObject(input) && 'pipe' in input && isFunction(input.pipe)) {
      // if input has stream.Readable interface
      input.pipe(this._dataStream);
    } else {
      if (_Array$isArray(input)) {
        for (const record of input) {
          for (const key of _Object$keys(record)) {
            if (typeof record[key] === 'boolean') {
              record[key] = String(record[key]);
            }
          }

          this.write(record);
        }

        this.end();
      } else if (typeof input === 'string') {
        this._dataStream.write(input, 'utf8');

        this._dataStream.end();
      }
    } // return Batch instance for chaining


    return this;
  }

  /**
   * Promise/A+ interface
   * Delegate to promise, return promise instance for batch result
   */
  then(onResolved, onReject) {
    if (!this._result) {
      this.execute();
    }

    return this._result.then(onResolved, onReject);
  }
  /**
   * Check the latest batch status in server
   */


  async check() {
    const bulk = this._bulk;
    const logger = bulk._logger;
    const jobId = this.job.id;
    const batchId = this.id;

    if (!jobId || !batchId) {
      throw new Error('Batch not started.');
    }

    const res = await bulk._request({
      method: 'GET',
      path: '/job/' + jobId + '/batch/' + batchId,
      responseType: 'application/xml'
    });
    logger.debug(res.batchInfo);
    return res.batchInfo;
  }
  /**
   * Polling the batch result and retrieve
   */


  poll(interval, timeout) {
    const jobId = this.job.id;
    const batchId = this.id;

    if (!jobId || !batchId) {
      throw new Error('Batch not started.');
    }

    const startTime = new Date().getTime();

    const poll = async () => {
      const now = new Date().getTime();

      if (startTime + timeout < now) {
        const err = new PollingTimeoutError('Polling time out. Job Id = ' + jobId + ' , batch Id = ' + batchId, jobId, batchId);
        this.emit('error', err);
        return;
      }

      let res;

      try {
        res = await this.check();
      } catch (err) {
        this.emit('error', err);
        return;
      }

      if (res.state === 'Failed') {
        if (_parseInt(res.numberRecordsProcessed, 10) > 0) {
          this.retrieve();
        } else {
          this.emit('error', new Error(res.stateMessage));
        }
      } else if (res.state === 'Completed') {
        this.retrieve();
      } else {
        this.emit('progress', res);

        _setTimeout(poll, interval);
      }
    };

    _setTimeout(poll, interval);
  }
  /**
   * Retrieve batch result
   */


  async retrieve() {
    const bulk = this._bulk;
    const jobId = this.job.id;
    const job = this.job;
    const batchId = this.id;

    if (!jobId || !batchId) {
      throw new Error('Batch not started.');
    }

    try {
      const resp = await bulk._request({
        method: 'GET',
        path: '/job/' + jobId + '/batch/' + batchId + '/result'
      });
      let results;

      if (job.operation === 'query' || job.operation === 'queryAll') {
        var _context3;

        const res = resp;
        let resultId = res['result-list'].result;
        results = _mapInstanceProperty(_context3 = _Array$isArray(resultId) ? resultId : [resultId]).call(_context3, id => ({
          id,
          batchId,
          jobId
        }));
      } else {
        const res = resp;
        results = _mapInstanceProperty(res).call(res, ret => ({
          id: ret.Id || null,
          success: ret.Success === 'true',
          errors: ret.Error ? [ret.Error] : []
        }));
      }

      this.emit('response', results);
      return results;
    } catch (err) {
      this.emit('error', err);
      throw err;
    }
  }
  /**
   * Fetch query result as a record stream
   * @param {String} resultId - Result id
   * @returns {RecordStream} - Record stream, convertible to CSV data stream
   */


  result(resultId) {
    const jobId = this.job.id;
    const batchId = this.id;

    if (!jobId || !batchId) {
      throw new Error('Batch not started.');
    }

    const resultStream = new Parsable();
    const resultDataStream = resultStream.stream('csv');

    this._bulk._request({
      method: 'GET',
      path: '/job/' + jobId + '/batch/' + batchId + '/result/' + resultId,
      responseType: 'application/octet-stream'
    }).stream().pipe(resultDataStream);

    return resultStream;
  }

}
/*--------------------------------------------*/

/**
 *
 */

class BulkApi extends HttpApi {
  beforeSend(request) {
    var _this$_conn$accessTok;

    request.headers = _objectSpread(_objectSpread({}, request.headers), {}, {
      'X-SFDC-SESSION': (_this$_conn$accessTok = this._conn.accessToken) !== null && _this$_conn$accessTok !== void 0 ? _this$_conn$accessTok : ''
    });
  }

  isSessionExpired(response) {
    return response.statusCode === 400 && /<exceptionCode>InvalidSessionId<\/exceptionCode>/.test(response.body);
  }

  hasErrorInResponseBody(body) {
    return !!body.error;
  }

  parseError(body) {
    return {
      errorCode: body.error.exceptionCode,
      message: body.error.exceptionMessage
    };
  }

}
/*--------------------------------------------*/

/**
 * Class for Bulk API
 *
 * @class
 */


export class Bulk {
  /**
   * Polling interval in milliseconds
   */

  /**
   * Polling timeout in milliseconds
   * @type {Number}
   */

  /**
   *
   */
  constructor(conn) {
    _defineProperty(this, "_conn", void 0);

    _defineProperty(this, "_logger", void 0);

    _defineProperty(this, "pollInterval", 1000);

    _defineProperty(this, "pollTimeout", 10000);

    this._conn = conn;
    this._logger = conn._logger;
  }
  /**
   *
   */


  _request(request_) {
    const conn = this._conn;

    const {
      path,
      responseType
    } = request_,
          rreq = _objectWithoutProperties(request_, ["path", "responseType"]);

    const baseUrl = [conn.instanceUrl, 'services/async', conn.version].join('/');

    const request = _objectSpread(_objectSpread({}, rreq), {}, {
      url: baseUrl + path
    });

    return new BulkApi(this._conn, {
      responseType
    }).request(request);
  }
  /**
   * Create and start bulkload job and batch
   */


  load(type, operation, optionsOrInput, input) {
    let options = {};

    if (typeof optionsOrInput === 'string' || _Array$isArray(optionsOrInput) || isObject(optionsOrInput) && 'pipe' in optionsOrInput && typeof optionsOrInput.pipe === 'function') {
      // when options is not plain hash object, it is omitted
      input = optionsOrInput;
    } else {
      options = optionsOrInput;
    }

    const job = this.createJob(type, operation, options);
    const batch = job.createBatch();

    const cleanup = () => job.close();

    const cleanupOnError = err => {
      if (err.name !== 'PollingTimeout') {
        cleanup();
      }
    };

    batch.on('response', cleanup);
    batch.on('error', cleanupOnError);
    batch.on('queue', () => {
      batch === null || batch === void 0 ? void 0 : batch.poll(this.pollInterval, this.pollTimeout);
    });
    return batch.execute(input);
  }
  /**
   * Execute bulk query and get record stream
   */


  query(soql) {
    const m = soql.replace(/\([\s\S]+\)/g, '').match(/FROM\s+(\w+)/i);

    if (!m) {
      throw new Error('No sobject type found in query, maybe caused by invalid SOQL.');
    }

    const type = m[1];
    const recordStream = new Parsable();
    const dataStream = recordStream.stream('csv');

    (async () => {
      try {
        const results = await this.load(type, 'query', soql);

        const streams = _mapInstanceProperty(results).call(results, result => this.job(result.jobId).batch(result.batchId).result(result.id).stream());

        joinStreams(streams).pipe(dataStream);
      } catch (err) {
        recordStream.emit('error', err);
      }
    })();

    return recordStream;
  }
  /**
   * Create a new job instance
   */


  createJob(type, operation, options = {}) {
    return new Job(this, type, operation, options);
  }
  /**
   * Get a job instance specified by given job ID
   *
   * @param {String} jobId - Job ID
   * @returns {Bulk~Job}
   */


  job(jobId) {
    return new Job(this, null, null, null, jobId);
  }

}
/*--------------------------------------------*/

/*
 * Register hook in connection instantiation for dynamically adding this API module features
 */

registerModule('bulk', conn => new Bulk(conn));
export default Bulk;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvYnVsay50cyJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJXcml0YWJsZSIsImpvaW5TdHJlYW1zIiwiU2VyaWFsaXphYmxlIiwiUGFyc2FibGUiLCJIdHRwQXBpIiwicmVnaXN0ZXJNb2R1bGUiLCJjb25jYXRTdHJlYW1zQXNEdXBsZXgiLCJpc0Z1bmN0aW9uIiwiaXNPYmplY3QiLCJKb2IiLCJjb25zdHJ1Y3RvciIsImJ1bGsiLCJ0eXBlIiwib3BlcmF0aW9uIiwib3B0aW9ucyIsImpvYklkIiwiX2J1bGsiLCJpZCIsInN0YXRlIiwiX2JhdGNoZXMiLCJvbiIsImVycm9yIiwiX2Vycm9yIiwiaW5mbyIsIl9qb2JJbmZvIiwiY2hlY2siLCJvcGVuIiwiRXJyb3IiLCJ0b0xvd2VyQ2FzZSIsImJvZHkiLCJleHRJZEZpZWxkIiwiY29uY3VycmVuY3lNb2RlIiwiYXNzaWdubWVudFJ1bGVJZCIsInJlcyIsIl9yZXF1ZXN0IiwibWV0aG9kIiwicGF0aCIsImhlYWRlcnMiLCJyZXNwb25zZVR5cGUiLCJlbWl0Iiwiam9iSW5mbyIsImVyciIsImNyZWF0ZUJhdGNoIiwiYmF0Y2giLCJCYXRjaCIsImJhdGNoSWQiLCJsb2dnZXIiLCJfbG9nZ2VyIiwicmVhZHkiLCJkZWJ1ZyIsIm9iamVjdCIsInJlc29sdmUiLCJ0aGVuIiwibGlzdCIsImJhdGNoSW5mb0xpc3QiLCJiYXRjaEluZm8iLCJjbG9zZSIsIl9jaGFuZ2VTdGF0ZSIsImFib3J0IiwiUG9sbGluZ1RpbWVvdXRFcnJvciIsIm1lc3NhZ2UiLCJuYW1lIiwiam9iIiwib2JqZWN0TW9kZSIsImV4ZWN1dGUiLCJjb252ZXJ0ZXJPcHRpb25zIiwibnVsbFZhbHVlIiwidXBsb2FkU3RyZWFtIiwiX3VwbG9hZFN0cmVhbSIsInVwbG9hZERhdGFTdHJlYW0iLCJzdHJlYW0iLCJkb3dubG9hZFN0cmVhbSIsIl9kb3dubG9hZFN0cmVhbSIsImRvd25sb2FkRGF0YVN0cmVhbSIsImVuZCIsIm9uY2UiLCJwaXBlIiwiX2NyZWF0ZVJlcXVlc3RTdHJlYW0iLCJfZGF0YVN0cmVhbSIsInJlcSIsIl93cml0ZSIsInJlY29yZF8iLCJlbmMiLCJjYiIsIklkIiwiYXR0cmlidXRlcyIsInJyZWMiLCJyZWNvcmQiLCJ3cml0ZSIsImlucHV0IiwiX3Jlc3VsdCIsInJlamVjdCIsImtleSIsIlN0cmluZyIsIm9uUmVzb2x2ZWQiLCJvblJlamVjdCIsInBvbGwiLCJpbnRlcnZhbCIsInRpbWVvdXQiLCJzdGFydFRpbWUiLCJEYXRlIiwiZ2V0VGltZSIsIm5vdyIsIm51bWJlclJlY29yZHNQcm9jZXNzZWQiLCJyZXRyaWV2ZSIsInN0YXRlTWVzc2FnZSIsInJlc3AiLCJyZXN1bHRzIiwicmVzdWx0SWQiLCJyZXN1bHQiLCJyZXQiLCJzdWNjZXNzIiwiU3VjY2VzcyIsImVycm9ycyIsInJlc3VsdFN0cmVhbSIsInJlc3VsdERhdGFTdHJlYW0iLCJCdWxrQXBpIiwiYmVmb3JlU2VuZCIsInJlcXVlc3QiLCJfY29ubiIsImFjY2Vzc1Rva2VuIiwiaXNTZXNzaW9uRXhwaXJlZCIsInJlc3BvbnNlIiwic3RhdHVzQ29kZSIsInRlc3QiLCJoYXNFcnJvckluUmVzcG9uc2VCb2R5IiwicGFyc2VFcnJvciIsImVycm9yQ29kZSIsImV4Y2VwdGlvbkNvZGUiLCJleGNlcHRpb25NZXNzYWdlIiwiQnVsayIsImNvbm4iLCJyZXF1ZXN0XyIsInJyZXEiLCJiYXNlVXJsIiwiaW5zdGFuY2VVcmwiLCJ2ZXJzaW9uIiwiam9pbiIsInVybCIsImxvYWQiLCJvcHRpb25zT3JJbnB1dCIsImNyZWF0ZUpvYiIsImNsZWFudXAiLCJjbGVhbnVwT25FcnJvciIsInBvbGxJbnRlcnZhbCIsInBvbGxUaW1lb3V0IiwicXVlcnkiLCJzb3FsIiwibSIsInJlcGxhY2UiLCJtYXRjaCIsInJlY29yZFN0cmVhbSIsImRhdGFTdHJlYW0iLCJzdHJlYW1zIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7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S0FiRDs7QUFjQSxXQUFPOEcsWUFBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7QUFDRVYsRUFBQUEsU0FBUyxDQUNQakksSUFETyxFQUVQQyxTQUZPLEVBR1BDLE9BQW9CLEdBQUcsRUFIaEIsRUFJUDtBQUNBLFdBQU8sSUFBSUwsR0FBSixDQUFRLElBQVIsRUFBY0csSUFBZCxFQUFvQkMsU0FBcEIsRUFBK0JDLE9BQS9CLENBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0VnRCxFQUFBQSxHQUFHLENBQTRCL0MsS0FBNUIsRUFBMkM7QUFDNUMsV0FBTyxJQUFJTixHQUFKLENBQWdCLElBQWhCLEVBQXNCLElBQXRCLEVBQTRCLElBQTVCLEVBQWtDLElBQWxDLEVBQXdDTSxLQUF4QyxDQUFQO0FBQ0Q7O0FBeklpQztBQTRJcEM7O0FBQ0E7QUFDQTtBQUNBOztBQUNBVixjQUFjLENBQUMsTUFBRCxFQUFVOEgsSUFBRCxJQUFVLElBQUlELElBQUosQ0FBU0MsSUFBVCxDQUFuQixDQUFkO0FBRUEsZUFBZUQsSUFBZiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgTWFuYWdlcyBTYWxlc2ZvcmNlIEJ1bGsgQVBJIHJlbGF0ZWQgb3BlcmF0aW9uc1xuICogQGF1dGhvciBTaGluaWNoaSBUb21pdGEgPHNoaW5pY2hpLnRvbWl0YUBnbWFpbC5jb20+XG4gKi9cbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBEdXBsZXgsIFJlYWRhYmxlLCBXcml0YWJsZSB9IGZyb20gJ3N0cmVhbSc7XG5pbXBvcnQgam9pblN0cmVhbXMgZnJvbSAnbXVsdGlzdHJlYW0nO1xuaW1wb3J0IENvbm5lY3Rpb24gZnJvbSAnLi4vY29ubmVjdGlvbic7XG5pbXBvcnQgeyBTZXJpYWxpemFibGUsIFBhcnNhYmxlIH0gZnJvbSAnLi4vcmVjb3JkLXN0cmVhbSc7XG5pbXBvcnQgSHR0cEFwaSBmcm9tICcuLi9odHRwLWFwaSc7XG5pbXBvcnQgeyByZWdpc3Rlck1vZHVsZSB9IGZyb20gJy4uL2pzZm9yY2UnO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vdXRpbC9sb2dnZXInO1xuaW1wb3J0IHsgY29uY2F0U3RyZWFtc0FzRHVwbGV4IH0gZnJvbSAnLi4vdXRpbC9zdHJlYW0nO1xuaW1wb3J0IHtcbiAgSHR0cE1ldGhvZHMsXG4gIEh0dHBSZXF1ZXN0LFxuICBIdHRwUmVzcG9uc2UsXG4gIFJlY29yZCxcbiAgU2NoZW1hLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc09iamVjdCB9IGZyb20gJy4uL3V0aWwvZnVuY3Rpb24nO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuZXhwb3J0IHR5cGUgQnVsa09wZXJhdGlvbiA9XG4gIHwgJ2luc2VydCdcbiAgfCAndXBkYXRlJ1xuICB8ICd1cHNlcnQnXG4gIHwgJ2RlbGV0ZSdcbiAgfCAnaGFyZERlbGV0ZSdcbiAgfCAncXVlcnknXG4gIHwgJ3F1ZXJ5QWxsJztcblxuZXhwb3J0IHR5cGUgQnVsa09wdGlvbnMgPSB7XG4gIGV4dElkRmllbGQ/OiBzdHJpbmc7XG4gIGNvbmN1cnJlbmN5TW9kZT86ICdTZXJpYWwnIHwgJ1BhcmFsbGVsJztcbiAgYXNzaWdubWVudFJ1bGVJZD86IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIEpvYlN0YXRlID0gJ09wZW4nIHwgJ0Nsb3NlZCcgfCAnQWJvcnRlZCcgfCAnRmFpbGVkJyB8ICdVbmtub3duJztcblxuZXhwb3J0IHR5cGUgSm9iSW5mbyA9IHtcbiAgaWQ6IHN0cmluZztcbiAgb2JqZWN0OiBzdHJpbmc7XG4gIG9wZXJhdGlvbjogQnVsa09wZXJhdGlvbjtcbiAgc3RhdGU6IEpvYlN0YXRlO1xufTtcblxudHlwZSBKb2JJbmZvUmVzcG9uc2UgPSB7XG4gIGpvYkluZm86IEpvYkluZm87XG59O1xuXG5leHBvcnQgdHlwZSBCYXRjaFN0YXRlID1cbiAgfCAnUXVldWVkJ1xuICB8ICdJblByb2dyZXNzJ1xuICB8ICdDb21wbGV0ZWQnXG4gIHwgJ0ZhaWxlZCdcbiAgfCAnTm90UHJvY2Vzc2VkJztcblxuZXhwb3J0IHR5cGUgQmF0Y2hJbmZvID0ge1xuICBpZDogc3RyaW5nO1xuICBqb2JJZDogc3RyaW5nO1xuICBzdGF0ZTogQmF0Y2hTdGF0ZTtcbiAgc3RhdGVNZXNzYWdlOiBzdHJpbmc7XG4gIG51bWJlclJlY29yZHNQcm9jZXNzZWQ6IHN0cmluZztcbiAgbnVtYmVyUmVjb3Jkc0ZhaWxlZDogc3RyaW5nO1xuICB0b3RhbFByb2Nlc3NpbmdUaW1lOiBzdHJpbmc7XG59O1xuXG50eXBlIEJhdGNoSW5mb1Jlc3BvbnNlID0ge1xuICBiYXRjaEluZm86IEJhdGNoSW5mbztcbn07XG5cbnR5cGUgQmF0Y2hJbmZvTGlzdFJlc3BvbnNlID0ge1xuICBiYXRjaEluZm9MaXN0OiB7XG4gICAgYmF0Y2hJbmZvOiBCYXRjaEluZm8gfCBCYXRjaEluZm9bXTtcbiAgfTtcbn07XG5cbmV4cG9ydCB0eXBlIEJ1bGtRdWVyeUJhdGNoUmVzdWx0ID0gQXJyYXk8e1xuICBpZDogc3RyaW5nO1xuICBiYXRjaElkOiBzdHJpbmc7XG4gIGpvYklkOiBzdHJpbmc7XG59PjtcblxuZXhwb3J0IHR5cGUgQnVsa0luZ2VzdEJhdGNoUmVzdWx0ID0gQXJyYXk8e1xuICBpZDogc3RyaW5nIHwgbnVsbDtcbiAgc3VjY2VzczogYm9vbGVhbjtcbiAgZXJyb3JzOiBzdHJpbmdbXTtcbn0+O1xuXG5leHBvcnQgdHlwZSBCYXRjaFJlc3VsdDxPcHIgZXh0ZW5kcyBCdWxrT3BlcmF0aW9uPiA9IE9wciBleHRlbmRzXG4gIHwgJ3F1ZXJ5J1xuICB8ICdxdWVyeUFsbCdcbiAgPyBCdWxrUXVlcnlCYXRjaFJlc3VsdFxuICA6IEJ1bGtJbmdlc3RCYXRjaFJlc3VsdDtcblxudHlwZSBCdWxrSW5nZXN0UmVzdWx0UmVzcG9uc2UgPSBBcnJheTx7XG4gIElkOiBzdHJpbmc7XG4gIFN1Y2Nlc3M6IHN0cmluZztcbiAgRXJyb3I6IHN0cmluZztcbn0+O1xuXG50eXBlIEJ1bGtRdWVyeVJlc3VsdFJlc3BvbnNlID0ge1xuICAncmVzdWx0LWxpc3QnOiB7XG4gICAgcmVzdWx0OiBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgfTtcbn07XG5cbnR5cGUgQnVsa1JlcXVlc3QgPSB7XG4gIG1ldGhvZDogSHR0cE1ldGhvZHM7XG4gIHBhdGg6IHN0cmluZztcbiAgYm9keT86IHN0cmluZztcbiAgaGVhZGVycz86IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9O1xuICByZXNwb25zZVR5cGU/OiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIENsYXNzIGZvciBCdWxrIEFQSSBKb2JcbiAqL1xuZXhwb3J0IGNsYXNzIEpvYjxcbiAgUyBleHRlbmRzIFNjaGVtYSxcbiAgT3ByIGV4dGVuZHMgQnVsa09wZXJhdGlvblxuPiBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIHR5cGU6IHN0cmluZyB8IG51bGw7XG4gIG9wZXJhdGlvbjogT3ByIHwgbnVsbDtcbiAgb3B0aW9uczogQnVsa09wdGlvbnM7XG4gIGlkOiBzdHJpbmcgfCBudWxsO1xuICBzdGF0ZTogSm9iU3RhdGU7XG4gIF9idWxrOiBCdWxrPFM+O1xuICBfYmF0Y2hlczogeyBbaWQ6IHN0cmluZ106IEJhdGNoPFMsIE9wcj4gfTtcbiAgX2pvYkluZm86IFByb21pc2U8Sm9iSW5mbz4gfCB1bmRlZmluZWQ7XG4gIF9lcnJvcjogRXJyb3IgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBidWxrOiBCdWxrPFM+LFxuICAgIHR5cGU6IHN0cmluZyB8IG51bGwsXG4gICAgb3BlcmF0aW9uOiBPcHIgfCBudWxsLFxuICAgIG9wdGlvbnM6IEJ1bGtPcHRpb25zIHwgbnVsbCxcbiAgICBqb2JJZD86IHN0cmluZyxcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9idWxrID0gYnVsaztcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMub3BlcmF0aW9uID0gb3BlcmF0aW9uO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5pZCA9IGpvYklkID8/IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuaWQgPyAnT3BlbicgOiAnVW5rbm93bic7XG4gICAgdGhpcy5fYmF0Y2hlcyA9IHt9O1xuICAgIC8vIGRlZmF1bHQgZXJyb3IgaGFuZGxlciB0byBrZWVwIHRoZSBsYXRlc3QgZXJyb3JcbiAgICB0aGlzLm9uKCdlcnJvcicsIChlcnJvcikgPT4gKHRoaXMuX2Vycm9yID0gZXJyb3IpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gbGF0ZXN0IGpvYkluZm8gZnJvbSBjYWNoZVxuICAgKi9cbiAgaW5mbygpIHtcbiAgICAvLyBpZiBjYWNoZSBpcyBub3QgYXZhaWxhYmxlLCBjaGVjayB0aGUgbGF0ZXN0XG4gICAgaWYgKCF0aGlzLl9qb2JJbmZvKSB7XG4gICAgICB0aGlzLl9qb2JJbmZvID0gdGhpcy5jaGVjaygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fam9iSW5mbztcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVuIG5ldyBqb2IgYW5kIGdldCBqb2JpbmZvXG4gICAqL1xuICBvcGVuKCk6IFByb21pc2U8Sm9iSW5mbz4ge1xuICAgIGNvbnN0IGJ1bGsgPSB0aGlzLl9idWxrO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAvLyBpZiBzb2JqZWN0IHR5cGUgLyBvcGVyYXRpb24gaXMgbm90IHByb3ZpZGVkXG4gICAgaWYgKCF0aGlzLnR5cGUgfHwgIXRoaXMub3BlcmF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R5cGUgLyBvcGVyYXRpb24gaXMgcmVxdWlyZWQgdG8gb3BlbiBhIG5ldyBqb2InKTtcbiAgICB9XG5cbiAgICAvLyBpZiBub3QgcmVxdWVzdGVkIG9wZW5pbmcgam9iXG4gICAgaWYgKCF0aGlzLl9qb2JJbmZvKSB7XG4gICAgICBsZXQgb3BlcmF0aW9uID0gdGhpcy5vcGVyYXRpb24udG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChvcGVyYXRpb24gPT09ICdoYXJkZGVsZXRlJykge1xuICAgICAgICBvcGVyYXRpb24gPSAnaGFyZERlbGV0ZSc7XG4gICAgICB9XG4gICAgICBpZiAob3BlcmF0aW9uID09PSAncXVlcnlhbGwnKSB7XG4gICAgICAgIG9wZXJhdGlvbiA9ICdxdWVyeUFsbCc7XG4gICAgICB9XG4gICAgICBjb25zdCBib2R5ID0gYFxuPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIj8+XG48am9iSW5mbyAgeG1sbnM9XCJodHRwOi8vd3d3LmZvcmNlLmNvbS8yMDA5LzA2L2FzeW5jYXBpL2RhdGFsb2FkXCI+XG4gIDxvcGVyYXRpb24+JHtvcGVyYXRpb259PC9vcGVyYXRpb24+XG4gIDxvYmplY3Q+JHt0aGlzLnR5cGV9PC9vYmplY3Q+XG4gICR7XG4gICAgb3B0aW9ucy5leHRJZEZpZWxkXG4gICAgICA/IGA8ZXh0ZXJuYWxJZEZpZWxkTmFtZT4ke29wdGlvbnMuZXh0SWRGaWVsZH08L2V4dGVybmFsSWRGaWVsZE5hbWU+YFxuICAgICAgOiAnJ1xuICB9XG4gICR7XG4gICAgb3B0aW9ucy5jb25jdXJyZW5jeU1vZGVcbiAgICAgID8gYDxjb25jdXJyZW5jeU1vZGU+JHtvcHRpb25zLmNvbmN1cnJlbmN5TW9kZX08L2NvbmN1cnJlbmN5TW9kZT5gXG4gICAgICA6ICcnXG4gIH1cbiAgJHtcbiAgICBvcHRpb25zLmFzc2lnbm1lbnRSdWxlSWRcbiAgICAgID8gYDxhc3NpZ25tZW50UnVsZUlkPiR7b3B0aW9ucy5hc3NpZ25tZW50UnVsZUlkfTwvYXNzaWdubWVudFJ1bGVJZD5gXG4gICAgICA6ICcnXG4gIH1cbiAgPGNvbnRlbnRUeXBlPkNTVjwvY29udGVudFR5cGU+XG48L2pvYkluZm8+XG4gICAgICBgLnRyaW0oKTtcblxuICAgICAgdGhpcy5fam9iSW5mbyA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgYnVsay5fcmVxdWVzdDxKb2JJbmZvUmVzcG9uc2U+KHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgcGF0aDogJy9qb2InLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94bWw7IGNoYXJzZXQ9dXRmLTgnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2FwcGxpY2F0aW9uL3htbCcsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5lbWl0KCdvcGVuJywgcmVzLmpvYkluZm8pO1xuICAgICAgICAgIHRoaXMuaWQgPSByZXMuam9iSW5mby5pZDtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gcmVzLmpvYkluZm8uc3RhdGU7XG4gICAgICAgICAgcmV0dXJuIHJlcy5qb2JJbmZvO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9qb2JJbmZvO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBiYXRjaCBpbnN0YW5jZSBpbiB0aGUgam9iXG4gICAqL1xuICBjcmVhdGVCYXRjaCgpOiBCYXRjaDxTLCBPcHI+IHtcbiAgICBjb25zdCBiYXRjaCA9IG5ldyBCYXRjaCh0aGlzKTtcbiAgICBiYXRjaC5vbigncXVldWUnLCAoKSA9PiB7XG4gICAgICB0aGlzLl9iYXRjaGVzW2JhdGNoLmlkIV0gPSBiYXRjaDtcbiAgICB9KTtcbiAgICByZXR1cm4gYmF0Y2g7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgYmF0Y2ggaW5zdGFuY2Ugc3BlY2lmaWVkIGJ5IGdpdmVuIGJhdGNoIElEXG4gICAqL1xuICBiYXRjaChiYXRjaElkOiBzdHJpbmcpOiBCYXRjaDxTLCBPcHI+IHtcbiAgICBsZXQgYmF0Y2ggPSB0aGlzLl9iYXRjaGVzW2JhdGNoSWRdO1xuICAgIGlmICghYmF0Y2gpIHtcbiAgICAgIGJhdGNoID0gbmV3IEJhdGNoKHRoaXMsIGJhdGNoSWQpO1xuICAgICAgdGhpcy5fYmF0Y2hlc1tiYXRjaElkXSA9IGJhdGNoO1xuICAgIH1cbiAgICByZXR1cm4gYmF0Y2g7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdGhlIGxhdGVzdCBqb2Igc3RhdHVzIGZyb20gc2VydmVyXG4gICAqL1xuICBjaGVjaygpIHtcbiAgICBjb25zdCBidWxrID0gdGhpcy5fYnVsaztcbiAgICBjb25zdCBsb2dnZXIgPSBidWxrLl9sb2dnZXI7XG5cbiAgICB0aGlzLl9qb2JJbmZvID0gKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGpvYklkID0gYXdhaXQgdGhpcy5yZWFkeSgpO1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgYnVsay5fcmVxdWVzdDxKb2JJbmZvUmVzcG9uc2U+KHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgcGF0aDogJy9qb2IvJyArIGpvYklkLFxuICAgICAgICByZXNwb25zZVR5cGU6ICdhcHBsaWNhdGlvbi94bWwnLFxuICAgICAgfSk7XG4gICAgICBsb2dnZXIuZGVidWcocmVzLmpvYkluZm8pO1xuICAgICAgdGhpcy5pZCA9IHJlcy5qb2JJbmZvLmlkO1xuICAgICAgdGhpcy50eXBlID0gcmVzLmpvYkluZm8ub2JqZWN0O1xuICAgICAgdGhpcy5vcGVyYXRpb24gPSByZXMuam9iSW5mby5vcGVyYXRpb24gYXMgT3ByO1xuICAgICAgdGhpcy5zdGF0ZSA9IHJlcy5qb2JJbmZvLnN0YXRlO1xuICAgICAgcmV0dXJuIHJlcy5qb2JJbmZvO1xuICAgIH0pKCk7XG5cbiAgICByZXR1cm4gdGhpcy5fam9iSW5mbztcbiAgfVxuXG4gIC8qKlxuICAgKiBXYWl0IHRpbGwgdGhlIGpvYiBpcyBhc3NpZ25lZCB0byBzZXJ2ZXJcbiAgICovXG4gIHJlYWR5KCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuaWRcbiAgICAgID8gUHJvbWlzZS5yZXNvbHZlKHRoaXMuaWQpXG4gICAgICA6IHRoaXMub3BlbigpLnRoZW4oKHsgaWQgfSkgPT4gaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgYWxsIHJlZ2lzdGVyZWQgYmF0Y2ggaW5mbyBpbiBqb2JcbiAgICovXG4gIGFzeW5jIGxpc3QoKSB7XG4gICAgY29uc3QgYnVsayA9IHRoaXMuX2J1bGs7XG4gICAgY29uc3QgbG9nZ2VyID0gYnVsay5fbG9nZ2VyO1xuICAgIGNvbnN0IGpvYklkID0gYXdhaXQgdGhpcy5yZWFkeSgpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGJ1bGsuX3JlcXVlc3Q8QmF0Y2hJbmZvTGlzdFJlc3BvbnNlPih7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgcGF0aDogJy9qb2IvJyArIGpvYklkICsgJy9iYXRjaCcsXG4gICAgICByZXNwb25zZVR5cGU6ICdhcHBsaWNhdGlvbi94bWwnLFxuICAgIH0pO1xuICAgIGxvZ2dlci5kZWJ1ZyhyZXMuYmF0Y2hJbmZvTGlzdC5iYXRjaEluZm8pO1xuICAgIGNvbnN0IGJhdGNoSW5mb0xpc3QgPSBBcnJheS5pc0FycmF5KHJlcy5iYXRjaEluZm9MaXN0LmJhdGNoSW5mbylcbiAgICAgID8gcmVzLmJhdGNoSW5mb0xpc3QuYmF0Y2hJbmZvXG4gICAgICA6IFtyZXMuYmF0Y2hJbmZvTGlzdC5iYXRjaEluZm9dO1xuICAgIHJldHVybiBiYXRjaEluZm9MaXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlIG9wZW5lZCBqb2JcbiAgICovXG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIGlmICghdGhpcy5pZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qgam9iSW5mbyA9IGF3YWl0IHRoaXMuX2NoYW5nZVN0YXRlKCdDbG9zZWQnKTtcbiAgICAgIHRoaXMuaWQgPSBudWxsO1xuICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIGpvYkluZm8pO1xuICAgICAgcmV0dXJuIGpvYkluZm87XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzdGF0dXMgdG8gYWJvcnRcbiAgICovXG4gIGFzeW5jIGFib3J0KCkge1xuICAgIGlmICghdGhpcy5pZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qgam9iSW5mbyA9IGF3YWl0IHRoaXMuX2NoYW5nZVN0YXRlKCdBYm9ydGVkJyk7XG4gICAgICB0aGlzLmlkID0gbnVsbDtcbiAgICAgIHRoaXMuZW1pdCgnYWJvcnQnLCBqb2JJbmZvKTtcbiAgICAgIHJldHVybiBqb2JJbmZvO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBfY2hhbmdlU3RhdGUoc3RhdGU6IEpvYlN0YXRlKSB7XG4gICAgY29uc3QgYnVsayA9IHRoaXMuX2J1bGs7XG4gICAgY29uc3QgbG9nZ2VyID0gYnVsay5fbG9nZ2VyO1xuXG4gICAgdGhpcy5fam9iSW5mbyA9IChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBqb2JJZCA9IGF3YWl0IHRoaXMucmVhZHkoKTtcbiAgICAgIGNvbnN0IGJvZHkgPSBgIFxuPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIj8+XG4gIDxqb2JJbmZvIHhtbG5zPVwiaHR0cDovL3d3dy5mb3JjZS5jb20vMjAwOS8wNi9hc3luY2FwaS9kYXRhbG9hZFwiPlxuICA8c3RhdGU+JHtzdGF0ZX08L3N0YXRlPlxuPC9qb2JJbmZvPlxuICAgICAgYC50cmltKCk7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBidWxrLl9yZXF1ZXN0PEpvYkluZm9SZXNwb25zZT4oe1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgcGF0aDogJy9qb2IvJyArIGpvYklkLFxuICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94bWw7IGNoYXJzZXQ9dXRmLTgnLFxuICAgICAgICB9LFxuICAgICAgICByZXNwb25zZVR5cGU6ICdhcHBsaWNhdGlvbi94bWwnLFxuICAgICAgfSk7XG4gICAgICBsb2dnZXIuZGVidWcocmVzLmpvYkluZm8pO1xuICAgICAgdGhpcy5zdGF0ZSA9IHJlcy5qb2JJbmZvLnN0YXRlO1xuICAgICAgcmV0dXJuIHJlcy5qb2JJbmZvO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIHRoaXMuX2pvYkluZm87XG4gIH1cbn1cblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5jbGFzcyBQb2xsaW5nVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBqb2JJZDogc3RyaW5nO1xuICBiYXRjaElkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIGpvYklkOiBzdHJpbmcsIGJhdGNoSWQ6IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdQb2xsaW5nVGltZW91dCc7XG4gICAgdGhpcy5qb2JJZCA9IGpvYklkO1xuICAgIHRoaXMuYmF0Y2hJZCA9IGJhdGNoSWQ7XG4gIH1cbn1cblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKipcbiAqIEJhdGNoIChleHRlbmRzIFdyaXRhYmxlKVxuICovXG5leHBvcnQgY2xhc3MgQmF0Y2g8XG4gIFMgZXh0ZW5kcyBTY2hlbWEsXG4gIE9wciBleHRlbmRzIEJ1bGtPcGVyYXRpb25cbj4gZXh0ZW5kcyBXcml0YWJsZSB7XG4gIGpvYjogSm9iPFMsIE9wcj47XG4gIGlkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIF9idWxrOiBCdWxrPFM+O1xuICBfdXBsb2FkU3RyZWFtOiBTZXJpYWxpemFibGU7XG4gIF9kb3dubG9hZFN0cmVhbTogUGFyc2FibGU7XG4gIF9kYXRhU3RyZWFtOiBEdXBsZXg7XG4gIF9yZXN1bHQ6IFByb21pc2U8QmF0Y2hSZXN1bHQ8T3ByPj4gfCB1bmRlZmluZWQ7XG4gIF9lcnJvcjogRXJyb3IgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihqb2I6IEpvYjxTLCBPcHI+LCBpZD86IHN0cmluZykge1xuICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICB0aGlzLmpvYiA9IGpvYjtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5fYnVsayA9IGpvYi5fYnVsaztcblxuICAgIC8vIGRlZmF1bHQgZXJyb3IgaGFuZGxlciB0byBrZWVwIHRoZSBsYXRlc3QgZXJyb3JcbiAgICB0aGlzLm9uKCdlcnJvcicsIChlcnJvcikgPT4gKHRoaXMuX2Vycm9yID0gZXJyb3IpKTtcblxuICAgIC8vXG4gICAgLy8gc2V0dXAgZGF0YSBzdHJlYW1zXG4gICAgLy9cbiAgICBjb25zdCBjb252ZXJ0ZXJPcHRpb25zID0geyBudWxsVmFsdWU6ICcjTi9BJyB9O1xuICAgIGNvbnN0IHVwbG9hZFN0cmVhbSA9ICh0aGlzLl91cGxvYWRTdHJlYW0gPSBuZXcgU2VyaWFsaXphYmxlKCkpO1xuICAgIGNvbnN0IHVwbG9hZERhdGFTdHJlYW0gPSB1cGxvYWRTdHJlYW0uc3RyZWFtKCdjc3YnLCBjb252ZXJ0ZXJPcHRpb25zKTtcbiAgICBjb25zdCBkb3dubG9hZFN0cmVhbSA9ICh0aGlzLl9kb3dubG9hZFN0cmVhbSA9IG5ldyBQYXJzYWJsZSgpKTtcbiAgICBjb25zdCBkb3dubG9hZERhdGFTdHJlYW0gPSBkb3dubG9hZFN0cmVhbS5zdHJlYW0oJ2NzdicsIGNvbnZlcnRlck9wdGlvbnMpO1xuXG4gICAgdGhpcy5vbignZmluaXNoJywgKCkgPT4gdXBsb2FkU3RyZWFtLmVuZCgpKTtcbiAgICB1cGxvYWREYXRhU3RyZWFtLm9uY2UoJ3JlYWRhYmxlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gZW5zdXJlIHRoZSBqb2IgaXMgb3BlbmVkIGluIHNlcnZlciBvciBqb2IgaWQgaXMgYWxyZWFkeSBhc3NpZ25lZFxuICAgICAgICBhd2FpdCB0aGlzLmpvYi5yZWFkeSgpO1xuICAgICAgICAvLyBwaXBlIHVwbG9hZCBkYXRhIHRvIGJhdGNoIEFQSSByZXF1ZXN0IHN0cmVhbVxuICAgICAgICB1cGxvYWREYXRhU3RyZWFtLnBpcGUodGhpcy5fY3JlYXRlUmVxdWVzdFN0cmVhbSgpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGR1cGxleCBkYXRhIHN0cmVhbSwgb3BlbmVkIGFjY2VzcyB0byBBUEkgcHJvZ3JhbW1lcnMgYnkgQmF0Y2gjc3RyZWFtKClcbiAgICB0aGlzLl9kYXRhU3RyZWFtID0gY29uY2F0U3RyZWFtc0FzRHVwbGV4KFxuICAgICAgdXBsb2FkRGF0YVN0cmVhbSxcbiAgICAgIGRvd25sb2FkRGF0YVN0cmVhbSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3QgYmF0Y2ggQVBJIGFuZCBjcmVhdGUgc3RyZWFtIGluc3RhbmNlIG9mIHJlcXVlc3QvcmVzcG9uc2VcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jcmVhdGVSZXF1ZXN0U3RyZWFtKCkge1xuICAgIGNvbnN0IGJ1bGsgPSB0aGlzLl9idWxrO1xuICAgIGNvbnN0IGxvZ2dlciA9IGJ1bGsuX2xvZ2dlcjtcbiAgICBjb25zdCByZXEgPSBidWxrLl9yZXF1ZXN0PEJhdGNoSW5mb1Jlc3BvbnNlPih7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIHBhdGg6ICcvam9iLycgKyB0aGlzLmpvYi5pZCArICcvYmF0Y2gnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ3RleHQvY3N2JyxcbiAgICAgIH0sXG4gICAgICByZXNwb25zZVR5cGU6ICdhcHBsaWNhdGlvbi94bWwnLFxuICAgIH0pO1xuICAgIChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCByZXE7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhyZXMuYmF0Y2hJbmZvKTtcbiAgICAgICAgdGhpcy5pZCA9IHJlcy5iYXRjaEluZm8uaWQ7XG4gICAgICAgIHRoaXMuZW1pdCgncXVldWUnLCByZXMuYmF0Y2hJbmZvKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICAgIHJldHVybiByZXEuc3RyZWFtKCk7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2YgV3JpdGFibGVcbiAgICovXG4gIF93cml0ZShyZWNvcmRfOiBSZWNvcmQsIGVuYzogc3RyaW5nLCBjYjogKCkgPT4gdm9pZCkge1xuICAgIGNvbnN0IHsgSWQsIHR5cGUsIGF0dHJpYnV0ZXMsIC4uLnJyZWMgfSA9IHJlY29yZF87XG4gICAgbGV0IHJlY29yZDtcbiAgICBzd2l0Y2ggKHRoaXMuam9iLm9wZXJhdGlvbikge1xuICAgICAgY2FzZSAnaW5zZXJ0JzpcbiAgICAgICAgcmVjb3JkID0gcnJlYztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgY2FzZSAnaGFyZERlbGV0ZSc6XG4gICAgICAgIHJlY29yZCA9IHsgSWQgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZWNvcmQgPSB7IElkLCAuLi5ycmVjIH07XG4gICAgfVxuICAgIHRoaXMuX3VwbG9hZFN0cmVhbS53cml0ZShyZWNvcmQsIGVuYywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZHVwbGV4IHN0cmVhbSB3aGljaCBhY2NlcHRzIENTViBkYXRhIGlucHV0IGFuZCBiYXRjaCByZXN1bHQgb3V0cHV0XG4gICAqL1xuICBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTdHJlYW07XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBiYXRjaCBvcGVyYXRpb25cbiAgICovXG4gIGV4ZWN1dGUoaW5wdXQ/OiBzdHJpbmcgfCBSZWNvcmRbXSB8IFJlYWRhYmxlKSB7XG4gICAgLy8gaWYgYmF0Y2ggaXMgYWxyZWFkeSBleGVjdXRlZFxuICAgIGlmICh0aGlzLl9yZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmF0Y2ggYWxyZWFkeSBleGVjdXRlZC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXN1bHQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLm9uY2UoJ3Jlc3BvbnNlJywgcmVzb2x2ZSk7XG4gICAgICB0aGlzLm9uY2UoJ2Vycm9yJywgcmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGlmIChpc09iamVjdChpbnB1dCkgJiYgJ3BpcGUnIGluIGlucHV0ICYmIGlzRnVuY3Rpb24oaW5wdXQucGlwZSkpIHtcbiAgICAgIC8vIGlmIGlucHV0IGhhcyBzdHJlYW0uUmVhZGFibGUgaW50ZXJmYWNlXG4gICAgICBpbnB1dC5waXBlKHRoaXMuX2RhdGFTdHJlYW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgZm9yIChjb25zdCByZWNvcmQgb2YgaW5wdXQpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhyZWNvcmQpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlY29yZFtrZXldID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgcmVjb3JkW2tleV0gPSBTdHJpbmcocmVjb3JkW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLndyaXRlKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9kYXRhU3RyZWFtLndyaXRlKGlucHV0LCAndXRmOCcpO1xuICAgICAgICB0aGlzLl9kYXRhU3RyZWFtLmVuZCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybiBCYXRjaCBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJ1biA9IHRoaXMuZXhlY3V0ZTtcblxuICBleGVjID0gdGhpcy5leGVjdXRlO1xuXG4gIC8qKlxuICAgKiBQcm9taXNlL0ErIGludGVyZmFjZVxuICAgKiBEZWxlZ2F0ZSB0byBwcm9taXNlLCByZXR1cm4gcHJvbWlzZSBpbnN0YW5jZSBmb3IgYmF0Y2ggcmVzdWx0XG4gICAqL1xuICB0aGVuKFxuICAgIG9uUmVzb2x2ZWQ6IChyZXM6IEJhdGNoUmVzdWx0PE9wcj4pID0+IHZvaWQsXG4gICAgb25SZWplY3Q6IChlcnI6IGFueSkgPT4gdm9pZCxcbiAgKSB7XG4gICAgaWYgKCF0aGlzLl9yZXN1bHQpIHtcbiAgICAgIHRoaXMuZXhlY3V0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVzdWx0IS50aGVuKG9uUmVzb2x2ZWQsIG9uUmVqZWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0aGUgbGF0ZXN0IGJhdGNoIHN0YXR1cyBpbiBzZXJ2ZXJcbiAgICovXG4gIGFzeW5jIGNoZWNrKCkge1xuICAgIGNvbnN0IGJ1bGsgPSB0aGlzLl9idWxrO1xuICAgIGNvbnN0IGxvZ2dlciA9IGJ1bGsuX2xvZ2dlcjtcbiAgICBjb25zdCBqb2JJZCA9IHRoaXMuam9iLmlkO1xuICAgIGNvbnN0IGJhdGNoSWQgPSB0aGlzLmlkO1xuXG4gICAgaWYgKCFqb2JJZCB8fCAhYmF0Y2hJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYXRjaCBub3Qgc3RhcnRlZC4nKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYnVsay5fcmVxdWVzdDxCYXRjaEluZm9SZXNwb25zZT4oe1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHBhdGg6ICcvam9iLycgKyBqb2JJZCArICcvYmF0Y2gvJyArIGJhdGNoSWQsXG4gICAgICByZXNwb25zZVR5cGU6ICdhcHBsaWNhdGlvbi94bWwnLFxuICAgIH0pO1xuICAgIGxvZ2dlci5kZWJ1ZyhyZXMuYmF0Y2hJbmZvKTtcbiAgICByZXR1cm4gcmVzLmJhdGNoSW5mbztcbiAgfVxuXG4gIC8qKlxuICAgKiBQb2xsaW5nIHRoZSBiYXRjaCByZXN1bHQgYW5kIHJldHJpZXZlXG4gICAqL1xuICBwb2xsKGludGVydmFsOiBudW1iZXIsIHRpbWVvdXQ6IG51bWJlcikge1xuICAgIGNvbnN0IGpvYklkID0gdGhpcy5qb2IuaWQ7XG4gICAgY29uc3QgYmF0Y2hJZCA9IHRoaXMuaWQ7XG5cbiAgICBpZiAoIWpvYklkIHx8ICFiYXRjaElkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhdGNoIG5vdCBzdGFydGVkLicpO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBjb25zdCBwb2xsID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICBpZiAoc3RhcnRUaW1lICsgdGltZW91dCA8IG5vdykge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgUG9sbGluZ1RpbWVvdXRFcnJvcihcbiAgICAgICAgICAnUG9sbGluZyB0aW1lIG91dC4gSm9iIElkID0gJyArIGpvYklkICsgJyAsIGJhdGNoIElkID0gJyArIGJhdGNoSWQsXG4gICAgICAgICAgam9iSWQsXG4gICAgICAgICAgYmF0Y2hJZCxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCByZXM7XG4gICAgICB0cnkge1xuICAgICAgICByZXMgPSBhd2FpdCB0aGlzLmNoZWNrKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZXMuc3RhdGUgPT09ICdGYWlsZWQnKSB7XG4gICAgICAgIGlmIChwYXJzZUludChyZXMubnVtYmVyUmVjb3Jkc1Byb2Nlc3NlZCwgMTApID4gMCkge1xuICAgICAgICAgIHRoaXMucmV0cmlldmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKHJlcy5zdGF0ZU1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZXMuc3RhdGUgPT09ICdDb21wbGV0ZWQnKSB7XG4gICAgICAgIHRoaXMucmV0cmlldmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCByZXMpO1xuICAgICAgICBzZXRUaW1lb3V0KHBvbGwsIGludGVydmFsKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHNldFRpbWVvdXQocG9sbCwgaW50ZXJ2YWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGJhdGNoIHJlc3VsdFxuICAgKi9cbiAgYXN5bmMgcmV0cmlldmUoKSB7XG4gICAgY29uc3QgYnVsayA9IHRoaXMuX2J1bGs7XG4gICAgY29uc3Qgam9iSWQgPSB0aGlzLmpvYi5pZDtcbiAgICBjb25zdCBqb2IgPSB0aGlzLmpvYjtcbiAgICBjb25zdCBiYXRjaElkID0gdGhpcy5pZDtcblxuICAgIGlmICgham9iSWQgfHwgIWJhdGNoSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmF0Y2ggbm90IHN0YXJ0ZWQuJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBidWxrLl9yZXF1ZXN0PFxuICAgICAgICBCdWxrSW5nZXN0UmVzdWx0UmVzcG9uc2UgfCBCdWxrUXVlcnlSZXN1bHRSZXNwb25zZVxuICAgICAgPih7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIHBhdGg6ICcvam9iLycgKyBqb2JJZCArICcvYmF0Y2gvJyArIGJhdGNoSWQgKyAnL3Jlc3VsdCcsXG4gICAgICB9KTtcbiAgICAgIGxldCByZXN1bHRzOiBCdWxrSW5nZXN0QmF0Y2hSZXN1bHQgfCBCdWxrUXVlcnlCYXRjaFJlc3VsdDtcbiAgICAgIGlmIChqb2Iub3BlcmF0aW9uID09PSAncXVlcnknIHx8IGpvYi5vcGVyYXRpb24gPT09ICdxdWVyeUFsbCcpIHtcbiAgICAgICAgY29uc3QgcmVzID0gcmVzcCBhcyBCdWxrUXVlcnlSZXN1bHRSZXNwb25zZTtcbiAgICAgICAgbGV0IHJlc3VsdElkID0gcmVzWydyZXN1bHQtbGlzdCddLnJlc3VsdDtcbiAgICAgICAgcmVzdWx0cyA9IChBcnJheS5pc0FycmF5KHJlc3VsdElkKVxuICAgICAgICAgID8gcmVzdWx0SWRcbiAgICAgICAgICA6IFtyZXN1bHRJZF1cbiAgICAgICAgKS5tYXAoKGlkKSA9PiAoeyBpZCwgYmF0Y2hJZCwgam9iSWQgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzID0gcmVzcCBhcyBCdWxrSW5nZXN0UmVzdWx0UmVzcG9uc2U7XG4gICAgICAgIHJlc3VsdHMgPSByZXMubWFwKChyZXQpID0+ICh7XG4gICAgICAgICAgaWQ6IHJldC5JZCB8fCBudWxsLFxuICAgICAgICAgIHN1Y2Nlc3M6IHJldC5TdWNjZXNzID09PSAndHJ1ZScsXG4gICAgICAgICAgZXJyb3JzOiByZXQuRXJyb3IgPyBbcmV0LkVycm9yXSA6IFtdLFxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoJ3Jlc3BvbnNlJywgcmVzdWx0cyk7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBxdWVyeSByZXN1bHQgYXMgYSByZWNvcmQgc3RyZWFtXG4gICAqIEBwYXJhbSB7U3RyaW5nfSByZXN1bHRJZCAtIFJlc3VsdCBpZFxuICAgKiBAcmV0dXJucyB7UmVjb3JkU3RyZWFtfSAtIFJlY29yZCBzdHJlYW0sIGNvbnZlcnRpYmxlIHRvIENTViBkYXRhIHN0cmVhbVxuICAgKi9cbiAgcmVzdWx0KHJlc3VsdElkOiBzdHJpbmcpIHtcbiAgICBjb25zdCBqb2JJZCA9IHRoaXMuam9iLmlkO1xuICAgIGNvbnN0IGJhdGNoSWQgPSB0aGlzLmlkO1xuICAgIGlmICgham9iSWQgfHwgIWJhdGNoSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmF0Y2ggbm90IHN0YXJ0ZWQuJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdFN0cmVhbSA9IG5ldyBQYXJzYWJsZSgpO1xuICAgIGNvbnN0IHJlc3VsdERhdGFTdHJlYW0gPSByZXN1bHRTdHJlYW0uc3RyZWFtKCdjc3YnKTtcbiAgICB0aGlzLl9idWxrXG4gICAgICAuX3JlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBwYXRoOiAnL2pvYi8nICsgam9iSWQgKyAnL2JhdGNoLycgKyBiYXRjaElkICsgJy9yZXN1bHQvJyArIHJlc3VsdElkLFxuICAgICAgICByZXNwb25zZVR5cGU6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLFxuICAgICAgfSlcbiAgICAgIC5zdHJlYW0oKVxuICAgICAgLnBpcGUocmVzdWx0RGF0YVN0cmVhbSk7XG4gICAgcmV0dXJuIHJlc3VsdFN0cmVhbTtcbiAgfVxufVxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qKlxuICpcbiAqL1xuY2xhc3MgQnVsa0FwaTxTIGV4dGVuZHMgU2NoZW1hPiBleHRlbmRzIEh0dHBBcGk8Uz4ge1xuICBiZWZvcmVTZW5kKHJlcXVlc3Q6IEh0dHBSZXF1ZXN0KSB7XG4gICAgcmVxdWVzdC5oZWFkZXJzID0ge1xuICAgICAgLi4ucmVxdWVzdC5oZWFkZXJzLFxuICAgICAgJ1gtU0ZEQy1TRVNTSU9OJzogdGhpcy5fY29ubi5hY2Nlc3NUb2tlbiA/PyAnJyxcbiAgICB9O1xuICB9XG5cbiAgaXNTZXNzaW9uRXhwaXJlZChyZXNwb25zZTogSHR0cFJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQwMCAmJlxuICAgICAgLzxleGNlcHRpb25Db2RlPkludmFsaWRTZXNzaW9uSWQ8XFwvZXhjZXB0aW9uQ29kZT4vLnRlc3QocmVzcG9uc2UuYm9keSlcbiAgICApO1xuICB9XG5cbiAgaGFzRXJyb3JJblJlc3BvbnNlQm9keShib2R5OiBhbnkpIHtcbiAgICByZXR1cm4gISFib2R5LmVycm9yO1xuICB9XG5cbiAgcGFyc2VFcnJvcihib2R5OiBhbnkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3JDb2RlOiBib2R5LmVycm9yLmV4Y2VwdGlvbkNvZGUsXG4gICAgICBtZXNzYWdlOiBib2R5LmVycm9yLmV4Y2VwdGlvbk1lc3NhZ2UsXG4gICAgfTtcbiAgfVxufVxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBDbGFzcyBmb3IgQnVsayBBUElcbiAqXG4gKiBAY2xhc3NcbiAqL1xuZXhwb3J0IGNsYXNzIEJ1bGs8UyBleHRlbmRzIFNjaGVtYT4ge1xuICBfY29ubjogQ29ubmVjdGlvbjxTPjtcbiAgX2xvZ2dlcjogTG9nZ2VyO1xuXG4gIC8qKlxuICAgKiBQb2xsaW5nIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuICAgKi9cbiAgcG9sbEludGVydmFsID0gMTAwMDtcblxuICAvKipcbiAgICogUG9sbGluZyB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgcG9sbFRpbWVvdXQgPSAxMDAwMDtcblxuICAvKipcbiAgICpcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbm46IENvbm5lY3Rpb248Uz4pIHtcbiAgICB0aGlzLl9jb25uID0gY29ubjtcbiAgICB0aGlzLl9sb2dnZXIgPSBjb25uLl9sb2dnZXI7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICovXG4gIF9yZXF1ZXN0PFQ+KHJlcXVlc3RfOiBCdWxrUmVxdWVzdCkge1xuICAgIGNvbnN0IGNvbm4gPSB0aGlzLl9jb25uO1xuICAgIGNvbnN0IHsgcGF0aCwgcmVzcG9uc2VUeXBlLCAuLi5ycmVxIH0gPSByZXF1ZXN0XztcbiAgICBjb25zdCBiYXNlVXJsID0gW2Nvbm4uaW5zdGFuY2VVcmwsICdzZXJ2aWNlcy9hc3luYycsIGNvbm4udmVyc2lvbl0uam9pbihcbiAgICAgICcvJyxcbiAgICApO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAuLi5ycmVxLFxuICAgICAgdXJsOiBiYXNlVXJsICsgcGF0aCxcbiAgICB9O1xuICAgIHJldHVybiBuZXcgQnVsa0FwaSh0aGlzLl9jb25uLCB7IHJlc3BvbnNlVHlwZSB9KS5yZXF1ZXN0PFQ+KHJlcXVlc3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgc3RhcnQgYnVsa2xvYWQgam9iIGFuZCBiYXRjaFxuICAgKi9cbiAgbG9hZDxPcHIgZXh0ZW5kcyBCdWxrT3BlcmF0aW9uPihcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgb3BlcmF0aW9uOiBPcHIsXG4gICAgaW5wdXQ/OiBSZWNvcmRbXSB8IFJlYWRhYmxlIHwgc3RyaW5nLFxuICApOiBCYXRjaDxTLCBPcHI+O1xuICBsb2FkPE9wciBleHRlbmRzIEJ1bGtPcGVyYXRpb24+KFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBvcGVyYXRpb246IE9wcixcbiAgICBvcHRpb25zT3JJbnB1dD86IEJ1bGtPcHRpb25zIHwgUmVjb3JkW10gfCBSZWFkYWJsZSB8IHN0cmluZyxcbiAgICBpbnB1dD86IFJlY29yZFtdIHwgUmVhZGFibGUgfCBzdHJpbmcsXG4gICk6IEJhdGNoPFMsIE9wcj47XG4gIGxvYWQ8T3ByIGV4dGVuZHMgQnVsa09wZXJhdGlvbj4oXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIG9wZXJhdGlvbjogT3ByLFxuICAgIG9wdGlvbnNPcklucHV0PzogQnVsa09wdGlvbnMgfCBSZWNvcmRbXSB8IFJlYWRhYmxlIHwgc3RyaW5nLFxuICAgIGlucHV0PzogUmVjb3JkW10gfCBSZWFkYWJsZSB8IHN0cmluZyxcbiAgKSB7XG4gICAgbGV0IG9wdGlvbnM6IEJ1bGtPcHRpb25zID0ge307XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG9wdGlvbnNPcklucHV0ID09PSAnc3RyaW5nJyB8fFxuICAgICAgQXJyYXkuaXNBcnJheShvcHRpb25zT3JJbnB1dCkgfHxcbiAgICAgIChpc09iamVjdChvcHRpb25zT3JJbnB1dCkgJiZcbiAgICAgICAgJ3BpcGUnIGluIG9wdGlvbnNPcklucHV0ICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zT3JJbnB1dC5waXBlID09PSAnZnVuY3Rpb24nKVxuICAgICkge1xuICAgICAgLy8gd2hlbiBvcHRpb25zIGlzIG5vdCBwbGFpbiBoYXNoIG9iamVjdCwgaXQgaXMgb21pdHRlZFxuICAgICAgaW5wdXQgPSBvcHRpb25zT3JJbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPcklucHV0IGFzIEJ1bGtPcHRpb25zO1xuICAgIH1cbiAgICBjb25zdCBqb2IgPSB0aGlzLmNyZWF0ZUpvYih0eXBlLCBvcGVyYXRpb24sIG9wdGlvbnMpO1xuICAgIGNvbnN0IGJhdGNoID0gam9iLmNyZWF0ZUJhdGNoKCk7XG4gICAgY29uc3QgY2xlYW51cCA9ICgpID0+IGpvYi5jbG9zZSgpO1xuICAgIGNvbnN0IGNsZWFudXBPbkVycm9yID0gKGVycjogRXJyb3IpID0+IHtcbiAgICAgIGlmIChlcnIubmFtZSAhPT0gJ1BvbGxpbmdUaW1lb3V0Jykge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBiYXRjaC5vbigncmVzcG9uc2UnLCBjbGVhbnVwKTtcbiAgICBiYXRjaC5vbignZXJyb3InLCBjbGVhbnVwT25FcnJvcik7XG4gICAgYmF0Y2gub24oJ3F1ZXVlJywgKCkgPT4ge1xuICAgICAgYmF0Y2g/LnBvbGwodGhpcy5wb2xsSW50ZXJ2YWwsIHRoaXMucG9sbFRpbWVvdXQpO1xuICAgIH0pO1xuICAgIHJldHVybiBiYXRjaC5leGVjdXRlKGlucHV0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGJ1bGsgcXVlcnkgYW5kIGdldCByZWNvcmQgc3RyZWFtXG4gICAqL1xuICBxdWVyeShzb3FsOiBzdHJpbmcpIHtcbiAgICBjb25zdCBtID0gc29xbC5yZXBsYWNlKC9cXChbXFxzXFxTXStcXCkvZywgJycpLm1hdGNoKC9GUk9NXFxzKyhcXHcrKS9pKTtcbiAgICBpZiAoIW0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ05vIHNvYmplY3QgdHlwZSBmb3VuZCBpbiBxdWVyeSwgbWF5YmUgY2F1c2VkIGJ5IGludmFsaWQgU09RTC4nLFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IG1bMV07XG4gICAgY29uc3QgcmVjb3JkU3RyZWFtID0gbmV3IFBhcnNhYmxlKCk7XG4gICAgY29uc3QgZGF0YVN0cmVhbSA9IHJlY29yZFN0cmVhbS5zdHJlYW0oJ2NzdicpO1xuICAgIChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5sb2FkKHR5cGUsICdxdWVyeScsIHNvcWwpO1xuICAgICAgICBjb25zdCBzdHJlYW1zID0gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT5cbiAgICAgICAgICB0aGlzLmpvYihyZXN1bHQuam9iSWQpXG4gICAgICAgICAgICAuYmF0Y2gocmVzdWx0LmJhdGNoSWQpXG4gICAgICAgICAgICAucmVzdWx0KHJlc3VsdC5pZClcbiAgICAgICAgICAgIC5zdHJlYW0oKSxcbiAgICAgICAgKTtcbiAgICAgICAgam9pblN0cmVhbXMoc3RyZWFtcykucGlwZShkYXRhU3RyZWFtKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWNvcmRTdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgfVxuICAgIH0pKCk7XG4gICAgcmV0dXJuIHJlY29yZFN0cmVhbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgam9iIGluc3RhbmNlXG4gICAqL1xuICBjcmVhdGVKb2I8T3ByIGV4dGVuZHMgQnVsa09wZXJhdGlvbj4oXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIG9wZXJhdGlvbjogT3ByLFxuICAgIG9wdGlvbnM6IEJ1bGtPcHRpb25zID0ge30sXG4gICkge1xuICAgIHJldHVybiBuZXcgSm9iKHRoaXMsIHR5cGUsIG9wZXJhdGlvbiwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgam9iIGluc3RhbmNlIHNwZWNpZmllZCBieSBnaXZlbiBqb2IgSURcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGpvYklkIC0gSm9iIElEXG4gICAqIEByZXR1cm5zIHtCdWxrfkpvYn1cbiAgICovXG4gIGpvYjxPcHIgZXh0ZW5kcyBCdWxrT3BlcmF0aW9uPihqb2JJZDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBKb2I8UywgT3ByPih0aGlzLCBudWxsLCBudWxsLCBudWxsLCBqb2JJZCk7XG4gIH1cbn1cblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKlxuICogUmVnaXN0ZXIgaG9vayBpbiBjb25uZWN0aW9uIGluc3RhbnRpYXRpb24gZm9yIGR5bmFtaWNhbGx5IGFkZGluZyB0aGlzIEFQSSBtb2R1bGUgZmVhdHVyZXNcbiAqL1xucmVnaXN0ZXJNb2R1bGUoJ2J1bGsnLCAoY29ubikgPT4gbmV3IEJ1bGsoY29ubikpO1xuXG5leHBvcnQgZGVmYXVsdCBCdWxrO1xuIl19