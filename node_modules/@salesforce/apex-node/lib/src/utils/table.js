"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Table = void 0;
const COLUMN_SEPARATOR = '  ';
const COLUMN_FILLER = ' ';
const HEADER_FILLER = 'â”€';
class Table {
    createTable(rows, cols, title) {
        if (!rows) {
            throw Error('rows cannot be undefined');
        }
        if (!cols) {
            throw Error('columns cannot be undefined');
        }
        const maxColWidths = this.calculateMaxColumnWidths(rows, cols);
        let table = title ? `=== ${title}` : '';
        let columnHeader = '';
        let headerSeparator = '';
        cols.forEach((col, index, arr) => {
            const width = maxColWidths.get(col.key);
            if (width) {
                const isLastCol = index === arr.length - 1;
                columnHeader += this.fillColumn(col.label || col.key, width, COLUMN_FILLER, isLastCol);
                headerSeparator += this.fillColumn('', width, HEADER_FILLER, isLastCol);
            }
        });
        if (columnHeader && headerSeparator) {
            table += `${title ? '\n' : ''}${columnHeader}\n${headerSeparator}\n`;
        }
        rows.forEach(row => {
            let outputRow = '';
            cols.forEach((col, colIndex, colArr) => {
                const cell = row[col.key];
                const isLastCol = colIndex === colArr.length - 1;
                const rowWidth = outputRow.length;
                cell.split('\n').forEach((line, lineIndex) => {
                    const cellWidth = maxColWidths.get(col.key);
                    if (cellWidth) {
                        if (lineIndex === 0) {
                            outputRow += this.fillColumn(line, cellWidth, COLUMN_FILLER, isLastCol);
                        }
                        else {
                            // If the cell is multiline, add an additional line to the table
                            // and pad it to the beginning of the current column.
                            // Only add col separator padding once to additional line.
                            outputRow +=
                                '\n' +
                                    this.fillColumn('', rowWidth, COLUMN_FILLER, true) +
                                    this.fillColumn(line, cellWidth, COLUMN_FILLER, isLastCol);
                        }
                    }
                });
            });
            table += outputRow + '\n';
        });
        return table;
    }
    calculateMaxColumnWidths(rows, cols) {
        const maxColWidths = new Map();
        cols.forEach(col => {
            rows.forEach(row => {
                const cell = row[col.key];
                if (cell === undefined) {
                    throw Error(`Row is missing the key ${col.key}`);
                }
                let maxColWidth = maxColWidths.get(col.key);
                if (maxColWidth === undefined) {
                    maxColWidth = (col.label || col.key).length;
                    maxColWidths.set(col.key, maxColWidth);
                }
                // if a cell is multiline, find the line that's the longest
                const longestLineWidth = cell
                    .split('\n')
                    .reduce((maxLine, line) => line.length > maxLine.length ? line : maxLine).length;
                if (longestLineWidth > maxColWidth) {
                    maxColWidths.set(col.key, longestLineWidth);
                }
            });
        });
        return maxColWidths;
    }
    fillColumn(label, width, filler, isLastCol) {
        let filled = label;
        for (let i = 0; i < width - label.length; i++) {
            filled += filler;
        }
        if (!isLastCol) {
            filled += COLUMN_SEPARATOR;
        }
        return filled;
    }
}
exports.Table = Table;
//# sourceMappingURL=table.js.map