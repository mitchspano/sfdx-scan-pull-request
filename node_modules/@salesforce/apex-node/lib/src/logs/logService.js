"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogService = void 0;
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const constants_1 = require("./constants");
const path = require("path");
const i18n_1 = require("../i18n");
const utils_1 = require("../utils");
const traceFlags_1 = require("../utils/traceFlags");
class LogService {
    constructor(connection) {
        this.connection = connection;
    }
    getLogIds(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(typeof options.logId === 'string' ||
                typeof options.numberOfLogs === 'number')) {
                throw new Error(i18n_1.nls.localize('missingInfoLogError'));
            }
            if (typeof options.numberOfLogs === 'number') {
                const logIdRecordList = yield this.getLogRecords(options.numberOfLogs);
                return logIdRecordList.map(logRecord => logRecord.Id);
            }
            return [options.logId];
        });
    }
    // TODO: readableStream cannot be used until updates are made in jsforce and sfdx-core
    getLogs(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const logIdList = yield this.getLogIds(options);
            const logPaths = [];
            const connectionRequests = logIdList.map((id) => __awaiter(this, void 0, void 0, function* () {
                const url = `${this.connection.tooling._baseUrl()}/sobjects/ApexLog/${id}/Body`;
                const logRecord = yield this.toolingRequest(url);
                if (options.outputDir) {
                    const logPath = path.join(options.outputDir, `${id}.log`);
                    logPaths.push(logPath);
                    (0, utils_1.createFile)(logPath, logRecord);
                }
                return String(logRecord);
            }));
            const logs = yield Promise.all(connectionRequests);
            if (logPaths.length > 0) {
                const logMap = [];
                for (let i = 0; i < logs.length; i++) {
                    logMap.push({ log: logs[i], logPath: logPaths[i] });
                }
                return logMap;
            }
            return logs.map(log => {
                return { log };
            });
        });
    }
    getLogById(logId) {
        return __awaiter(this, void 0, void 0, function* () {
            const baseUrl = this.connection.tooling._baseUrl();
            const url = `${baseUrl}/sobjects/ApexLog/${logId}/Body`;
            const response = (yield this.connection.tooling.request(url));
            return { log: response.toString() || '' };
        });
    }
    getLogRecords(numberOfLogs) {
        return __awaiter(this, void 0, void 0, function* () {
            let apexLogQuery = `
        SELECT Id, Application, DurationMilliseconds, Location, LogLength, LogUser.Name,
          Operation, Request, StartTime, Status
        FROM ApexLog
        ORDER BY StartTime DESC
      `;
            if (typeof numberOfLogs === 'number') {
                if (numberOfLogs <= 0) {
                    throw new Error(i18n_1.nls.localize('numLogsError'));
                }
                numberOfLogs = Math.min(numberOfLogs, constants_1.MAX_NUM_LOGS);
                apexLogQuery += ` LIMIT ${numberOfLogs}`;
            }
            const response = (yield this.connection.tooling.query(apexLogQuery));
            return response.records;
        });
    }
    tail(org, tailer) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger = yield core_1.Logger.child('apexLogApi', { tag: 'tail' });
            this.logTailer = tailer;
            const stream = yield this.createStreamingClient(org);
            this.logger.debug(i18n_1.nls.localize('startHandshake'));
            yield stream.handshake();
            this.logger.debug(i18n_1.nls.localize('finishHandshake'));
            yield stream.subscribe(() => __awaiter(this, void 0, void 0, function* () {
                this.logger.debug(i18n_1.nls.localize('subscribeStarted'));
            }));
        });
    }
    createStreamingClient(org) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = new core_1.StreamingClient.DefaultOptions(org, constants_1.STREAMING_LOG_TOPIC, this.streamingCallback.bind(this));
            options.setSubscribeTimeout(kit_1.Duration.minutes(constants_1.LOG_TIMER_LENGTH_MINUTES));
            return yield core_1.StreamingClient.create(options);
        });
    }
    logCallback(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (message.sobject && message.sobject.Id) {
                const log = yield this.getLogById(message.sobject.Id);
                if (log && this.logTailer) {
                    this.logTailer(log.log);
                }
            }
        });
    }
    streamingCallback(message) {
        var _a;
        if (message.errorName === constants_1.LISTENER_ABORTED_ERROR_NAME) {
            return { completed: true };
        }
        if ((_a = message.sobject) === null || _a === void 0 ? void 0 : _a.Id) {
            this.logCallback(message);
        }
        return { completed: false };
    }
    prepareTraceFlag(requestedDebugLevel) {
        return __awaiter(this, void 0, void 0, function* () {
            const flags = new traceFlags_1.TraceFlags(this.connection);
            yield flags.ensureTraceFlags(requestedDebugLevel);
        });
    }
    toolingRequest(url) {
        return __awaiter(this, void 0, void 0, function* () {
            const log = (yield this.connection.tooling.request(url));
            return log;
        });
    }
}
exports.LogService = LogService;
//# sourceMappingURL=logService.js.map