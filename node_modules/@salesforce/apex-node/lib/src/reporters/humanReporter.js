"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HumanReporter = void 0;
const utils_1 = require("../utils");
const i18n_1 = require("../i18n");
class HumanReporter {
    format(testResult, detailedCoverage) {
        let tbResult = this.formatSummary(testResult);
        if (!testResult.codecoverage || !detailedCoverage) {
            tbResult += this.formatTestResults(testResult.tests);
        }
        if (testResult.codecoverage) {
            if (detailedCoverage) {
                tbResult += this.formatDetailedCov(testResult);
            }
            tbResult += this.formatCodeCov(testResult.codecoverage);
        }
        return tbResult;
    }
    formatSummary(testResult) {
        const tb = new utils_1.Table();
        // Summary Table
        const summaryRowArray = [
            {
                name: i18n_1.nls.localize('outcome'),
                value: testResult.summary.outcome
            },
            {
                name: i18n_1.nls.localize('testsRan'),
                value: String(testResult.summary.testsRan)
            },
            {
                name: i18n_1.nls.localize('passRate'),
                value: testResult.summary.passRate
            },
            {
                name: i18n_1.nls.localize('failRate'),
                value: testResult.summary.failRate
            },
            {
                name: i18n_1.nls.localize('skipRate'),
                value: testResult.summary.skipRate
            },
            {
                name: i18n_1.nls.localize('testRunId'),
                value: testResult.summary.testRunId
            },
            {
                name: i18n_1.nls.localize('testExecutionTime'),
                value: `${testResult.summary.testExecutionTimeInMs} ms`
            },
            {
                name: i18n_1.nls.localize('orgId'),
                value: testResult.summary.orgId
            },
            {
                name: i18n_1.nls.localize('username'),
                value: testResult.summary.username
            },
            ...(testResult.summary.orgWideCoverage
                ? [
                    {
                        name: i18n_1.nls.localize('orgWideCoverage'),
                        value: String(testResult.summary.orgWideCoverage)
                    }
                ]
                : [])
        ];
        const summaryTable = tb.createTable(summaryRowArray, [
            {
                key: 'name',
                label: i18n_1.nls.localize('nameColHeader')
            },
            { key: 'value', label: i18n_1.nls.localize('valueColHeader') }
        ], i18n_1.nls.localize('testSummaryHeader'));
        return summaryTable;
    }
    formatTestResults(tests) {
        const tb = new utils_1.Table();
        const testRowArray = [];
        tests.forEach((elem) => {
            const msg = elem.stackTrace
                ? `${elem.message}\n${elem.stackTrace}`
                : elem.message;
            testRowArray.push({
                name: elem.fullName,
                outcome: elem.outcome,
                msg: elem.message ? msg : '',
                runtime: elem.outcome !== "Fail" /* Fail */ ? `${elem.runTime}` : ''
            });
        });
        let testResultTable = '\n\n';
        testResultTable += tb.createTable(testRowArray, [
            {
                key: 'name',
                label: i18n_1.nls.localize('testNameColHeader')
            },
            { key: 'outcome', label: i18n_1.nls.localize('outcomeColHeader') },
            { key: 'msg', label: i18n_1.nls.localize('msgColHeader') },
            { key: 'runtime', label: i18n_1.nls.localize('runtimeColHeader') }
        ], i18n_1.nls.localize('testResultsHeader'));
        return testResultTable;
    }
    formatDetailedCov(testResult) {
        const tb = new utils_1.Table();
        const testRowArray = [];
        testResult.tests.forEach((elem) => {
            const msg = elem.stackTrace
                ? `${elem.message}\n${elem.stackTrace}`
                : elem.message;
            if (elem.perClassCoverage) {
                elem.perClassCoverage.forEach(perClassCov => {
                    testRowArray.push({
                        name: elem.fullName,
                        coveredClassName: perClassCov.apexClassOrTriggerName,
                        outcome: elem.outcome,
                        coveredClassPercentage: perClassCov.percentage,
                        msg: elem.message ? msg : '',
                        runtime: `${elem.runTime}`
                    });
                });
            }
            else {
                testRowArray.push({
                    name: elem.fullName,
                    coveredClassName: '',
                    outcome: elem.outcome,
                    coveredClassPercentage: '',
                    msg: elem.message ? msg : '',
                    runtime: `${elem.runTime}`
                });
            }
        });
        let detailedCovTable = '\n\n';
        detailedCovTable += tb.createTable(testRowArray, [
            {
                key: 'name',
                label: i18n_1.nls.localize('testNameColHeader')
            },
            {
                key: 'coveredClassName',
                label: i18n_1.nls.localize('classTestedHeader')
            },
            {
                key: 'outcome',
                label: i18n_1.nls.localize('outcomeColHeader')
            },
            {
                key: 'coveredClassPercentage',
                label: i18n_1.nls.localize('percentColHeader')
            },
            { key: 'msg', label: i18n_1.nls.localize('msgColHeader') },
            { key: 'runtime', label: i18n_1.nls.localize('runtimeColHeader') }
        ], i18n_1.nls.localize('detailedCodeCovHeader', [testResult.summary.testRunId]));
        return detailedCovTable;
    }
    formatCodeCov(codeCoverages) {
        const tb = new utils_1.Table();
        const codeCovRowArray = [];
        codeCoverages.forEach((elem) => {
            codeCovRowArray.push({
                name: elem.name,
                percent: elem.percentage,
                uncoveredLines: this.formatUncoveredLines(elem.uncoveredLines)
            });
        });
        let codeCovTable = '\n\n';
        codeCovTable += tb.createTable(codeCovRowArray, [
            {
                key: 'name',
                label: i18n_1.nls.localize('classesColHeader')
            },
            {
                key: 'percent',
                label: i18n_1.nls.localize('percentColHeader')
            },
            {
                key: 'uncoveredLines',
                label: i18n_1.nls.localize('uncoveredLinesColHeader')
            }
        ], i18n_1.nls.localize('codeCovHeader'));
        return codeCovTable;
    }
    formatUncoveredLines(uncoveredLines) {
        const arrayLimit = 5;
        if (uncoveredLines.length === 0) {
            return '';
        }
        const limit = uncoveredLines.length > arrayLimit ? arrayLimit : uncoveredLines.length;
        let processedLines = uncoveredLines.slice(0, limit).join(',');
        if (uncoveredLines.length > arrayLimit) {
            processedLines += '...';
        }
        return processedLines;
    }
}
exports.HumanReporter = HumanReporter;
//# sourceMappingURL=humanReporter.js.map