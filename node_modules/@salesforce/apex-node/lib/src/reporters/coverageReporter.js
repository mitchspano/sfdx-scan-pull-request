"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoverageReporter = exports.DefaultReportOptions = exports.DefaultWatermarks = void 0;
const libReport = require("istanbul-lib-report");
const reports = require("istanbul-reports");
const libCoverage = require("istanbul-lib-coverage");
const path = require("path");
const glob_1 = require("glob");
const fs = require("fs");
const i18n_1 = require("../i18n");
const startOfSource = (source) => {
    if (source) {
        return source.search(/\S/) || 0;
    }
    return 0;
};
const endOfSource = (source) => {
    if (source) {
        return source.search(/\S$/) || 0;
    }
    return 0;
};
exports.DefaultWatermarks = {
    statements: [50, 75],
    functions: [50, 75],
    branches: [50, 75],
    lines: [50, 75]
};
exports.DefaultReportOptions = {
    clover: { file: 'clover.xml', projectRoot: '.' },
    cobertura: { file: 'cobertura.xml', projectRoot: '.' },
    'html-spa': {
        verbose: false,
        skipEmpty: false,
        subdir: 'html-spa',
        linkMapper: undefined,
        metricsToShow: ['lines', 'statements', 'branches']
    },
    html: {
        verbose: false,
        skipEmpty: false,
        subdir: 'html',
        linkMapper: undefined
    },
    json: { file: 'coverage.json' },
    'json-summary': { file: 'coverage-summary.json' },
    lcovonly: { file: 'lcovonly.info', projectRoot: '.' },
    none: {},
    teamcity: { file: 'teamcity.txt', blockName: 'coverage' },
    text: { file: 'text.txt', maxCols: 160, skipEmpty: false, skipFull: false },
    'text-summary': { file: 'text-summary.txt' }
};
/**
 * Utility class to produce various well-known code coverage reports from Apex test coverage results.
 */
class CoverageReporter {
    /**
     *
     * @param coverage - instance of either a ApexCodeCoverageAggregate or ApexCodeCoverage object
     * @param reportDir - Directory to where the requested coverage reports will be written
     * @param sourceDir - Source directory for those Apex classes or triggers included in coverage data
     * @param options - CoverageReporterOptions
     */
    constructor(coverage, reportDir, sourceDir, options) {
        this.coverage = coverage;
        this.reportDir = reportDir;
        this.sourceDir = sourceDir;
        this.options = options;
    }
    generateReports() {
        var _a, _b;
        try {
            this.coverageMap = this.buildCoverageMap();
            fs.statSync(this.reportDir);
            const context = libReport.createContext({
                dir: this.reportDir,
                defaultSummarizer: 'nested',
                watermarks: ((_a = this.options) === null || _a === void 0 ? void 0 : _a.watermark) || exports.DefaultWatermarks,
                coverageMap: this.coverageMap
            });
            const formats = ((_b = this.options) === null || _b === void 0 ? void 0 : _b.reportFormats) || ['text-summary'];
            formats.forEach(format => {
                var _a;
                const report = reports.create(format, ((_a = this.options) === null || _a === void 0 ? void 0 : _a.reportOptions[format]) || exports.DefaultReportOptions[format]);
                report.execute(context);
            });
        }
        catch (e) {
            throw new Error(i18n_1.nls.localize('coverageReportCreationError', e.message));
        }
    }
    buildCoverageMap() {
        const pathsToFiles = this.findFullPathToClass(['cls', 'trigger']);
        const coverageMap = libCoverage.createCoverageMap();
        this.coverage.records.forEach((record) => {
            const fileCoverageData = {};
            const fileRegEx = new RegExp(`${record.ApexClassOrTrigger.Name}\.(cls|trigger)`);
            fileCoverageData.fnMap = {};
            fileCoverageData.branchMap = {};
            fileCoverageData.path = path.join(this.sourceDir, pathsToFiles.find(file => fileRegEx.test(file)) ||
                record.ApexClassOrTrigger.Name);
            fileCoverageData.f = {};
            fileCoverageData.b = {};
            fileCoverageData.s = [
                ...record.Coverage.coveredLines.map(line => [line, 1]),
                ...record.Coverage.uncoveredLines.map(line => [line, 0])
            ]
                .map(([line, covered]) => [Number(line).toString(10), covered])
                .reduce((acc, [line, value]) => {
                return Object.assign(acc, { [line]: value });
            }, {});
            let sourceLines = [];
            try {
                sourceLines = fs
                    .readFileSync(fileCoverageData.path, 'utf8')
                    .split('\n');
            }
            catch (_a) {
                // file not found
            }
            fileCoverageData.statementMap = [
                ...record.Coverage.coveredLines,
                ...record.Coverage.uncoveredLines
            ]
                .sort()
                .map(line => {
                const statement = {
                    start: {
                        line,
                        column: startOfSource(sourceLines[line - 1])
                    },
                    end: {
                        line,
                        column: endOfSource(sourceLines[line - 1])
                    }
                };
                return [Number(line).toString(10), statement];
            })
                .reduce((acc, [line, value]) => {
                return Object.assign(acc, { [Number(line).toString()]: value });
            }, {});
            coverageMap.addFileCoverage(fileCoverageData);
        });
        return coverageMap;
    }
    findFullPathToClass(listOfExtensions) {
        const searchPattern = `**/*.{${listOfExtensions.join(',')}}`;
        return glob_1.glob.sync(searchPattern, { cwd: this.sourceDir });
    }
}
exports.CoverageReporter = CoverageReporter;
//# sourceMappingURL=coverageReporter.js.map