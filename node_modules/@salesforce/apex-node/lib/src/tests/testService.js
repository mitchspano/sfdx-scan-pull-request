"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestService = void 0;
const types_1 = require("./types");
const path_1 = require("path");
const i18n_1 = require("../i18n");
const reporters_1 = require("../reporters");
const utils_1 = require("./utils");
const fileSystemHandler_1 = require("../utils/fileSystemHandler");
const asyncTests_1 = require("./asyncTests");
const syncTests_1 = require("./syncTests");
const diagnosticUtil_1 = require("./diagnosticUtil");
class TestService {
    constructor(connection) {
        this.connection = connection;
        this.syncService = new syncTests_1.SyncTests(connection);
        this.asyncService = new asyncTests_1.AsyncTests(connection);
    }
    /**
     * Retrieve all suites in org
     * @returns list of Suites in org
     */
    retrieveAllSuites() {
        return __awaiter(this, void 0, void 0, function* () {
            const testSuiteRecords = (yield this.connection.tooling.query(`SELECT id, TestSuiteName FROM ApexTestSuite`));
            return testSuiteRecords.records;
        });
    }
    retrieveSuiteId(suitename) {
        return __awaiter(this, void 0, void 0, function* () {
            const suiteResult = (yield this.connection.tooling.query(`SELECT id FROM ApexTestSuite WHERE TestSuiteName = '${suitename}'`));
            if (suiteResult.records.length === 0) {
                return undefined;
            }
            return suiteResult.records[0].Id;
        });
    }
    /**
     * Retrive the ids for the given suites
     * @param suitenames names of suites
     * @returns Ids associated with each suite
     */
    getOrCreateSuiteIds(suitenames) {
        return __awaiter(this, void 0, void 0, function* () {
            const suiteIds = suitenames.map((suite) => __awaiter(this, void 0, void 0, function* () {
                const suiteId = yield this.retrieveSuiteId(suite);
                if (suiteId === undefined) {
                    const result = (yield this.connection.tooling.create('ApexTestSuite', {
                        TestSuiteName: suite
                    }));
                    return result.id;
                }
                return suiteId;
            }));
            return yield Promise.all(suiteIds);
        });
    }
    /**
     * Retrieves the test classes in a given suite
     * @param suitename name of suite
     * @param suiteId id of suite
     * @returns list of test classes in the suite
     */
    getTestsInSuite(suitename, suiteId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (suitename === undefined && suiteId === undefined) {
                throw new Error(i18n_1.nls.localize('suitenameErr'));
            }
            if (suitename) {
                suiteId = yield this.retrieveSuiteId(suitename);
                if (suiteId === undefined) {
                    throw new Error(i18n_1.nls.localize('missingSuiteErr'));
                }
            }
            const classRecords = (yield this.connection.tooling.query(`SELECT ApexClassId FROM TestSuiteMembership WHERE ApexTestSuiteId = '${suiteId}'`));
            return classRecords.records;
        });
    }
    /**
     * Returns the associated Ids for each given Apex class
     * @param testClasses list of Apex class names
     * @returns the associated ids for each Apex class
     */
    getApexClassIds(testClasses) {
        return __awaiter(this, void 0, void 0, function* () {
            const classIds = testClasses.map((testClass) => __awaiter(this, void 0, void 0, function* () {
                const apexClass = (yield this.connection.tooling.query(`SELECT id, name FROM ApexClass WHERE Name = '${testClass}'`));
                if (apexClass.records.length === 0) {
                    throw new Error(i18n_1.nls.localize('missingTestClassErr', testClass));
                }
                return apexClass.records[0].Id;
            }));
            return yield Promise.all(classIds);
        });
    }
    /**
     * Builds a test suite with the given test classes. Creates the test suite if it doesn't exist already
     * @param suitename name of suite
     * @param tests tests to be added to suite
     */
    buildSuite(suitename, testClasses) {
        return __awaiter(this, void 0, void 0, function* () {
            const testSuiteId = (yield this.getOrCreateSuiteIds([suitename]))[0];
            const classesInSuite = yield this.getTestsInSuite(undefined, testSuiteId);
            const testClassIds = yield this.getApexClassIds(testClasses);
            yield Promise.all(testClassIds.map((classId) => __awaiter(this, void 0, void 0, function* () {
                const existingClass = classesInSuite.filter(rec => rec.ApexClassId === classId);
                const testClass = testClasses[testClassIds.indexOf(classId)];
                if (existingClass.length > 0) {
                    console.log(i18n_1.nls.localize('testSuiteMsg', [testClass, suitename]));
                }
                else {
                    yield this.connection.tooling.create('TestSuiteMembership', {
                        ApexClassId: classId,
                        ApexTestSuiteId: testSuiteId
                    });
                    console.log(i18n_1.nls.localize('classSuiteMsg', [testClass, suitename]));
                }
            })));
        });
    }
    /**
     * Synchronous Test Runs
     * @param options Synchronous Test Runs configuration
     * @param codeCoverage should report code coverage
     * @param token cancellation token
     */
    runTestSynchronous(options, codeCoverage = false, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.syncService.runTests(options, codeCoverage, token);
        });
    }
    /**
     * Asynchronous Test Runs
     * @param options test options
     * @param codeCoverage should report code coverage
     * @param immediatelyReturn should not wait for test run to complete, return test run id immediately
     * @param progress progress reporter
     * @param token cancellation token
     */
    runTestAsynchronous(options, codeCoverage = false, immediatelyReturn = false, progress, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncService.runTests(options, codeCoverage, immediatelyReturn, progress, token);
        });
    }
    /**
     * Report Asynchronous Test Run Results
     * @param testRunId test run id
     * @param codeCoverage should report code coverages
     * @param token cancellation token
     */
    reportAsyncResults(testRunId, codeCoverage = false, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.asyncService.reportAsyncResults(testRunId, codeCoverage, token);
        });
    }
    /**
     *
     * @param result test result
     * @param outputDirConfig config for result files
     * @param codeCoverage should report code coverage
     * @returns list of result files created
     */
    writeResultFiles(result, outputDirConfig, codeCoverage = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const { dirPath, resultFormats, fileInfos } = outputDirConfig;
            const fileMap = [];
            const testRunId = result.hasOwnProperty('summary')
                ? result.summary.testRunId
                : result.testRunId;
            fileMap.push({
                path: (0, path_1.join)(dirPath, 'test-run-id.txt'),
                content: testRunId
            });
            if (resultFormats) {
                if (!result.hasOwnProperty('summary')) {
                    throw new Error(i18n_1.nls.localize('runIdFormatErr'));
                }
                result = result;
                for (const format of resultFormats) {
                    if (!(format in types_1.ResultFormat)) {
                        throw new Error(i18n_1.nls.localize('resultFormatErr'));
                    }
                    switch (format) {
                        case types_1.ResultFormat.json:
                            fileMap.push({
                                path: (0, path_1.join)(dirPath, testRunId ? `test-result-${testRunId}.json` : `test-result.json`),
                                content: (0, utils_1.stringify)(result)
                            });
                            break;
                        case types_1.ResultFormat.tap:
                            const tapResult = new reporters_1.TapReporter().format(result);
                            fileMap.push({
                                path: (0, path_1.join)(dirPath, `test-result-${testRunId}-tap.txt`),
                                content: tapResult
                            });
                            break;
                        case types_1.ResultFormat.junit:
                            const junitResult = new reporters_1.JUnitReporter().format(result);
                            fileMap.push({
                                path: (0, path_1.join)(dirPath, testRunId
                                    ? `test-result-${testRunId}-junit.xml`
                                    : `test-result-junit.xml`),
                                content: junitResult
                            });
                            break;
                    }
                }
            }
            if (codeCoverage) {
                if (!result.hasOwnProperty('summary')) {
                    throw new Error(i18n_1.nls.localize('covIdFormatErr'));
                }
                result = result;
                const coverageRecords = result.tests.map(record => {
                    return record.perClassCoverage;
                });
                fileMap.push({
                    path: (0, path_1.join)(dirPath, `test-result-${testRunId}-codecoverage.json`),
                    content: (0, utils_1.stringify)(coverageRecords)
                });
            }
            fileInfos === null || fileInfos === void 0 ? void 0 : fileInfos.forEach(fileInfo => {
                fileMap.push({
                    path: (0, path_1.join)(dirPath, fileInfo.filename),
                    content: typeof fileInfo.content !== 'string'
                        ? (0, utils_1.stringify)(fileInfo.content)
                        : fileInfo.content
                });
            });
            (0, fileSystemHandler_1.createFiles)(fileMap);
            return fileMap.map(file => {
                return file.path;
            });
        });
    }
    // utils to build test run payloads that may contain namespaces
    buildSyncPayload(testLevel, tests, classnames) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (tests) {
                    const payload = yield this.buildTestPayload(tests);
                    const classes = (_a = payload.tests) === null || _a === void 0 ? void 0 : _a.map(testItem => {
                        if (testItem.className) {
                            return testItem.className;
                        }
                    });
                    if (new Set(classes).size !== 1) {
                        throw new Error(i18n_1.nls.localize('syncClassErr'));
                    }
                    return payload;
                }
                else if (classnames) {
                    const prop = (0, utils_1.isValidApexClassID)(classnames) ? 'classId' : 'className';
                    return {
                        tests: [{ [prop]: classnames }],
                        testLevel
                    };
                }
                throw new Error(i18n_1.nls.localize('payloadErr'));
            }
            catch (e) {
                throw (0, diagnosticUtil_1.formatTestErrors)(e);
            }
        });
    }
    buildAsyncPayload(testLevel, tests, classNames, suiteNames) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (tests) {
                    return (yield this.buildTestPayload(tests));
                }
                else if (classNames) {
                    return yield this.buildAsyncClassPayload(classNames);
                }
                else {
                    return {
                        suiteNames,
                        testLevel
                    };
                }
            }
            catch (e) {
                throw (0, diagnosticUtil_1.formatTestErrors)(e);
            }
        });
    }
    buildAsyncClassPayload(classNames) {
        return __awaiter(this, void 0, void 0, function* () {
            const classNameArray = classNames.split(',');
            const classItems = classNameArray.map(item => {
                const classParts = item.split('.');
                if (classParts.length > 1) {
                    return {
                        className: `${classParts[0]}.${classParts[1]}`
                    };
                }
                const prop = (0, utils_1.isValidApexClassID)(item) ? 'classId' : 'className';
                return { [prop]: item };
            });
            return { tests: classItems, testLevel: "RunSpecifiedTests" /* RunSpecifiedTests */ };
        });
    }
    buildTestPayload(testNames) {
        return __awaiter(this, void 0, void 0, function* () {
            const testNameArray = testNames.split(',');
            const testItems = [];
            let namespaceInfos;
            for (const test of testNameArray) {
                if (test.indexOf('.') > 0) {
                    const testParts = test.split('.');
                    if (testParts.length === 3) {
                        testItems.push({
                            namespace: `${testParts[0]}`,
                            className: `${testParts[1]}`,
                            testMethods: [testParts[2]]
                        });
                    }
                    else {
                        if (typeof namespaceInfos === 'undefined') {
                            namespaceInfos = yield (0, utils_1.queryNamespaces)(this.connection);
                        }
                        const currentNamespace = namespaceInfos.find(namespaceInfo => namespaceInfo.namespace === testParts[0]);
                        // NOTE: Installed packages require the namespace to be specified as part of the className field
                        // The namespace field should not be used with subscriber orgs
                        if (currentNamespace) {
                            if (currentNamespace.installedNs) {
                                testItems.push({
                                    className: `${testParts[0]}.${testParts[1]}`
                                });
                            }
                            else {
                                testItems.push({
                                    namespace: `${testParts[0]}`,
                                    className: `${testParts[1]}`
                                });
                            }
                        }
                        else {
                            testItems.push({
                                className: testParts[0],
                                testMethods: [testParts[1]]
                            });
                        }
                    }
                }
                else {
                    const prop = (0, utils_1.isValidApexClassID)(test) ? 'classId' : 'className';
                    testItems.push({ [prop]: test });
                }
            }
            return {
                tests: testItems,
                testLevel: "RunSpecifiedTests" /* RunSpecifiedTests */
            };
        });
    }
}
exports.TestService = TestService;
//# sourceMappingURL=testService.js.map