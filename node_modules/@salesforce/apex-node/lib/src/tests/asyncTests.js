"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncTests = void 0;
const i18n_1 = require("../i18n");
const streaming_1 = require("../streaming");
const utils_1 = require("../utils");
const diagnosticUtil_1 = require("./diagnosticUtil");
const utils_2 = require("./utils");
const util = require("util");
const constants_1 = require("./constants");
const codeCoverage_1 = require("./codeCoverage");
class AsyncTests {
    constructor(connection) {
        this.connection = connection;
        this.codecoverage = new codeCoverage_1.CodeCoverage(this.connection);
    }
    /**
     * Asynchronous Test Runs
     * @param options test options
     * @param codeCoverage should report code coverage
     * @param exitOnTestRunId should not wait for test run to complete, return test run id immediately
     * @param progress progress reporter
     * @param token cancellation token
     */
    runTests(options, codeCoverage = false, exitOnTestRunId = false, progress, token) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const sClient = new streaming_1.StreamingClient(this.connection, progress);
                yield sClient.init();
                yield sClient.handshake();
                token &&
                    token.onCancellationRequested(() => __awaiter(this, void 0, void 0, function* () {
                        const testRunId = yield sClient.subscribedTestRunIdPromise;
                        yield this.abortTestRun(testRunId, progress);
                        sClient.disconnect();
                    }));
                const testRunId = yield this.getTestRunRequestAction(options)();
                if (exitOnTestRunId) {
                    return { testRunId };
                }
                if (token && token.isCancellationRequested) {
                    return null;
                }
                const asyncRunResult = yield sClient.subscribe(undefined, testRunId);
                const testRunSummary = yield this.checkRunStatus(asyncRunResult.runId);
                return yield this.formatAsyncResults(asyncRunResult, (0, utils_1.getCurrentTime)(), codeCoverage, testRunSummary, progress);
            }
            catch (e) {
                throw (0, diagnosticUtil_1.formatTestErrors)(e);
            }
        });
    }
    /**
     * Report Asynchronous Test Run Results
     * @param testRunId test run id
     * @param codeCoverage should report code coverages
     * @param token cancellation token
     */
    reportAsyncResults(testRunId, codeCoverage = false, token) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const sClient = new streaming_1.StreamingClient(this.connection);
                yield sClient.init();
                yield sClient.handshake();
                let queueItem;
                let testRunSummary = yield this.checkRunStatus(testRunId);
                if (testRunSummary !== undefined) {
                    queueItem = yield sClient.handler(undefined, testRunId);
                }
                else {
                    queueItem = (yield sClient.subscribe(undefined, testRunId)).queueItem;
                    testRunSummary = yield this.checkRunStatus(testRunId);
                }
                token &&
                    token.onCancellationRequested(() => __awaiter(this, void 0, void 0, function* () {
                        sClient.disconnect();
                    }));
                if (token && token.isCancellationRequested) {
                    return null;
                }
                return yield this.formatAsyncResults({ queueItem, runId: testRunId }, (0, utils_1.getCurrentTime)(), codeCoverage, testRunSummary);
            }
            catch (e) {
                throw (0, diagnosticUtil_1.formatTestErrors)(e);
            }
        });
    }
    checkRunStatus(testRunId, progress) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, utils_2.isValidTestRunID)(testRunId)) {
                throw new Error(i18n_1.nls.localize('invalidTestRunIdErr', testRunId));
            }
            let testRunSummaryQuery = 'SELECT AsyncApexJobId, Status, ClassesCompleted, ClassesEnqueued, ';
            testRunSummaryQuery +=
                'MethodsEnqueued, StartTime, EndTime, TestTime, UserId ';
            testRunSummaryQuery += `FROM ApexTestRunResult WHERE AsyncApexJobId = '${testRunId}'`;
            progress === null || progress === void 0 ? void 0 : progress.report({
                type: 'FormatTestResultProgress',
                value: 'retrievingTestRunSummary',
                message: i18n_1.nls.localize('retrievingTestRunSummary')
            });
            const testRunSummaryResults = (yield this.connection.tooling.query(testRunSummaryQuery, {
                autoFetch: true
            }));
            if (testRunSummaryResults.records.length === 0) {
                throw new Error(i18n_1.nls.localize('noTestResultSummary', testRunId));
            }
            if (testRunSummaryResults.records[0].Status ===
                "Aborted" /* Aborted */ ||
                testRunSummaryResults.records[0].Status ===
                    "Failed" /* Failed */ ||
                testRunSummaryResults.records[0].Status ===
                    "Completed" /* Completed */ ||
                testRunSummaryResults.records[0].Status ===
                    "Passed" /* Passed */ ||
                testRunSummaryResults.records[0].Status ===
                    "Skipped" /* Skipped */) {
                return testRunSummaryResults.records[0];
            }
            return undefined;
        });
    }
    /**
     * Format the results of a completed asynchronous test run
     * @param asyncRunResult TestQueueItem and RunId for an async run
     * @param commandStartTime start time for the async test run
     * @param codeCoverage should report code coverages
     * @param testRunSummary test run summary
     * @param progress progress reporter
     * @returns
     */
    formatAsyncResults(asyncRunResult, commandStartTime, codeCoverage = false, testRunSummary, progress) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const coveredApexClassIdSet = new Set();
            const apexTestResults = yield this.getAsyncTestResults(asyncRunResult.queueItem);
            const { apexTestClassIdSet, testResults, globalTests } = yield this.buildAsyncTestResults(apexTestResults);
            let outcome = testRunSummary.Status;
            if (globalTests.failed > 0) {
                outcome = "Failed" /* Failed */;
            }
            else if (globalTests.passed === 0) {
                outcome = "Skipped" /* Skipped */;
            }
            else if (testRunSummary.Status === "Completed" /* Completed */) {
                outcome = "Passed" /* Passed */;
            }
            // TODO: deprecate testTotalTime
            const result = {
                summary: {
                    outcome,
                    testsRan: testResults.length,
                    passing: globalTests.passed,
                    failing: globalTests.failed,
                    skipped: globalTests.skipped,
                    passRate: (0, utils_2.calculatePercentage)(globalTests.passed, testResults.length),
                    failRate: (0, utils_2.calculatePercentage)(globalTests.failed, testResults.length),
                    skipRate: (0, utils_2.calculatePercentage)(globalTests.skipped, testResults.length),
                    testStartTime: (0, utils_1.formatStartTime)(testRunSummary.StartTime),
                    testExecutionTimeInMs: (_a = testRunSummary.TestTime) !== null && _a !== void 0 ? _a : 0,
                    testTotalTimeInMs: (_b = testRunSummary.TestTime) !== null && _b !== void 0 ? _b : 0,
                    commandTimeInMs: (0, utils_1.getCurrentTime)() - commandStartTime,
                    hostname: this.connection.instanceUrl,
                    orgId: this.connection.getAuthInfoFields().orgId,
                    username: this.connection.getUsername(),
                    testRunId: asyncRunResult.runId,
                    userId: testRunSummary.UserId
                },
                tests: testResults
            };
            if (codeCoverage) {
                const perClassCovMap = yield this.codecoverage.getPerClassCodeCoverage(apexTestClassIdSet);
                result.tests.forEach(item => {
                    const keyCodeCov = `${item.apexClass.id}-${item.methodName}`;
                    const perClassCov = perClassCovMap.get(keyCodeCov);
                    // Skipped test is not in coverage map, check to see if perClassCov exists first
                    if (perClassCov) {
                        perClassCov.forEach(classCov => coveredApexClassIdSet.add(classCov.apexClassOrTriggerId));
                        item.perClassCoverage = perClassCov;
                    }
                });
                progress === null || progress === void 0 ? void 0 : progress.report({
                    type: 'FormatTestResultProgress',
                    value: 'queryingForAggregateCodeCoverage',
                    message: i18n_1.nls.localize('queryingForAggregateCodeCoverage')
                });
                const { codeCoverageResults, totalLines, coveredLines } = yield this.codecoverage.getAggregateCodeCoverage(coveredApexClassIdSet);
                result.codecoverage = codeCoverageResults;
                result.summary.totalLines = totalLines;
                result.summary.coveredLines = coveredLines;
                result.summary.testRunCoverage = (0, utils_2.calculatePercentage)(coveredLines, totalLines);
                result.summary.orgWideCoverage = yield this.codecoverage.getOrgWideCoverage();
            }
            return result;
        });
    }
    getAsyncTestResults(testQueueResult) {
        return __awaiter(this, void 0, void 0, function* () {
            let apexTestResultQuery = 'SELECT Id, QueueItemId, StackTrace, Message, ';
            apexTestResultQuery +=
                'RunTime, TestTimestamp, AsyncApexJobId, MethodName, Outcome, ApexLogId, ';
            apexTestResultQuery +=
                'ApexClass.Id, ApexClass.Name, ApexClass.NamespacePrefix ';
            apexTestResultQuery += 'FROM ApexTestResult WHERE QueueItemId IN (%s)';
            const apexResultIds = testQueueResult.records.map(record => record.Id);
            // iterate thru ids, create query with id, & compare query length to char limit
            const queries = [];
            for (let i = 0; i < apexResultIds.length; i += constants_1.QUERY_RECORD_LIMIT) {
                const recordSet = apexResultIds
                    .slice(i, i + constants_1.QUERY_RECORD_LIMIT)
                    .map(id => `'${id}'`);
                const query = util.format(apexTestResultQuery, recordSet.join(','));
                queries.push(query);
            }
            const queryPromises = queries.map(query => {
                return this.connection.tooling.query(query, {
                    autoFetch: true
                });
            });
            const apexTestResults = yield Promise.all(queryPromises);
            return apexTestResults;
        });
    }
    buildAsyncTestResults(apexTestResults) {
        return __awaiter(this, void 0, void 0, function* () {
            const apexTestClassIdSet = new Set();
            let passed = 0;
            let failed = 0;
            let skipped = 0;
            // Iterate over test results, format and add them as results.tests
            const testResults = [];
            for (const result of apexTestResults) {
                result.records.forEach(item => {
                    var _a;
                    switch (item.Outcome) {
                        case "Pass" /* Pass */:
                            passed++;
                            break;
                        case "Fail" /* Fail */:
                        case "CompileFail" /* CompileFail */:
                            failed++;
                            break;
                        case "Skip" /* Skip */:
                            skipped++;
                            break;
                    }
                    apexTestClassIdSet.add(item.ApexClass.Id);
                    // Can only query the FullName field if a single record is returned, so manually build the field
                    item.ApexClass.FullName = item.ApexClass.NamespacePrefix
                        ? `${item.ApexClass.NamespacePrefix}__${item.ApexClass.Name}`
                        : item.ApexClass.Name;
                    const diagnostic = item.Message || item.StackTrace ? (0, diagnosticUtil_1.getAsyncDiagnostic)(item) : null;
                    testResults.push(Object.assign({ id: item.Id, queueItemId: item.QueueItemId, stackTrace: item.StackTrace, message: item.Message, asyncApexJobId: item.AsyncApexJobId, methodName: item.MethodName, outcome: item.Outcome, apexLogId: item.ApexLogId, apexClass: {
                            id: item.ApexClass.Id,
                            name: item.ApexClass.Name,
                            namespacePrefix: item.ApexClass.NamespacePrefix,
                            fullName: item.ApexClass.FullName
                        }, runTime: (_a = item.RunTime) !== null && _a !== void 0 ? _a : 0, testTimestamp: item.TestTimestamp, fullName: `${item.ApexClass.FullName}.${item.MethodName}` }, (diagnostic ? { diagnostic } : {})));
                });
            }
            return {
                apexTestClassIdSet,
                testResults,
                globalTests: { passed, failed, skipped }
            };
        });
    }
    /**
     * Abort test run with test run id
     * @param testRunId
     */
    abortTestRun(testRunId, progress) {
        return __awaiter(this, void 0, void 0, function* () {
            progress === null || progress === void 0 ? void 0 : progress.report({
                type: 'AbortTestRunProgress',
                value: 'abortingTestRun',
                message: i18n_1.nls.localize('abortingTestRun', testRunId),
                testRunId
            });
            const testQueueItems = yield this.connection.tooling.query(`SELECT Id, Status FROM ApexTestQueueItem WHERE ParentJobId = '${testRunId}'`);
            for (const record of testQueueItems.records) {
                record.Status = "Aborted" /* Aborted */;
            }
            yield this.connection.tooling.update('ApexTestQueueItem', testQueueItems.records);
            progress === null || progress === void 0 ? void 0 : progress.report({
                type: 'AbortTestRunProgress',
                value: 'abortingTestRunRequested',
                message: i18n_1.nls.localize('abortingTestRunRequested', testRunId),
                testRunId
            });
        });
    }
    getTestRunRequestAction(options) {
        const requestTestRun = () => __awaiter(this, void 0, void 0, function* () {
            const url = `${this.connection.tooling._baseUrl()}/runTestsAsynchronous`;
            const request = {
                method: 'POST',
                url,
                body: JSON.stringify(options),
                headers: { 'content-type': 'application/json' }
            };
            try {
                const testRunId = (yield this.connection.tooling.request(request));
                return Promise.resolve(testRunId);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
        return requestTestRun;
    }
}
exports.AsyncTests = AsyncTests;
//# sourceMappingURL=asyncTests.js.map