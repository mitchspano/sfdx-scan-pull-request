"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyncTests = void 0;
const utils_1 = require("../utils");
const codeCoverage_1 = require("./codeCoverage");
const diagnosticUtil_1 = require("./diagnosticUtil");
const utils_2 = require("./utils");
class SyncTests {
    constructor(connection) {
        this.connection = connection;
        this.codecoverage = new codeCoverage_1.CodeCoverage(this.connection);
    }
    /**
     * Synchronous Test Runs
     * @param options Synchronous Test Runs configuration
     * @param codeCoverage should report code coverage
     * @param token cancellation token
     */
    runTests(options, codeCoverage = false, token) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const url = `${this.connection.tooling._baseUrl()}/runTestsSynchronous`;
                const request = {
                    method: 'POST',
                    url,
                    body: JSON.stringify(options),
                    headers: { 'content-type': 'application/json' }
                };
                const testRun = (yield this.connection.tooling.request(request));
                if (token && token.isCancellationRequested) {
                    return null;
                }
                return yield this.formatSyncResults(testRun, (0, utils_1.getCurrentTime)(), codeCoverage);
            }
            catch (e) {
                throw (0, diagnosticUtil_1.formatTestErrors)(e);
            }
        });
    }
    formatSyncResults(apiTestResult, startTime, codeCoverage = false) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const coveredApexClassIdSet = new Set();
            const { apexTestClassIdSet, testResults } = this.buildSyncTestResults(apiTestResult);
            const globalTestFailed = apiTestResult.failures.length;
            const globalTestPassed = apiTestResult.successes.length;
            const result = {
                summary: {
                    outcome: globalTestFailed === 0
                        ? "Passed" /* Passed */
                        : "Failed" /* Failed */,
                    testsRan: apiTestResult.numTestsRun,
                    passing: globalTestPassed,
                    failing: globalTestFailed,
                    skipped: 0,
                    passRate: (0, utils_2.calculatePercentage)(globalTestPassed, apiTestResult.numTestsRun),
                    failRate: (0, utils_2.calculatePercentage)(globalTestFailed, apiTestResult.numTestsRun),
                    skipRate: (0, utils_2.calculatePercentage)(0, apiTestResult.numTestsRun),
                    testStartTime: (0, utils_1.formatStartTime)(startTime),
                    testExecutionTimeInMs: (_a = apiTestResult.totalTime) !== null && _a !== void 0 ? _a : 0,
                    testTotalTimeInMs: (_b = apiTestResult.totalTime) !== null && _b !== void 0 ? _b : 0,
                    commandTimeInMs: (0, utils_1.getCurrentTime)() - startTime,
                    hostname: this.connection.instanceUrl,
                    orgId: this.connection.getAuthInfoFields().orgId,
                    username: this.connection.getUsername(),
                    testRunId: '',
                    userId: this.connection.getConnectionOptions().userId
                },
                tests: testResults
            };
            if (codeCoverage) {
                const perClassCovMap = yield this.codecoverage.getPerClassCodeCoverage(apexTestClassIdSet);
                if (perClassCovMap.size > 0) {
                    result.tests.forEach(item => {
                        const keyCodeCov = `${item.apexClass.id}-${item.methodName}`;
                        const perClassCov = perClassCovMap.get(keyCodeCov);
                        if (perClassCov) {
                            perClassCov.forEach(classCov => coveredApexClassIdSet.add(classCov.apexClassOrTriggerId));
                            item.perClassCoverage = perClassCov;
                        }
                    });
                }
                const { codeCoverageResults, totalLines, coveredLines } = yield this.codecoverage.getAggregateCodeCoverage(coveredApexClassIdSet);
                result.codecoverage = codeCoverageResults;
                result.summary.totalLines = totalLines;
                result.summary.coveredLines = coveredLines;
                result.summary.testRunCoverage = (0, utils_2.calculatePercentage)(coveredLines, totalLines);
                result.summary.orgWideCoverage = yield this.codecoverage.getOrgWideCoverage();
            }
            return result;
        });
    }
    buildSyncTestResults(apiTestResult) {
        const testResults = [];
        const apexTestClassIdSet = new Set();
        apiTestResult.successes.forEach(item => {
            var _a;
            const nms = item.namespace ? `${item.namespace}__` : '';
            apexTestClassIdSet.add(item.id);
            testResults.push({
                id: '',
                queueItemId: '',
                stackTrace: '',
                message: '',
                asyncApexJobId: '',
                methodName: item.methodName,
                outcome: "Pass" /* Pass */,
                apexLogId: apiTestResult.apexLogId,
                apexClass: {
                    id: item.id,
                    name: item.name,
                    namespacePrefix: item.namespace,
                    fullName: `${nms}${item.name}`
                },
                runTime: (_a = item.time) !== null && _a !== void 0 ? _a : 0,
                testTimestamp: '',
                fullName: `${nms}${item.name}.${item.methodName}`
            });
        });
        apiTestResult.failures.forEach(item => {
            var _a;
            const nms = item.namespace ? `${item.namespace}__` : '';
            apexTestClassIdSet.add(item.id);
            const diagnostic = item.message || item.stackTrace ? (0, diagnosticUtil_1.getSyncDiagnostic)(item) : null;
            testResults.push(Object.assign({ id: '', queueItemId: '', stackTrace: item.stackTrace, message: item.message, asyncApexJobId: '', methodName: item.methodName, outcome: "Fail" /* Fail */, apexLogId: apiTestResult.apexLogId, apexClass: {
                    id: item.id,
                    name: item.name,
                    namespacePrefix: item.namespace,
                    fullName: `${nms}${item.name}`
                }, runTime: (_a = item.time) !== null && _a !== void 0 ? _a : 0, testTimestamp: '', fullName: `${nms}${item.name}.${item.methodName}` }, (diagnostic ? { diagnostic } : {})));
        });
        return { apexTestClassIdSet, testResults };
    }
}
exports.SyncTests = SyncTests;
//# sourceMappingURL=syncTests.js.map