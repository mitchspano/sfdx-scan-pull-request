"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeCoverage = void 0;
const util = require("util");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
class CodeCoverage {
    constructor(connection) {
        this.connection = connection;
    }
    /**
     * Returns the string representation of the org wide coverage percentage for a given username connection from OrgWideCoverage entity
     * @returns Org wide coverage percentage for a given username connection
     */
    getOrgWideCoverage() {
        return __awaiter(this, void 0, void 0, function* () {
            const orgWideCoverageResult = (yield this.connection.tooling.query('SELECT PercentCovered FROM ApexOrgWideCoverage'));
            if (orgWideCoverageResult.records.length === 0) {
                return '0%';
            }
            return `${orgWideCoverageResult.records[0].PercentCovered}%`;
        });
    }
    /**
     * Returns the code coverage information for each Apex class covered by each Apex test method from ApexCodeCoverage entity
     * @param apexTestClassSet Set of Apex test classes
     * @returns The code coverage information associated with each Apex test class
     * NOTE: a test could cover more than one class, result map should contain a record for each covered class
     */
    getPerClassCodeCoverage(apexTestClassSet) {
        return __awaiter(this, void 0, void 0, function* () {
            if (apexTestClassSet.size === 0) {
                return new Map();
            }
            const perClassCodeCovResults = yield this.queryPerClassCodeCov(apexTestClassSet);
            const perClassCoverageMap = new Map();
            perClassCodeCovResults.forEach(chunk => {
                chunk.records.forEach(item => {
                    const totalLines = item.NumLinesCovered + item.NumLinesUncovered;
                    const percentage = (0, utils_1.calculatePercentage)(item.NumLinesCovered, totalLines);
                    const value = Object.assign({ apexClassOrTriggerName: item.ApexClassOrTrigger.Name, apexClassOrTriggerId: item.ApexClassOrTrigger.Id, apexTestClassId: item.ApexTestClassId, apexTestMethodName: item.TestMethodName, numLinesCovered: item.NumLinesCovered, numLinesUncovered: item.NumLinesUncovered, percentage }, (item.Coverage ? { coverage: item.Coverage } : {}));
                    const key = `${item.ApexTestClassId}-${item.TestMethodName}`;
                    if (perClassCoverageMap.get(key)) {
                        perClassCoverageMap.get(key).push(value);
                    }
                    else {
                        perClassCoverageMap.set(`${item.ApexTestClassId}-${item.TestMethodName}`, [value]);
                    }
                });
            });
            return perClassCoverageMap;
        });
    }
    /**
     * Returns the aggregate code coverage information from ApexCodeCoverageAggregate entity for a given set of Apex classes
     * @param apexClassIdSet Set of ids for Apex classes
     * @returns The aggregate code coverage information for the given set of Apex classes
     */
    getAggregateCodeCoverage(apexClassIdSet) {
        return __awaiter(this, void 0, void 0, function* () {
            if (apexClassIdSet.size === 0) {
                return { codeCoverageResults: [], totalLines: 0, coveredLines: 0 };
            }
            const codeCoverageAggregates = yield this.queryAggregateCodeCov(apexClassIdSet);
            let totalLinesCovered = 0;
            let totalLinesUncovered = 0;
            const totalCodeCoverageResults = [];
            codeCoverageAggregates.forEach(chunk => {
                const codeCoverageResults = chunk.records.map(item => {
                    totalLinesCovered += item.NumLinesCovered;
                    totalLinesUncovered += item.NumLinesUncovered;
                    const totalLines = item.NumLinesCovered + item.NumLinesUncovered;
                    const percentage = (0, utils_1.calculatePercentage)(item.NumLinesCovered, totalLines);
                    return {
                        apexId: item.ApexClassOrTrigger.Id,
                        name: item.ApexClassOrTrigger.Name,
                        type: item.ApexClassOrTrigger.Id.startsWith('01p')
                            ? 'ApexClass'
                            : 'ApexTrigger',
                        numLinesCovered: item.NumLinesCovered,
                        numLinesUncovered: item.NumLinesUncovered,
                        percentage,
                        coveredLines: item.Coverage.coveredLines,
                        uncoveredLines: item.Coverage.uncoveredLines
                    };
                });
                totalCodeCoverageResults.push(...codeCoverageResults);
            });
            return {
                codeCoverageResults: totalCodeCoverageResults,
                totalLines: totalLinesCovered + totalLinesUncovered,
                coveredLines: totalLinesCovered
            };
        });
    }
    queryPerClassCodeCov(apexTestClassSet) {
        return __awaiter(this, void 0, void 0, function* () {
            const perClassCodeCovQuery = 'SELECT ApexTestClassId, ApexClassOrTrigger.Id, ApexClassOrTrigger.Name, TestMethodName, NumLinesCovered, NumLinesUncovered, Coverage FROM ApexCodeCoverage WHERE ApexTestClassId IN (%s)';
            return this.fetchResults(apexTestClassSet, perClassCodeCovQuery);
        });
    }
    queryAggregateCodeCov(apexClassIdSet) {
        return __awaiter(this, void 0, void 0, function* () {
            const codeCoverageQuery = 'SELECT ApexClassOrTrigger.Id, ApexClassOrTrigger.Name, NumLinesCovered, NumLinesUncovered, Coverage FROM ApexCodeCoverageAggregate WHERE ApexClassorTriggerId IN (%s)';
            return this.fetchResults(apexClassIdSet, codeCoverageQuery);
        });
    }
    fetchResults(idSet, selectQuery) {
        return __awaiter(this, void 0, void 0, function* () {
            const queries = this.createQueries(selectQuery, idSet);
            const queryPromises = queries.map(query => {
                // The query method returns a type QueryResult from jsforce
                // that has takes a type that extends the jsforce Record.
                // ApexCodeCoverageRecord and ApexCodeCoverageAggregateRecord
                // are the Records compatible types defined in this project.
                return this.connection.tooling.query(query, {
                    autoFetch: true
                });
            });
            // Note here the result of the .all call is of type QueryResult<ApexCodeCoverageAggregateRecord | ApexCodeCoverageRecord>[]
            // Since QueryResult is compatible with ApexCodeCoverage and ApexCodeCoverageAggregate we can cast to T[]
            // and things work out.
            //TODO: figure out how to use the provided types from core instead of having to work around typescript here.
            return (yield Promise.all(queryPromises));
        });
    }
    createQueries(selectQuery, idSet) {
        const idArray = [...idSet];
        const queries = [];
        for (let i = 0; i < idArray.length; i += constants_1.QUERY_RECORD_LIMIT) {
            const recordSet = idArray
                .slice(i, i + constants_1.QUERY_RECORD_LIMIT)
                .map(id => `'${id}'`);
            const query = util.format(selectQuery, recordSet.join(','));
            queries.push(query);
        }
        return queries;
    }
}
exports.CodeCoverage = CodeCoverage;
//# sourceMappingURL=codeCoverage.js.map