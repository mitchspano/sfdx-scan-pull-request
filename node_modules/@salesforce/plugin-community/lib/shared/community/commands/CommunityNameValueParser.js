"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommunityNameValueParser = void 0;
const lodash_1 = require("lodash");
const core_1 = require("@salesforce/core");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-community', 'create');
/**
 * A parser for the CommunityCreateCommand varargs.
 */
class CommunityNameValueParser {
    /**
     * The caller/creator of the parser needs to pass in some patterns to validate.
     *
     * These patterns are joined together in a RegExp and matched against the "name" portion of the vararg.
     *
     * e.g.
     * let parser = new CommunityNameValueParser([ "name", "template" ]);
     * parser.parse([ "name=Demo", "template=\"Customer Service\"" ]); // passes
     * parser.parse([ "name=Demo", "urlpathprefix=pathToDemo" ]); // fails
     * parser.parse([ "nameOne=Demo" ]); // fails
     * parser.parse([ "thename=Demo" ]); // fails
     * parser.parse([ "Name=Demo" ]); // fails
     *
     * The patterns are joined between a /^(...)$/ RegExp enclosure so it only accepts exact matches that are case sensitive. (See validate().)
     *
     * However, you can use regular expressions to allow for pattern matches.
     *
     * let parser = new CommunityNameValueParser([ "name", "template\\.\\w+" ]);
     * parser.parse([ "template.anything=substance" ]); // passes
     * parser.parse([ "name=Demo", "template=\"Customer Service\"" ]); // fails
     * parser.parse([ "name=Demo", "template.=templateOne" ]); // fails
     */
    constructor(patterns = ['.+']) {
        this.patterns = patterns;
    }
    parse(args) {
        const mappings = this.parseKeyValuePairs(args);
        this.validate(mappings);
        const values = this.buildJsonMapFromKeyValues(mappings);
        return values;
    }
    parseKeyValuePairs(args) {
        const keyValues = args.reduce(function (collection, terms) {
            const [key, value] = terms.split(/=(.*)/);
            collection.push([key, value]);
            return collection;
        }, []);
        return keyValues;
    }
    validate(parsedArgs) {
        const pattern = new RegExp('^(' + this.patterns.join('|') + ')$');
        const errors = parsedArgs
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            .filter(([key, value]) => !pattern.test(key))
            .map(([key, value]) => `${key}="${value}"`);
        if (!(0, lodash_1.isEmpty)(errors)) {
            throw messages.createError('error.invalidVarargs', errors);
        }
    }
    buildJsonMapFromKeyValues(keyValues) {
        let results = {};
        keyValues.forEach(([key, value]) => {
            results = this.setValue(key, value, results);
        });
        return results;
    }
    setValue(hyperKey, value, json = {}) {
        const keys = hyperKey.split('.');
        const lastKey = keys[keys.length - 1];
        const last = keys
            .slice(0, -1)
            .reduce((map, index) => (map[index] = map[index] === undefined ? {} : map[index]), json);
        last[lastKey] = value;
        return json;
    }
}
exports.CommunityNameValueParser = CommunityNameValueParser;
//# sourceMappingURL=CommunityNameValueParser.js.map