"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComponentSet = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
/* eslint  @typescript-eslint/unified-signatures:0 */
const fast_xml_parser_1 = require("fast-xml-parser");
const core_1 = require("@salesforce/core");
const client_1 = require("../client");
const common_1 = require("../common");
const resolve_1 = require("../resolve");
const registry_1 = require("../registry");
const types_1 = require("./types");
const lazyCollection_1 = require("./lazyCollection");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/source-deploy-retrieve', 'sdr', ['error_no_source_to_deploy']);
/**
 * A collection containing no duplicate metadata members (`fullName` and `type` pairs). `ComponentSets`
 * are a convenient way of constructing a unique collection of components to perform operations such as
 * deploying and retrieving.
 *
 * Multiple {@link SourceComponent}s can be present in the set and correspond to the same member.
 * This is typically the case when a component's source files are split across locations. For an example, see
 * the [multiple package directories](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_ws_mpd.htm)
 * scenario.
 */
class ComponentSet extends lazyCollection_1.LazyCollection {
    constructor(components = [], registry = new registry_1.RegistryAccess()) {
        super();
        this.components = new Map();
        // internal component maps used by this.getObject() when building manifests.
        this.destructiveComponents = {
            [types_1.DestructiveChangesType.PRE]: new Map(),
            [types_1.DestructiveChangesType.POST]: new Map(),
        };
        this.manifestComponents = new Map();
        this.destructiveChangesType = types_1.DestructiveChangesType.POST;
        this.registry = registry;
        this.logger = core_1.Logger.childFromRoot(this.constructor.name);
        for (const component of components) {
            const destructiveType = component instanceof resolve_1.SourceComponent ? component.getDestructiveChangesType() : this.destructiveChangesType;
            this.add(component, destructiveType);
        }
    }
    static fromSource(input) {
        let fsPaths = [];
        let registry;
        let tree;
        let inclusiveFilter;
        let fsDeletePaths = [];
        if (Array.isArray(input)) {
            fsPaths = input;
        }
        else if (typeof input === 'object') {
            fsPaths = input.fsPaths;
            registry = input.registry ?? registry;
            tree = input.tree ?? tree;
            inclusiveFilter = input.include;
            fsDeletePaths = input.fsDeletePaths ?? fsDeletePaths;
        }
        else {
            fsPaths = [input];
        }
        const resolver = new resolve_1.MetadataResolver(registry, tree);
        const set = new ComponentSet([], registry);
        const buildComponents = (paths, destructiveType) => {
            for (const path of paths) {
                for (const component of resolver.getComponentsFromPath(path, inclusiveFilter)) {
                    set.add(component, destructiveType);
                }
            }
        };
        buildComponents(fsPaths);
        buildComponents(fsDeletePaths, types_1.DestructiveChangesType.POST);
        set.forceIgnoredPaths = resolver.forceIgnoredPaths;
        return set;
    }
    static async fromManifest(input) {
        const manifestPath = typeof input === 'string' ? input : input.manifestPath;
        const options = (typeof input === 'object' ? input : {});
        const manifestResolver = new resolve_1.ManifestResolver(options.tree, options.registry);
        const manifest = await manifestResolver.resolve(manifestPath);
        const resolveIncludeSet = options.resolveSourcePaths ? new ComponentSet([], options.registry) : undefined;
        const result = new ComponentSet([], options.registry);
        result.apiVersion = manifest.apiVersion;
        result.fullName = manifest.fullName;
        const addComponent = (component, deletionType) => {
            if (resolveIncludeSet) {
                resolveIncludeSet.add(component, deletionType);
            }
            const memberIsWildcard = component.fullName === ComponentSet.WILDCARD;
            if (!memberIsWildcard || options.forceAddWildcards || !options.resolveSourcePaths) {
                result.add(component, deletionType);
            }
        };
        const resolveDestructiveChanges = async (path, destructiveChangeType) => {
            const destructiveManifest = await manifestResolver.resolve(path);
            for (const comp of destructiveManifest.components) {
                addComponent(new resolve_1.SourceComponent({ type: comp.type, name: comp.fullName }), destructiveChangeType);
            }
        };
        if (options.destructivePre) {
            await resolveDestructiveChanges(options.destructivePre, types_1.DestructiveChangesType.PRE);
        }
        if (options.destructivePost) {
            await resolveDestructiveChanges(options.destructivePost, types_1.DestructiveChangesType.POST);
        }
        for (const component of manifest.components) {
            addComponent(component);
        }
        if (options.resolveSourcePaths) {
            const components = ComponentSet.fromSource({
                fsPaths: options.resolveSourcePaths,
                tree: options.tree,
                include: resolveIncludeSet,
                registry: options.registry,
            });
            result.forceIgnoredPaths = components.forceIgnoredPaths;
            for (const component of components) {
                result.add(component);
            }
        }
        return result;
    }
    static async fromConnection(input) {
        let usernameOrConnection = typeof input === 'string' ? input : input.usernameOrConnection;
        const options = (typeof input === 'object' ? input : {});
        if (typeof usernameOrConnection === 'string') {
            usernameOrConnection = await core_1.Connection.create({
                authInfo: await core_1.AuthInfo.create({ username: usernameOrConnection }),
            });
            if (options.apiVersion && options.apiVersion !== usernameOrConnection.version) {
                usernameOrConnection.setApiVersion(options.apiVersion);
            }
        }
        const connectionResolver = new resolve_1.ConnectionResolver(usernameOrConnection, options.registry);
        const manifest = await connectionResolver.resolve(options.componentFilter);
        const result = new ComponentSet([], options.registry);
        result.apiVersion = manifest.apiVersion;
        for (const component of manifest.components) {
            result.add(component);
        }
        return result;
    }
    /**
     * Constructs a deploy operation using the components in the set and starts
     * the deployment. There must be at least one source-backed component in
     * the set to create an operation.
     *
     * @param options
     * @returns Metadata API deploy operation
     */
    async deploy(options) {
        const toDeploy = Array.from(this.getSourceComponents());
        if (toDeploy.length === 0) {
            throw new core_1.SfError(messages.getMessage('error_no_source_to_deploy'), 'ComponentSetError');
        }
        const operationOptions = Object.assign({}, options, {
            components: this,
            registry: this.registry,
            apiVersion: this.apiVersion,
        });
        // if (!options.apiVersion && !this.apiVersion && !this.sourceApiVersion) {
        //   operationOptions.apiVersion = `${await getCurrentApiVersion()}.0`;
        // }
        const mdapiDeploy = new client_1.MetadataApiDeploy(operationOptions);
        await mdapiDeploy.start();
        return mdapiDeploy;
    }
    /**
     * Constructs a retrieve operation using the components in the set and
     * starts the retrieval.
     *
     * @param options
     * @returns Metadata API retrieve operation
     */
    async retrieve(options) {
        const operationOptions = Object.assign({}, options, {
            components: this,
            registry: this.registry,
            apiVersion: this.apiVersion,
        });
        const mdapiRetrieve = new client_1.MetadataApiRetrieve(operationOptions);
        await mdapiRetrieve.start();
        return mdapiRetrieve;
    }
    /**
     * Get an object representation of a package manifest based on the set components.
     *
     * @param destructiveType Optional value for generating objects representing destructive change manifests
     * @returns Object representation of a package manifest
     */
    async getObject(destructiveType) {
        const version = this.sourceApiVersion ?? this.apiVersion ?? `${await (0, registry_1.getCurrentApiVersion)()}.0`;
        // If this ComponentSet has components marked for delete, we need to
        // only include those components in a destructiveChanges.xml and
        // all other components in the regular manifest.
        let components = this.components;
        if (this.getTypesOfDestructiveChanges().length) {
            components = destructiveType ? this.destructiveComponents[destructiveType] : this.manifestComponents;
        }
        const typeMap = new Map();
        const addToTypeMap = (type, fullName) => {
            if (type.isAddressable !== false) {
                const typeName = type.name;
                if (!typeMap.has(typeName)) {
                    typeMap.set(typeName, []);
                }
                const typeEntry = typeMap.get(typeName);
                if (fullName === ComponentSet.WILDCARD && !type.supportsWildcardAndName && !destructiveType) {
                    // if the type doesn't support mixed wildcards and specific names, overwrite the names to be a wildcard
                    typeMap.set(typeName, [fullName]);
                }
                else if (!typeEntry.includes(fullName) &&
                    (!typeEntry.includes(ComponentSet.WILDCARD) || type.supportsWildcardAndName)) {
                    // if the type supports both wildcards and names, add them regardless
                    typeMap.get(typeName).push(fullName);
                }
            }
        };
        for (const key of components.keys()) {
            const [typeId, fullName] = this.splitOnFirstDelimiter(key);
            let type = this.registry.getTypeByName(typeId);
            if (type.folderContentType) {
                type = this.registry.getTypeByName(type.folderContentType);
            }
            addToTypeMap(type, fullName);
            // Add children
            const componentMap = components.get(key);
            for (const comp of componentMap.values()) {
                for (const child of comp.getChildren()) {
                    addToTypeMap(child.type, child.fullName);
                }
            }
        }
        const typeMembers = [];
        for (const [typeName, members] of typeMap.entries()) {
            typeMembers.push({ members: members.sort(), name: typeName });
        }
        const pkg = {
            Package: {
                ...{
                    types: typeMembers.sort((a, b) => (a.name > b.name ? 1 : -1)),
                    version,
                },
                ...(this.fullName ? { fullName: this.fullName } : {}),
            },
        };
        return pkg;
    }
    /**
     * Create a manifest in xml format based on the set components and the
     * type of manifest to create.
     *
     * E.g. package.xml or destructiveChanges.xml
     *
     * @param indentation Number of spaces to indent lines by.
     * @param forDestructiveChanges Whether to build a manifest for destructive changes.
     */
    async getPackageXml(indentation = 4, destructiveType) {
        const j2x = new fast_xml_parser_1.j2xParser({
            format: true,
            indentBy: new Array(indentation + 1).join(' '),
            ignoreAttributes: false,
        });
        const toParse = await this.getObject(destructiveType);
        toParse.Package[common_1.XML_NS_KEY] = common_1.XML_NS_URL;
        return common_1.XML_DECL.concat(j2x.parse(toParse));
    }
    /**
     * Get only the source-backed metadata components in the set.
     *
     * @param member Member to retrieve source-backed components for.
     * @returns Collection of source-backed components
     */
    getSourceComponents(member) {
        let iter;
        if (member) {
            // filter optimization
            const memberCollection = this.components.get(this.simpleKey(member));
            iter = memberCollection?.size > 0 ? memberCollection.values() : [];
        }
        else {
            iter = this;
        }
        return new lazyCollection_1.LazyCollection(iter).filter((c) => c instanceof resolve_1.SourceComponent);
    }
    add(component, deletionType) {
        const key = this.simpleKey(component);
        if (!this.components.has(key)) {
            this.components.set(key, new Map());
        }
        if (!(component instanceof resolve_1.SourceComponent)) {
            return;
        }
        // we're working with SourceComponents now
        this.components.get(key).set(this.sourceKey(component), component);
        // Build maps of destructive components and regular components as they are added
        // as an optimization when building manifests.
        if (deletionType) {
            component.setMarkedForDelete(deletionType);
            this.logger.debug(`Marking component for delete: ${component.fullName}`);
            const deletions = this.destructiveComponents[deletionType];
            if (!deletions.has(key)) {
                deletions.set(key, new Map());
            }
            deletions.get(key).set(this.sourceKey(component), component);
        }
        else {
            if (!this.manifestComponents.has(key)) {
                this.manifestComponents.set(key, new Map());
            }
            this.manifestComponents.get(key).set(this.sourceKey(component), component);
        }
        // something could try adding a component meant for deletion improperly, which would be marked as an addition
        // specifically the ComponentSet.fromManifest with the `resolveSourcePaths` options which calls
        // ComponentSet.fromSource, and adds everything as an addition
        if (this.manifestComponents.has(key) &&
            (this.destructiveChangesPre.has(key) || this.destructiveChangesPost.has(key))) {
            // if a component is in the manifestComponents, as well as being part of a destructive manifest, keep in the destructive manifest
            component.setMarkedForDelete(deletionType);
            this.manifestComponents.delete(key);
            this.logger.debug(`Component: ${key} was found in both destructive and constructive manifests - keeping as a destructive change`);
        }
    }
    /**
     * Tests whether or not a `fullName` and `type` pair is present in the set.
     *
     * A pair is considered present in the set if one of the following criteria is met:
     *
     * - The pair is directly in the set
     * - A wildcard component with the same `type` as the pair
     * - If a parent is attached to the pair and the parent is directly in the set
     * - If a parent is attached to the pair, and a wildcard component's `type` matches the parent's `type`
     *
     * @param component Component to test for membership in the set
     * @returns `true` if the component is in the set
     */
    has(component) {
        const isDirectlyInSet = this.components.has(this.simpleKey(component));
        if (isDirectlyInSet) {
            return true;
        }
        const wildcardMember = {
            fullName: ComponentSet.WILDCARD,
            type: typeof component.type === 'object' ? component.type.name : component.type,
        };
        const isIncludedInWildcard = this.components.has(this.simpleKey(wildcardMember));
        if (isIncludedInWildcard) {
            return true;
        }
        if (typeof component.type === 'object') {
            const { parent } = component;
            if (parent) {
                const parentDirectlyInSet = this.components.has(this.simpleKey(parent));
                if (parentDirectlyInSet) {
                    return true;
                }
                const wildcardKey = this.simpleKey({
                    fullName: ComponentSet.WILDCARD,
                    type: parent.type,
                });
                const parentInWildcard = this.components.has(wildcardKey);
                if (parentInWildcard) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * For a fullName and type, this returns the filenames the matching component, or an empty array if the component is not present
     *
     * @param param Object with fullName and type properties
     * @returns string[]
     */
    getComponentFilenamesByNameAndType({ fullName, type }) {
        const key = this.simpleKey({ fullName, type });
        const componentMap = this.components.get(key);
        if (!componentMap) {
            return [];
        }
        const output = new Set();
        componentMap.forEach((component) => {
            [...component.walkContent(), component.content, component.xml]
                .filter(Boolean)
                .map((filename) => output.add(filename));
        });
        return Array.from(output);
    }
    *[Symbol.iterator]() {
        for (const [key, sourceComponents] of this.components.entries()) {
            if (sourceComponents.size === 0) {
                const [typeName, fullName] = this.splitOnFirstDelimiter(key);
                yield {
                    fullName,
                    type: this.registry.getTypeByName(typeName),
                };
            }
            else {
                for (const component of sourceComponents.values()) {
                    yield component;
                }
            }
        }
    }
    /**
     * If this `ComponentSet` has components marked for delete, this sets
     * whether those components are deleted before any other changes are
     * deployed (`destructiveChangesPre.xml`) or after changes are deployed
     * (`destructiveChangesPost.xml`).
     *
     * @param type The type of destructive changes to make; i.e., pre or post deploy.
     */
    setDestructiveChangesType(type) {
        this.destructiveChangesType = type;
    }
    /**
     * If this `ComponentSet` has components marked for delete it will use this
     * type to build the appropriate destructive changes manifest.
     *
     * @returns The type of destructive changes to make; i.e., pre or post deploy.
     */
    getDestructiveChangesType() {
        return this.destructiveChangesType;
    }
    /**
     * Will return the types of destructive changes in the component set
     * or an empty array if there aren't destructive components present
     *
     * @return DestructiveChangesType[]
     */
    getTypesOfDestructiveChanges() {
        const destructiveChangesTypes = [];
        if (this.destructiveChangesPre.size) {
            destructiveChangesTypes.push(types_1.DestructiveChangesType.PRE);
        }
        if (this.destructiveChangesPost.size) {
            destructiveChangesTypes.push(types_1.DestructiveChangesType.POST);
        }
        return destructiveChangesTypes;
    }
    /**
     * Each {@link SourceComponent} counts as an element in the set, even if multiple
     * ones map to the same `fullName` and `type` pair.
     *
     * @returns number of metadata components in the set
     */
    get size() {
        let size = 0;
        for (const collection of this.components.values()) {
            // just having an entry in the parent map counts as 1
            size += collection.size === 0 ? 1 : collection.size;
        }
        return size;
    }
    get destructiveChangesPre() {
        return this.destructiveComponents[types_1.DestructiveChangesType.PRE];
    }
    get destructiveChangesPost() {
        return this.destructiveComponents[types_1.DestructiveChangesType.POST];
    }
    sourceKey(component) {
        const { fullName, type, xml, content } = component;
        return `${type.name}${fullName}${xml ?? ''}${content ?? ''}`;
    }
    simpleKey(component) {
        const typeName = typeof component.type === 'string' ? component.type.toLowerCase().trim() : component.type.id;
        return `${typeName}${ComponentSet.KEY_DELIMITER}${component.fullName}`;
    }
    splitOnFirstDelimiter(input) {
        const indexOfSplitChar = input.indexOf(ComponentSet.KEY_DELIMITER);
        return [input.substring(0, indexOfSplitChar), input.substring(indexOfSplitChar + 1)];
    }
}
exports.ComponentSet = ComponentSet;
ComponentSet.WILDCARD = '*';
ComponentSet.KEY_DELIMITER = '#';
//# sourceMappingURL=componentSet.js.map