"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComponentSetBuilder = void 0;
/* eslint complexity: ["error", 22] */
const path = require("path");
const core_1 = require("@salesforce/core");
const fs = require("graceful-fs");
const collections_1 = require("../collections");
const registry_1 = require("../registry");
class ComponentSetBuilder {
    /**
     * Builds a ComponentSet that can be used for source conversion,
     * deployment, or retrieval, using all specified options.
     *
     * @see https://github.com/forcedotcom/source-deploy-retrieve/blob/develop/src/collections/componentSet.ts
     *
     * @param options: options for creating a ComponentSet
     */
    static async build(options) {
        const logger = core_1.Logger.childFromRoot('componentSetBuilder');
        let componentSet;
        const { sourcepath, manifest, metadata, packagenames, apiversion, sourceapiversion, org } = options;
        try {
            if (sourcepath) {
                logger.debug(`Building ComponentSet from sourcepath: ${sourcepath.join(', ')}`);
                const fsPaths = sourcepath.map((filepath) => {
                    if (!fs.existsSync(filepath)) {
                        throw new core_1.SfError(`The sourcepath "${filepath}" is not a valid source file path.`);
                    }
                    return path.resolve(filepath);
                });
                componentSet = collections_1.ComponentSet.fromSource({ fsPaths });
            }
            // Return empty ComponentSet and use packageNames in the connection via `.retrieve` options
            if (packagenames) {
                logger.debug(`Building ComponentSet for packagenames: ${packagenames.toString()}`);
                componentSet ?? (componentSet = new collections_1.ComponentSet());
            }
            // Resolve manifest with source in package directories.
            if (manifest) {
                logger.debug(`Building ComponentSet from manifest: ${manifest.manifestPath}`);
                const directoryPaths = options.manifest.directoryPaths;
                logger.debug(`Searching in packageDir: ${directoryPaths.join(', ')} for matching metadata`);
                componentSet = await collections_1.ComponentSet.fromManifest({
                    manifestPath: manifest.manifestPath,
                    resolveSourcePaths: directoryPaths,
                    forceAddWildcards: true,
                    destructivePre: options.manifest.destructiveChangesPre,
                    destructivePost: options.manifest.destructiveChangesPost,
                });
            }
            // Resolve metadata entries with source in package directories.
            if (metadata) {
                logger.debug(`Building ComponentSet from metadata: ${metadata.metadataEntries.toString()}`);
                const registry = new registry_1.RegistryAccess();
                const compSetFilter = new collections_1.ComponentSet();
                componentSet ?? (componentSet = new collections_1.ComponentSet());
                // Build a Set of metadata entries
                metadata.metadataEntries.forEach((rawEntry) => {
                    const splitEntry = rawEntry.split(':').map((entry) => entry.trim());
                    // The registry will throw if it doesn't know what this type is.
                    registry.getTypeByName(splitEntry[0]);
                    const entry = {
                        type: splitEntry[0],
                        fullName: splitEntry.length === 1 ? '*' : splitEntry[1],
                    };
                    // Add to the filtered ComponentSet for resolved source paths,
                    // and the unfiltered ComponentSet to build the correct manifest.
                    compSetFilter.add(entry);
                    componentSet.add(entry);
                });
                const directoryPaths = options.metadata.directoryPaths;
                logger.debug(`Searching for matching metadata in directories: ${directoryPaths.join(', ')}`);
                const resolvedComponents = collections_1.ComponentSet.fromSource({ fsPaths: directoryPaths, include: compSetFilter });
                componentSet.forceIgnoredPaths = resolvedComponents.forceIgnoredPaths;
                for (const comp of resolvedComponents) {
                    componentSet.add(comp);
                }
            }
            // Resolve metadata entries with an org connection
            if (org) {
                componentSet ?? (componentSet = new collections_1.ComponentSet());
                logger.debug(`Building ComponentSet from targetUsername: ${org.username}`);
                const fromConnection = await collections_1.ComponentSet.fromConnection({
                    usernameOrConnection: (await core_1.StateAggregator.getInstance()).aliases.getUsername(org.username) || org.username,
                    // exclude components based on the results of componentFilter function
                    // components with namespacePrefix where org.exclude includes manageableState (to exclude managed packages)
                    // components with namespacePrefix where manageableState equals undefined (to exclude components e.g. InstalledPackage)
                    // components where org.exclude includes manageableState (to exclude packages without namespacePrefix e.g. unlocked packages)
                    componentFilter: (component) => !(org.exclude && org.exclude.includes(component?.manageableState)),
                });
                for (const comp of fromConnection) {
                    componentSet.add(comp);
                }
            }
        }
        catch (e) {
            if (e.message.includes('Missing metadata type definition in registry for id')) {
                // to remain generic to catch missing metadata types regardless of parameters, split on '
                // example message : Missing metadata type definition in registry for id 'NonExistentType'
                const issueType = e.message.split("'")[1];
                throw new core_1.SfError(`The specified metadata type is unsupported: [${issueType}]`);
            }
            else {
                throw e;
            }
        }
        // This is only for debug output of matched files based on the command flags.
        // It will log up to 20 file matches.
        if (logger.debugEnabled && componentSet.size) {
            logger.debug(`Matching metadata files (${componentSet.size}):`);
            const components = componentSet.getSourceComponents().toArray();
            for (let i = 0; i < componentSet.size; i++) {
                if (components[i]?.content) {
                    logger.debug(components[i].content);
                }
                else if (components[i]?.xml) {
                    logger.debug(components[i].xml);
                }
                if (i > 18) {
                    logger.debug(`(showing 20 of ${componentSet.size} matches)`);
                    break;
                }
            }
        }
        if (apiversion) {
            componentSet.apiVersion = apiversion;
        }
        if (sourceapiversion) {
            componentSet.sourceApiVersion = sourceapiversion;
        }
        return componentSet;
    }
}
exports.ComponentSetBuilder = ComponentSetBuilder;
//# sourceMappingURL=componentSetBuilder.js.map