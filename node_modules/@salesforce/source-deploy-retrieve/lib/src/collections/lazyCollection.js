"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LazyCollection = void 0;
class LazyCollection {
    constructor(iterable) {
        this.iterable = iterable;
    }
    first() {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return this.getIterator().next().value;
    }
    find(predicate) {
        const iter = this.getIterator();
        let next = iter.next();
        while (!next.done) {
            if (predicate(next.value)) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return next.value;
            }
            next = iter.next();
        }
    }
    filter(predicate) {
        const iter = this.getIterator();
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore: valid syntax - invokes the constructor of the instance's type
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return new this.constructor((function* () {
            let next = iter.next();
            while (!next.done) {
                if (predicate(next.value)) {
                    yield next.value;
                }
                next = iter.next();
            }
        })());
    }
    map(mapper) {
        const iter = this.getIterator();
        return new LazyCollection((function* () {
            let next = iter.next();
            while (!next.done) {
                yield mapper(next.value);
                next = iter.next();
            }
        })());
    }
    toArray() {
        const result = [];
        const iter = this.getIterator();
        let next = iter.next();
        while (!next.done) {
            result.push(next.value);
            next = iter.next();
        }
        return result;
    }
    /**
     * USE getIterator() IN METHOD IMPLEMENTATIONS
     *
     * This is to support for..of syntax on non-subclass instances of
     * LazyCollection. getIterator() ensures we use [Symbol.iterator] of the
     * subclass if `iterable` is not set.
     */
    [Symbol.iterator]() {
        return this.iterable ? this.iterable[Symbol.iterator]() : [][Symbol.iterator]();
    }
    getIterator() {
        return this.iterable ? this.iterable[Symbol.iterator]() : this[Symbol.iterator]();
    }
}
exports.LazyCollection = LazyCollection;
//# sourceMappingURL=lazyCollection.js.map