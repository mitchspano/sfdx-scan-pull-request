import { MetadataApiDeploy, MetadataApiDeployOptions, MetadataApiRetrieve, MetadataApiRetrieveOptions } from '../client';
import { ComponentLike, MetadataComponent, MetadataMember, SourceComponent } from '../resolve';
import { RegistryAccess } from '../registry';
import { DestructiveChangesType, FromManifestOptions, FromSourceOptions, FromConnectionOptions, PackageManifestObject } from './types';
import { LazyCollection } from './lazyCollection';
export declare type DeploySetOptions = Omit<MetadataApiDeployOptions, 'components'>;
export declare type RetrieveSetOptions = Omit<MetadataApiRetrieveOptions, 'components'>;
/**
 * A collection containing no duplicate metadata members (`fullName` and `type` pairs). `ComponentSets`
 * are a convenient way of constructing a unique collection of components to perform operations such as
 * deploying and retrieving.
 *
 * Multiple {@link SourceComponent}s can be present in the set and correspond to the same member.
 * This is typically the case when a component's source files are split across locations. For an example, see
 * the [multiple package directories](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_ws_mpd.htm)
 * scenario.
 */
export declare class ComponentSet extends LazyCollection<MetadataComponent> {
    static readonly WILDCARD = "*";
    private static readonly KEY_DELIMITER;
    /**
     * The metadata API version to use. E.g., 52.0
     */
    apiVersion: string;
    /**
     * The metadata API version of the deployed/retrieved source.
     * This is used as the value for the `version` field in the manifest.
     */
    sourceApiVersion: string;
    fullName?: string;
    forceIgnoredPaths?: Set<string>;
    private logger;
    private registry;
    private components;
    private destructiveComponents;
    private manifestComponents;
    private destructiveChangesType;
    constructor(components?: Iterable<ComponentLike>, registry?: RegistryAccess);
    /**
     * Resolve metadata components from a file or directory path in a file system.
     *
     * @param fsPath File or directory path to resolve against
     * @returns ComponentSet of source resolved components
     */
    static fromSource(fsPath: string): ComponentSet;
    /**
     * Resolve metadata components from multiple file paths or directory paths in a file system.
     *
     * @param fsPaths File or directory paths to resolve against
     * @returns ComponentSet of source resolved components
     */
    static fromSource(fsPaths: string[]): ComponentSet;
    /**
     * Resolve metadata components from file or directory paths in a file system.
     * Customize the resolution process using an options object, such as specifying filters
     * and resolving against a different file system abstraction (see {@link TreeContainer}).
     *
     * @param options
     * @returns ComponentSet of source resolved components
     */
    static fromSource(options: FromSourceOptions): ComponentSet;
    /**
     * Resolve components from a manifest file in XML format.
     *
     * see [Sample package.xml Manifest Files](https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/manifest_samples.htm)
     *
     * @param manifestPath Path to XML file
     * @returns Promise of a ComponentSet containing manifest components
     */
    static fromManifest(manifestPath: string): Promise<ComponentSet>;
    /**
     * Resolve components from a manifest file in XML format.
     * Customize the resolution process using an options object. For example, resolve source-backed components
     * while using the manifest file as a filter.
     * process using an options object, such as resolving source-backed components
     * and using the manifest file as a filter.
     *
     * see [Sample package.xml Manifest Files](https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/manifest_samples.htm)
     *
     * @param options
     * @returns Promise of a ComponentSet containing manifest components
     */
    static fromManifest(options: FromManifestOptions): Promise<ComponentSet>;
    /**
     * Resolve components from an org connection.
     *
     * @param username org connection username
     * @returns ComponentSet of source resolved components
     */
    static fromConnection(username: string): Promise<ComponentSet>;
    /**
     * Resolve components from an org connection.
     *
     * @param options
     * @returns ComponentSet of source resolved components
     */
    static fromConnection(options: FromConnectionOptions): Promise<ComponentSet>;
    /**
     * Constructs a deploy operation using the components in the set and starts
     * the deployment. There must be at least one source-backed component in
     * the set to create an operation.
     *
     * @param options
     * @returns Metadata API deploy operation
     */
    deploy(options: DeploySetOptions): Promise<MetadataApiDeploy>;
    /**
     * Constructs a retrieve operation using the components in the set and
     * starts the retrieval.
     *
     * @param options
     * @returns Metadata API retrieve operation
     */
    retrieve(options: RetrieveSetOptions): Promise<MetadataApiRetrieve>;
    /**
     * Get an object representation of a package manifest based on the set components.
     *
     * @param destructiveType Optional value for generating objects representing destructive change manifests
     * @returns Object representation of a package manifest
     */
    getObject(destructiveType?: DestructiveChangesType): Promise<PackageManifestObject>;
    /**
     * Create a manifest in xml format based on the set components and the
     * type of manifest to create.
     *
     * E.g. package.xml or destructiveChanges.xml
     *
     * @param indentation Number of spaces to indent lines by.
     * @param forDestructiveChanges Whether to build a manifest for destructive changes.
     */
    getPackageXml(indentation?: number, destructiveType?: DestructiveChangesType): Promise<string>;
    /**
     * Get only the source-backed metadata components in the set.
     *
     * @param member Member to retrieve source-backed components for.
     * @returns Collection of source-backed components
     */
    getSourceComponents(member?: ComponentLike): LazyCollection<SourceComponent>;
    add(component: ComponentLike, deletionType?: DestructiveChangesType): void;
    /**
     * Tests whether or not a `fullName` and `type` pair is present in the set.
     *
     * A pair is considered present in the set if one of the following criteria is met:
     *
     * - The pair is directly in the set
     * - A wildcard component with the same `type` as the pair
     * - If a parent is attached to the pair and the parent is directly in the set
     * - If a parent is attached to the pair, and a wildcard component's `type` matches the parent's `type`
     *
     * @param component Component to test for membership in the set
     * @returns `true` if the component is in the set
     */
    has(component: ComponentLike): boolean;
    /**
     * For a fullName and type, this returns the filenames the matching component, or an empty array if the component is not present
     *
     * @param param Object with fullName and type properties
     * @returns string[]
     */
    getComponentFilenamesByNameAndType({ fullName, type }: MetadataMember): string[];
    [Symbol.iterator](): Iterator<MetadataComponent>;
    /**
     * If this `ComponentSet` has components marked for delete, this sets
     * whether those components are deleted before any other changes are
     * deployed (`destructiveChangesPre.xml`) or after changes are deployed
     * (`destructiveChangesPost.xml`).
     *
     * @param type The type of destructive changes to make; i.e., pre or post deploy.
     */
    setDestructiveChangesType(type: DestructiveChangesType): void;
    /**
     * If this `ComponentSet` has components marked for delete it will use this
     * type to build the appropriate destructive changes manifest.
     *
     * @returns The type of destructive changes to make; i.e., pre or post deploy.
     */
    getDestructiveChangesType(): DestructiveChangesType;
    /**
     * Will return the types of destructive changes in the component set
     * or an empty array if there aren't destructive components present
     *
     * @return DestructiveChangesType[]
     */
    getTypesOfDestructiveChanges(): DestructiveChangesType[];
    /**
     * Each {@link SourceComponent} counts as an element in the set, even if multiple
     * ones map to the same `fullName` and `type` pair.
     *
     * @returns number of metadata components in the set
     */
    get size(): number;
    get destructiveChangesPre(): Map<string, Map<string, SourceComponent>>;
    get destructiveChangesPost(): Map<string, Map<string, SourceComponent>>;
    private sourceKey;
    private simpleKey;
    private splitOnFirstDelimiter;
}
