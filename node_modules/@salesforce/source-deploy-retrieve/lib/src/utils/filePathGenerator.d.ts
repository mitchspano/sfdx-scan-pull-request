import { MetadataComponent } from '../resolve/types';
/**
 * Provided a metadata fullName and type pair, return an array of file paths that should
 * be expected based on the type's definition in the metadata registry.
 *
 * This won't give all the filenames for decomposed types (that would require retrieving
 * the actual parent xml) but should provide enough of the filePath to figure out if the
 * forceignore would ignore it.
 *
 * Example:
 * `const type = new RegistryAccess().getTypeByName('ApexClass');`
 * `filePathsFromMetadataComponent({ fullName: 'MyClass', type }, 'myPackageDir');`
 * returns:
 * `['myPackageDir/classes/MyClass.cls', 'myPackageDir/classes/MyClass.cls-meta.xml']`
 *
 * @param param a MetadataComponent (type/name pair) for which to generate file paths
 * @param packageDir optional package directory to apply to the file paths
 * @returns array of file paths
 */
export declare const filePathsFromMetadataComponent: ({ fullName, type }: MetadataComponent, packageDir?: string) => string[];
