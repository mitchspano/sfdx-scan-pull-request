"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseNestedFullName = exports.parseMetadataXml = exports.trimUntil = exports.parentName = exports.extName = exports.baseName = void 0;
const path_1 = require("path");
/**
 * Get the file or directory name at the end of a path. Different from `path.basename`
 * in that it strips anything after the first '.' in the name.
 *
 * @param fsPath The path to evaluate
 */
function baseName(fsPath) {
    return (0, path_1.basename)(fsPath).split('.')[0];
}
exports.baseName = baseName;
/**
 * Get the name of file path extension. Different from path.extname in that it
 * does not include the '.' in the extension name. Returns an empty string if
 * there is no extension.
 *
 * @param fsPath The path to evaluate
 */
function extName(fsPath) {
    const split = (0, path_1.extname)(fsPath).split('.');
    return split.length > 1 ? split[1] : split[0];
}
exports.extName = extName;
/**
 * Get the name of the parent to the last portion of a path
 *
 * @param fsPath The path to evaluate
 */
function parentName(fsPath) {
    return (0, path_1.basename)((0, path_1.dirname)(fsPath));
}
exports.parentName = parentName;
/**
 * Trim a path up until and including the given part. Returns `fsPath`
 * if the path `part` was not found.
 *
 * @param fsPath Path to trim
 * @param part Path part to trim up until
 * @param untilLast Trim until the *last* occurrence of `part`
 */
function trimUntil(fsPath, part, untilLast = false) {
    const parts = fsPath.split(path_1.sep);
    const partIndex = untilLast ? parts.lastIndexOf(part) : parts.findIndex((p) => part === p);
    if (partIndex === -1) {
        return fsPath;
    }
    return parts.slice(partIndex).join(path_1.sep);
}
exports.trimUntil = trimUntil;
/**
 * Returns the `MetadataXml` info from a given file path. If the path is not a
 * metadata xml file (-meta.xml), returns `undefined`.
 *
 * @param fsPath - File path to parse
 * @returns MetadataXml info or undefined
 */
function parseMetadataXml(fsPath) {
    const match = new RegExp(/(.+)\.(.+)-meta\.xml/).exec((0, path_1.basename)(fsPath));
    if (match) {
        return { fullName: match[1], suffix: match[2], path: fsPath };
    }
}
exports.parseMetadataXml = parseMetadataXml;
/**
 * Returns the fullName for a nested metadata source file. This is for metadata
 * types that can be nested more than 1 level such as report and reportFolder,
 * dashboard and dashboardFolder, etc. It uses the directory name for the metadata type
 * as the starting point (non-inclusively) to parse the fullName.
 *
 * Examples:
 * (source format path)
 * fsPath: force-app/main/default/reports/foo/bar/My_Report.report-meta.xml
 * returns: foo/bar/My_Report
 *
 * (mdapi format path)
 * fsPath: unpackaged/reports/foo/bar-meta.xml
 * returns: foo/bar
 *
 * @param fsPath - File path to parse
 * @param directoryName - name of directory to use as a parsing index
 * @returns the FullName
 */
function parseNestedFullName(fsPath, directoryName) {
    const pathSplits = fsPath.split(path_1.sep);
    // Exit if the directoryName is not included in the file path.
    if (!pathSplits.includes(directoryName)) {
        return;
    }
    const pathPrefix = pathSplits.slice(pathSplits.lastIndexOf(directoryName) + 1);
    const fileName = pathSplits.pop().replace('-meta.xml', '').split('.')[0];
    pathPrefix[pathPrefix.length - 1] = fileName;
    return pathPrefix.join('/');
}
exports.parseNestedFullName = parseNestedFullName;
//# sourceMappingURL=path.js.map