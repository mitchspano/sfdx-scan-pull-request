"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiagnosticUtil = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path_1 = require("path");
const registry_1 = require("../registry");
class DiagnosticUtil {
    constructor(api) {
        this.api = api;
    }
    parseDeployDiagnostic(component, message) {
        const { name: typeName } = component.type;
        switch (typeName) {
            case registry_1.registry.types.lightningcomponentbundle.name:
                return this.parseLwc(component, message);
            case registry_1.registry.types.auradefinitionbundle.name:
                return this.parseAura(component, message);
            default:
                if (typeof message !== 'string') {
                    return this.parseDefault(component, message);
                }
        }
    }
    parseDefault(component, message) {
        const { problem, problemType, fileName, lineNumber, columnNumber } = message;
        const diagnostic = {
            error: problem,
            problemType,
        };
        if (fileName) {
            const localProblemFile = component.walkContent().find((f) => f.endsWith((0, path_1.basename)(message.fileName)));
            diagnostic.filePath = localProblemFile ?? component.xml;
        }
        if (lineNumber && columnNumber) {
            diagnostic.lineNumber = Number(lineNumber);
            diagnostic.columnNumber = Number(columnNumber);
            diagnostic.error = this.appendErrorWithLocation(diagnostic.error, lineNumber, columnNumber);
        }
        return diagnostic;
    }
    parseLwc(component, message) {
        const problem = typeof message === 'string' ? message : message.problem;
        const diagnostic = {
            error: problem,
            problemType: 'Error',
        };
        if (this.api === 'metadata') {
            const deployMessage = message;
            if (deployMessage.fileName) {
                diagnostic.filePath = component.walkContent().find((f) => f.includes(message.fileName));
            }
            const matches = new RegExp(/(\[Line: (\d+), Col: (\d+)] )?(.*)/).exec(problem);
            if (matches && matches[2] && matches[3] && matches[4]) {
                diagnostic.lineNumber = Number(matches[2]);
                diagnostic.columnNumber = Number(matches[3]);
                diagnostic.error = this.appendErrorWithLocation(matches[4], diagnostic.lineNumber, diagnostic.columnNumber);
            }
            else {
                diagnostic.error = problem;
            }
        }
        else {
            try {
                const pathParts = problem.split(/[\s\n\t]+/);
                const msgStartIndex = pathParts.findIndex((part) => part.includes(':'));
                const fileObject = pathParts[msgStartIndex];
                const errLocation = fileObject.slice(fileObject.indexOf(':') + 1);
                const fileName = fileObject.slice(0, fileObject.indexOf(':'));
                diagnostic.error = pathParts.slice(msgStartIndex + 2).join(' ');
                diagnostic.filePath = component.walkContent().find((f) => f.includes(fileName));
                diagnostic.lineNumber = Number(errLocation.split(',')[0]);
                diagnostic.columnNumber = Number(errLocation.split(',')[1]);
                diagnostic.error = this.appendErrorWithLocation(diagnostic.error, diagnostic.lineNumber, diagnostic.columnNumber);
            }
            catch (e) {
                // TODO: log error with parsing error message
                diagnostic.error = problem;
            }
        }
        return diagnostic;
    }
    parseAura(component, message) {
        const problem = typeof message === 'string' ? message : message.problem;
        const diagnostic = {
            error: problem,
            problemType: 'Error',
        };
        let filePath;
        if (this.api === 'tooling') {
            const errorParts = problem.split(' ');
            const fileType = errorParts.find((part) => {
                part = part.toLowerCase();
                return part.includes('controller') || part.includes('renderer') || part.includes('helper');
            });
            filePath = fileType
                ? component.walkContent().find((s) => s.toLowerCase().includes(fileType.toLowerCase()))
                : undefined;
        }
        else {
            const deployMessage = message;
            if (deployMessage.fileName) {
                filePath = component.walkContent().find((f) => f.endsWith((0, path_1.basename)(deployMessage.fileName)));
            }
        }
        if (filePath) {
            diagnostic.filePath = filePath;
            const matches = new RegExp(/(\d+),\s?(\d+)/).exec(problem);
            if (matches) {
                const lineNumber = Number(matches[1]);
                const columnNumber = Number(matches[2]);
                diagnostic.lineNumber = lineNumber;
                diagnostic.columnNumber = columnNumber;
                diagnostic.error = this.appendErrorWithLocation(diagnostic.error, lineNumber, columnNumber);
            }
        }
        return diagnostic;
    }
    appendErrorWithLocation(error, line, column) {
        return `${error} (${line}:${column})`;
    }
}
exports.DiagnosticUtil = DiagnosticUtil;
//# sourceMappingURL=diagnosticUtil.js.map