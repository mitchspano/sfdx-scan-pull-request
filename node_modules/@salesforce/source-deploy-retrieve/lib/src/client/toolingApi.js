"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToolingApi = exports.deployTypes = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
const utils_1 = require("../utils");
const collections_1 = require("../collections");
const registry_1 = require("../registry");
const types_1 = require("./types");
const retrieveUtil_1 = require("./retrieveUtil");
const deployStrategies_1 = require("./deployStrategies");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/source-deploy-retrieve', 'sdr', [
    'beta_tapi_membertype_unsupported_error',
    'tapi_deploy_component_limit_error',
    'tapi_retrieve_component_limit_error',
    'error_in_tooling_retrieve',
    'error_md_not_present_in_org',
]);
const retrieveTypes = new Set([
    'ApexClass',
    'ApexTrigger',
    'ApexPage',
    'ApexComponent',
    'AuraDefinitionBundle',
    'LightningComponentBundle',
]);
exports.deployTypes = new Map([
    ['ApexClass', 'ApexClassMember'],
    ['ApexTrigger', 'ApexTriggerMember'],
    ['ApexPage', 'ApexPageMember'],
    ['ApexComponent', 'ApexComponentMember'],
    ['AuraDefinitionBundle', 'AuraDefinition'],
    ['LightningComponentBundle', 'LightningComponentResource'],
]);
class ToolingApi {
    constructor(connection, resolver, registry = new registry_1.RegistryAccess()) {
        this.connection = connection;
        this.resolver = resolver;
        this.registry = registry;
    }
    async retrieveWithPaths(options) {
        return this.retrieve({
            output: options.output,
            namespace: options.namespace,
            components: collections_1.ComponentSet.fromSource({ fsPaths: [options.paths[0]], registry: this.registry }),
        });
    }
    async retrieve(options) {
        let retrieveResult;
        if (options.components.size > 1) {
            throw new core_1.SfError(messages.getMessage('tapi_retrieve_component_limit_error'), 'MetadataRetrieveLimit');
        }
        const mdComponent = options.components.getSourceComponents().first();
        if (!retrieveTypes.has(mdComponent.type.name)) {
            throw new core_1.SfError(messages.getMessage('beta_tapi_membertype_unsupported_error', [mdComponent.type.name]), 'MetadataTypeUnsupported');
        }
        try {
            const queryResult = (await this.connection.tooling.query((0, retrieveUtil_1.buildQuery)(mdComponent, options.namespace)));
            if (queryResult && queryResult.records.length === 0) {
                return {
                    status: types_1.RequestStatus.Failed,
                    success: false,
                    successes: [],
                    failures: [
                        {
                            component: {
                                fullName: mdComponent.fullName,
                                type: mdComponent.type,
                            },
                            message: messages.getMessage('error_md_not_present_in_org', [mdComponent.fullName]),
                        },
                    ],
                };
            }
            const saveFilesMap = (0, retrieveUtil_1.queryToFileMap)(queryResult, mdComponent, options.output);
            (0, utils_1.createFiles)(saveFilesMap);
            retrieveResult = {
                status: types_1.RequestStatus.Succeeded,
                success: true,
                successes: [{ component: mdComponent }],
                failures: [],
            };
        }
        catch (err) {
            const error = err;
            throw new core_1.SfError(messages.getMessage('error_in_tooling_retrieve'), error.name, [], err, err);
        }
        return retrieveResult;
    }
    async deploy(components, options) {
        let mdComponent;
        if (Array.isArray(components)) {
            if (components.length > 1) {
                throw new core_1.SfError(messages.getMessage('tapi_deploy_component_limit_error'), 'SourceClientError');
            }
            mdComponent = components[0];
        }
        else {
            mdComponent = components;
        }
        const metadataType = mdComponent.type.name;
        if (!exports.deployTypes.get(metadataType)) {
            throw new core_1.SfError(messages.getMessage('beta_tapi_membertype_unsupported_error', [metadataType]), 'SourceClientError');
        }
        const deployStrategy = (0, deployStrategies_1.getDeployStrategy)(metadataType, this.connection);
        const namespace = options && options.namespace ? options.namespace : '';
        return deployStrategy.deploy(mdComponent, namespace);
    }
    async deployWithPaths(path, options) {
        return this.deploy(this.resolver.getComponentsFromPath(path), options);
    }
}
exports.ToolingApi = ToolingApi;
//# sourceMappingURL=toolingApi.js.map