import { ComponentSet } from '../collections';
import { MetadataTransfer, MetadataTransferOptions } from './metadataTransfer';
import { AsyncResult, FileResponse, MetadataApiDeployOptions as ApiOptions, MetadataApiDeployStatus, MetadataTransferResult } from './types';
export declare class DeployResult implements MetadataTransferResult {
    readonly response: MetadataApiDeployStatus;
    readonly components: ComponentSet;
    private readonly diagnosticUtil;
    private fileResponses;
    private readonly shouldConvertPaths;
    constructor(response: MetadataApiDeployStatus, components: ComponentSet);
    getFileResponses(): FileResponse[];
    private createResponses;
    private getState;
    /**
     * Groups messages from the deploy result by component fullName and type
     */
    private getDeployMessages;
    /**
     * If a components fails to delete because it doesn't exist in the org, you get a message like
     * key: 'ApexClass#destructiveChanges.xml'
     * value:[{
     * fullName: 'destructiveChanges.xml',
     * fileName: 'destructiveChanges.xml',
     * componentType: 'ApexClass',
     * problem: 'No ApexClass named: test1 found',
     * problemType: 'Warning'
     * }]
     */
    private deleteNotFoundToFileResponses;
    /**
     * Fix any issues with the deploy message returned by the api.
     * TODO: remove cases if fixes are made in the api.
     */
    private sanitizeDeployMessage;
    private key;
}
export interface MetadataApiDeployOptions extends MetadataTransferOptions {
    apiOptions?: ApiOptions;
    /**
     * Path to a zip file containing mdapi-formatted code and a package.xml
     */
    zipPath?: string;
    /**
     * Path to a directory containing mdapi-formatted code and a package.xml
     */
    mdapiPath?: string;
}
export declare class MetadataApiDeploy extends MetadataTransfer<MetadataApiDeployStatus, DeployResult> {
    static readonly DEFAULT_OPTIONS: Partial<MetadataApiDeployOptions>;
    private options;
    private orgId;
    private isRestDeploy;
    constructor(options: MetadataApiDeployOptions);
    /**
     * Deploy recently validated components without running Apex tests. Requires the operation to have been
     * created with the `{ checkOnly: true }` API option.
     *
     * Ensure that the following requirements are met before deploying a recent validation:
     * - The components have been validated successfully for the target environment within the last 10 days.
     * - As part of the validation, Apex tests in the target org have passed.
     * - Code coverage requirements are met.
     * - If all tests in the org or all local tests are run, overall code coverage is at least 75%, and Apex triggers have some coverage.
     * - If specific tests are run with the RunSpecifiedTests test level, each class and trigger that was deployed is covered by at least 75% individually.
     *
     * See [deployRecentValidation()](https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_deployRecentValidation.htm)
     *
     * @param rest - Set to `true` to use the REST API, otherwise defaults to using SOAP
     * @returns The ID of the quick deployment
     */
    deployRecentValidation(rest?: boolean): Promise<string>;
    /**
     * Check the status of the deploy operation.
     *
     * @returns Status of the deploy
     */
    checkStatus(): Promise<MetadataApiDeployStatus>;
    /**
     * Cancel the deploy operation.
     *
     * Deploys are asynchronously canceled. Once the cancel request is made to the org,
     * check the status of the cancellation with `checkStatus`.
     */
    cancel(): Promise<void>;
    protected pre(): Promise<AsyncResult>;
    protected post(result: MetadataApiDeployStatus): Promise<DeployResult>;
    private getZipBuffer;
}
/**
 * register a listener to `scopedPreDeploy`
 */
export interface ScopedPreDeploy {
    componentSet: ComponentSet;
    orgId: string;
}
/**
 * register a listener to `scopedPostDeploy`
 */
export interface ScopedPostDeploy {
    deployResult: DeployResult;
    orgId: string;
}
