"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryToFileMap = exports.buildQuery = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path_1 = require("path");
const utils_1 = require("../utils");
function buildQuery(mdComponent, namespace = '') {
    let queryString = '';
    const typeName = mdComponent.type.name;
    const fullName = mdComponent.fullName;
    switch (typeName) {
        case 'ApexClass':
        case 'ApexTrigger':
            queryString = `Select Id, ApiVersion, Body, Name, NamespacePrefix, Status from ${typeName} where Name = '${fullName}' and NamespacePrefix = '${namespace}'`;
            break;
        case 'ApexComponent':
        case 'ApexPage':
            queryString = `Select Id, ApiVersion, Name, NamespacePrefix, Markup from ${typeName} where Name = '${fullName}' and NamespacePrefix = '${namespace}'`;
            break;
        case 'AuraDefinitionBundle':
            queryString = 'Select Id, AuraDefinitionBundle.ApiVersion, AuraDefinitionBundle.DeveloperName, ';
            queryString += `AuraDefinitionBundle.NamespacePrefix, DefType, Source from AuraDefinition where AuraDefinitionBundle.DeveloperName = '${fullName}' and AuraDefinitionBundle.NamespacePrefix = '${namespace}'`;
            break;
        case 'LightningComponentBundle':
            queryString =
                'Select Id, LightningComponentBundle.DeveloperName, LightningComponentBundle.NamespacePrefix, FilePath, Source from LightningComponentResource ';
            queryString += `where LightningComponentBundle.DeveloperName = '${fullName}' and LightningComponentBundle.NamespacePrefix = '${namespace}'`;
            break;
        default:
            queryString = '';
    }
    return queryString;
}
exports.buildQuery = buildQuery;
function getAuraSourceName(componentPath, fileNamePrefix, defType) {
    const cmpParentName = (0, path_1.join)((0, path_1.dirname)(componentPath), fileNamePrefix);
    switch (defType) {
        case 'APPLICATION':
            return `${cmpParentName}.app`;
        case 'COMPONENT':
            return `${cmpParentName}.cmp`;
        case 'DOCUMENTATION':
            return `${cmpParentName}.auradoc`;
        case 'STYLE':
            return `${cmpParentName}.css`;
        case 'EVENT':
            return `${cmpParentName}.evt`;
        case 'DESIGN':
            return `${cmpParentName}.design`;
        case 'SVG':
            return `${cmpParentName}.svg`;
        case 'CONTROLLER':
            return `${cmpParentName}Controller.js`;
        case 'HELPER':
            return `${cmpParentName}Helper.js`;
        case 'RENDERER':
            return `${cmpParentName}Renderer.js`;
        case 'TOKENS':
            return `${cmpParentName}.tokens`;
        case 'INTERFACE':
            return `${cmpParentName}.intf`;
        default:
            return '';
    }
}
function queryToFileMap(queryResult, mdComponent, overrideOutputPath) {
    const typeName = mdComponent.type.name;
    let apiVersion;
    let status;
    let record;
    // If output is defined it overrides where the component will be stored
    const mdSourcePath = overrideOutputPath ? (0, utils_1.trimMetaXmlSuffix)(overrideOutputPath) : mdComponent.walkContent()[0];
    const saveFilesMap = new Map();
    switch (typeName) {
        case 'ApexClass':
        case 'ApexTrigger':
            record = queryResult.records[0];
            status = record.Status;
            apiVersion = record.ApiVersion;
            saveFilesMap.set(mdSourcePath, record.Body);
            break;
        case 'ApexComponent':
        case 'ApexPage':
            record = queryResult.records[0];
            apiVersion = record.ApiVersion;
            saveFilesMap.set(mdSourcePath, record.Markup);
            break;
        case 'AuraDefinitionBundle': {
            const auraRecord = queryResult.records;
            apiVersion = auraRecord[0].AuraDefinitionBundle.ApiVersion;
            auraRecord.forEach((item) => {
                const cmpName = getAuraSourceName(mdSourcePath, mdComponent.name, item.DefType);
                saveFilesMap.set(cmpName, item.Source);
            });
            break;
        }
        case 'LightningComponentBundle': {
            const lwcRecord = queryResult.records;
            const bundleParentPath = mdSourcePath.substring(0, mdSourcePath.lastIndexOf(`${path_1.sep}lwc`));
            lwcRecord.forEach((item) => {
                const cmpName = (0, path_1.join)(bundleParentPath, item.FilePath);
                saveFilesMap.set(cmpName, item.Source);
            });
            break;
        }
        default:
    }
    // NOTE: LightningComponentBundle query results returns the -meta.xml file
    if (typeName !== 'LightningComponentBundle') {
        saveFilesMap.set((0, utils_1.generateMetaXMLPath)(mdSourcePath), (0, utils_1.generateMetaXML)(typeName, apiVersion, status));
    }
    return saveFilesMap;
}
exports.queryToFileMap = queryToFileMap;
//# sourceMappingURL=retrieveUtil.js.map