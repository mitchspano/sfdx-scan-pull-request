"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataTransfer = void 0;
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const events_1 = require("events");
const path_1 = require("path");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const fs = require("graceful-fs");
const convert_1 = require("../convert");
const collections_1 = require("../collections");
const types_1 = require("./types");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/source-deploy-retrieve', 'sdr', ['md_request_fail']);
class MetadataTransfer {
    constructor({ usernameOrConnection, components, apiVersion, id }) {
        this.canceled = false;
        this.event = new events_1.EventEmitter();
        this.usernameOrConnection = usernameOrConnection;
        this.components = components;
        this.apiVersion = apiVersion;
        this.transferId = id;
        this.logger = core_1.Logger.childFromRoot(this.constructor.name);
    }
    get id() {
        return this.transferId;
    }
    /**
     * Send the metadata transfer request to the org.
     *
     * @returns AsyncResult from the deploy or retrieve response.
     */
    async start() {
        this.canceled = false;
        const asyncResult = await this.pre();
        this.transferId = asyncResult.id;
        this.logger.debug(`Started metadata transfer. ID = ${this.id}`);
        return asyncResult;
    }
    async pollStatus(frequencyOrOptions, timeout) {
        let pollingOptions = {
            frequency: kit_1.Duration.milliseconds(this.calculatePollingFrequency()),
            timeout: kit_1.Duration.minutes(60),
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            poll: this.poll.bind(this),
        };
        if ((0, ts_types_1.isNumber)(frequencyOrOptions)) {
            pollingOptions.frequency = kit_1.Duration.milliseconds(frequencyOrOptions);
        }
        else if (frequencyOrOptions !== undefined) {
            pollingOptions = { ...pollingOptions, ...frequencyOrOptions };
        }
        if ((0, ts_types_1.isNumber)(timeout)) {
            pollingOptions.timeout = kit_1.Duration.seconds(timeout);
        }
        // from the overloaded methods, there's a possibility frequency/timeout isn't set
        // guarantee frequency and timeout are set
        pollingOptions.frequency ?? (pollingOptions.frequency = kit_1.Duration.milliseconds(this.calculatePollingFrequency()));
        pollingOptions.timeout ?? (pollingOptions.timeout = kit_1.Duration.minutes(60));
        const pollingClient = await core_1.PollingClient.create(pollingOptions);
        try {
            this.logger.debug(`Polling for metadata transfer status. ID = ${this.id}`);
            this.logger.debug(`Polling frequency (ms): ${pollingOptions.frequency.milliseconds}`);
            this.logger.debug(`Polling timeout (min): ${pollingOptions.timeout.minutes}`);
            const completedMdapiStatus = (await pollingClient.subscribe());
            const result = await this.post(completedMdapiStatus);
            if (completedMdapiStatus.status === types_1.RequestStatus.Canceled) {
                this.event.emit('cancel', completedMdapiStatus);
            }
            else {
                this.event.emit('finish', result);
            }
            return result;
        }
        catch (e) {
            const err = e;
            const error = new core_1.SfError(messages.getMessage('md_request_fail', [err.message]), 'MetadataTransferError');
            error.setData({
                id: this.id,
            });
            if (error.stack && err.stack) {
                // append the original stack to this new error
                error.stack += `\nDUE TO:\n${err.stack}`;
            }
            if (this.event.listenerCount('error') === 0) {
                throw error;
            }
            this.event.emit('error', error);
        }
    }
    onUpdate(subscriber) {
        this.event.on('update', subscriber);
    }
    onFinish(subscriber) {
        this.event.on('finish', subscriber);
    }
    onCancel(subscriber) {
        this.event.on('cancel', subscriber);
    }
    onError(subscriber) {
        this.event.on('error', subscriber);
    }
    async maybeSaveTempDirectory(target, cs) {
        const mdapiTempDir = process.env.SFDX_MDAPI_TEMP_DIR;
        if (mdapiTempDir) {
            await core_1.Lifecycle.getInstance().emitWarning('The SFDX_MDAPI_TEMP_DIR environment variable is set, which may degrade performance');
            this.logger.debug(`Converting metadata to: ${mdapiTempDir} because the SFDX_MDAPI_TEMP_DIR environment variable is set`);
            try {
                const source = cs || this.components || new collections_1.ComponentSet();
                const converter = new convert_1.MetadataConverter();
                await converter.convert(source, target, {
                    type: 'directory',
                    outputDirectory: mdapiTempDir,
                });
                if (target === 'source') {
                    // for source convert the package.xml isn't included so write it separately
                    await fs.promises.writeFile((0, path_1.join)(mdapiTempDir, 'package.xml'), await source.getPackageXml());
                }
            }
            catch (e) {
                this.logger.debug(e);
            }
        }
    }
    async getConnection() {
        if (typeof this.usernameOrConnection === 'string') {
            this.usernameOrConnection = await core_1.Connection.create({
                authInfo: await core_1.AuthInfo.create({ username: this.usernameOrConnection }),
            });
            if (this.apiVersion && this.apiVersion !== this.usernameOrConnection.version) {
                this.usernameOrConnection.setApiVersion(this.apiVersion);
                this.logger.debug(`Overriding apiVersion to: ${this.apiVersion}`);
            }
        }
        return this.usernameOrConnection;
    }
    async poll() {
        let completed = false;
        let mdapiStatus;
        if (this.canceled) {
            // This only happens for a canceled retrieve. Canceled deploys are
            // handled via checkStatus response.
            if (!mdapiStatus) {
                mdapiStatus = { id: this.id, success: false, done: true };
            }
            mdapiStatus.status = types_1.RequestStatus.Canceled;
            completed = true;
            this.canceled = false;
        }
        else {
            try {
                mdapiStatus = await this.checkStatus();
                completed = mdapiStatus?.done;
                if (!completed) {
                    this.event.emit('update', mdapiStatus);
                }
            }
            catch (e) {
                this.logger.error(e);
                // tolerate a known mdapi problem 500/INVALID_CROSS_REFERENCE_KEY: invalid cross reference id
                // that happens when request moves out of Pending
                if (e instanceof Error && e.name === 'JsonParseError') {
                    this.logger.debug('Metadata API response not parseable', e);
                    await core_1.Lifecycle.getInstance().emitWarning('Metadata API response not parseable');
                    return { completed: false };
                }
                // tolerate intermittent network errors upto retry limit
                if (['ETIMEDOUT', 'ENOTFOUND', 'ECONNRESET', 'socket hang up'].some((retryableNetworkError) => e.message.includes(retryableNetworkError))) {
                    this.logger.debug('Network error on the request', e);
                    await core_1.Lifecycle.getInstance().emitWarning('Network error occurred.  Continuing to poll.');
                    return { completed: false };
                }
                throw e;
            }
        }
        this.logger.debug(`MDAPI status update: ${mdapiStatus.status}`);
        return { completed, payload: mdapiStatus };
    }
    /**
     * Based on the source components in the component set, it will return a polling frequency in milliseconds
     */
    calculatePollingFrequency() {
        const size = this.components?.getSourceComponents().toArray().length || 0;
        // take a piece-wise approach to encapsulate discrete deployment sizes in polling frequencies that "feel" good when deployed
        if (size === 0) {
            // no component set size is possible for retrieve
            return 1000;
        }
        else if (size <= 10) {
            return 100;
        }
        else if (size <= 50) {
            return 250;
        }
        else if (size <= 100) {
            return 500;
        }
        else if (size <= 1000) {
            return 1000;
        }
        else {
            return size;
        }
    }
}
exports.MetadataTransfer = MetadataTransfer;
//# sourceMappingURL=metadataTransfer.js.map