"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LwcDeploy = void 0;
const path_1 = require("path");
const graceful_fs_1 = require("graceful-fs");
const types_1 = require("../types");
const utils_1 = require("../../utils");
const toolingApi_1 = require("../toolingApi");
const diagnosticUtil_1 = require("../diagnosticUtil");
const baseDeploy_1 = require("./baseDeploy");
class LwcDeploy extends baseDeploy_1.BaseDeploy {
    async deploy(component, namespace) {
        this.component = component;
        this.namespace = namespace;
        const lwcResources = await this.buildResourceList();
        const componentDeployment = await this.upsert(lwcResources);
        let status = "Completed" /* ToolingDeployStatus.Completed */;
        if (componentDeployment.diagnostics.length > 0) {
            status =
                componentDeployment.status !== types_1.ComponentStatus.Failed
                    ? "CompletedPartial" /* ToolingDeployStatus.CompletedPartial */
                    : "Failed" /* ToolingDeployStatus.Failed */;
        }
        return {
            id: undefined,
            status,
            success: status === "Completed" /* ToolingDeployStatus.Completed */,
            components: [componentDeployment],
        };
    }
    async buildResourceList() {
        const sourceFiles = this.component.walkContent();
        sourceFiles.push(this.component.xml);
        const lightningResources = [];
        const existingResources = await this.findLightningResources();
        const lightningBundle = existingResources[0]
            ? await this.upsertBundle(existingResources[0].LightningComponentBundleId)
            : await this.upsertBundle();
        const bundleId = lightningBundle.id;
        sourceFiles.forEach((sourceFile) => {
            const source = (0, graceful_fs_1.readFileSync)(sourceFile, 'utf8');
            const isMetaSource = sourceFile === this.component.xml;
            const format = isMetaSource ? 'js' : (0, utils_1.extName)(sourceFile);
            let match;
            if (existingResources.length > 0) {
                match = existingResources.find((resource) => sourceFile.endsWith((0, path_1.normalize)(resource.FilePath)));
            }
            // If resource exists in org, assign the matching Id
            // else, assign the id of the bundle it's associated with
            const lightningResource = {
                FilePath: sourceFile,
                Source: source,
                Format: format,
                ...(match ? { Id: match.Id } : { LightningComponentBundleId: bundleId }),
            };
            // This is to ensure that the base file is deployed first for lwc
            // otherwise there is a `no base file found` error
            // eslint-disable-next-line no-unused-expressions
            lightningResource.Format === 'js' && !isMetaSource
                ? lightningResources.unshift(lightningResource)
                : lightningResources.push(lightningResource);
        });
        return lightningResources;
    }
    async upsert(lightningResources) {
        const type = this.component.type.name;
        const deployment = {
            status: types_1.ComponentStatus.Unchanged,
            component: this.component,
            diagnostics: [],
        };
        const diagnosticUtil = new diagnosticUtil_1.DiagnosticUtil('tooling');
        let partialSuccess = false;
        let allCreate = true;
        // first resource needs to be created first, so force sync
        for (const resource of lightningResources) {
            try {
                if (resource.Id) {
                    const formattedDef = {
                        Source: resource.Source,
                        Id: resource.Id,
                    };
                    await this.connection.tooling.update(toolingApi_1.deployTypes.get(type), formattedDef);
                    allCreate = false;
                    partialSuccess = true;
                }
                else {
                    const formattedDef = {
                        LightningComponentBundleId: resource.LightningComponentBundleId,
                        Format: resource.Format,
                        Source: resource.Source,
                        FilePath: this.getFormattedPaths(resource.FilePath)[0],
                    };
                    await this.toolingCreate(toolingApi_1.deployTypes.get(type), formattedDef);
                }
            }
            catch (e) {
                const diagnostic = diagnosticUtil.parseDeployDiagnostic(this.component, e.message);
                deployment.diagnostics.push(diagnostic);
            }
        }
        if (deployment.diagnostics.length > 0) {
            deployment.status = partialSuccess ? types_1.ComponentStatus.Changed : types_1.ComponentStatus.Failed;
        }
        else if (allCreate) {
            deployment.status = types_1.ComponentStatus.Created;
        }
        else {
            deployment.status = types_1.ComponentStatus.Changed;
        }
        return deployment;
    }
    async findLightningResources() {
        const lightningResourceResult = await this.connection.tooling.query(`Select LightningComponentBundleId, Id, Format, Source, FilePath from LightningComponentResource where LightningComponentBundle.DeveloperName = '${this.component.fullName}' and LightningComponentBundle.NamespacePrefix = '${this.namespace}'`);
        return lightningResourceResult.records;
    }
}
exports.LwcDeploy = LwcDeploy;
//# sourceMappingURL=lwcDeploy.js.map