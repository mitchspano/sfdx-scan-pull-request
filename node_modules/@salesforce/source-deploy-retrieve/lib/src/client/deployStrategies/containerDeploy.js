"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerDeploy = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const graceful_fs_1 = require("graceful-fs");
const kit_1 = require("@salesforce/kit");
const core_1 = require("@salesforce/core");
const toolingApi_1 = require("../toolingApi");
const types_1 = require("../types");
const path_1 = require("../../utils/path");
const baseDeploy_1 = require("./baseDeploy");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/source-deploy-retrieve', 'sdr', [
    'beta_tapi_mdcontainer_error',
    'beta_tapi_car_error',
    'beta_tapi_membertype_error',
]);
class ContainerDeploy extends baseDeploy_1.BaseDeploy {
    async deploy(component, namespace) {
        this.component = component;
        this.namespace = namespace;
        const sourcePath = component.content;
        const metadataPath = component.xml;
        const container = await this.createMetadataContainer();
        await this.createContainerMember([sourcePath, metadataPath], container);
        const asyncRequest = await this.createContainerAsyncRequest(container);
        const containerRequestStatus = await this.pollContainerStatus(asyncRequest.id);
        return this.buildSourceDeployResult(containerRequestStatus);
    }
    async createMetadataContainer() {
        const metadataContainer = await this.toolingCreate(ContainerDeploy.METADATA_CONTAINER, {
            Name: `Deploy_MDC_${Date.now()}`,
        });
        if (!metadataContainer.success) {
            throw new core_1.SfError(messages.getMessage('beta_tapi_mdcontainer_error'), 'DeployError');
        }
        return metadataContainer;
    }
    async createContainerMember(outboundFiles, container) {
        const id = container.id;
        const metadataContent = (0, graceful_fs_1.readFileSync)(outboundFiles[1], 'utf8');
        const metadataField = this.buildMetadataField(metadataContent);
        const body = (0, graceful_fs_1.readFileSync)(outboundFiles[0], 'utf8');
        const fileName = (0, path_1.baseName)(outboundFiles[0]);
        const entityId = await this.getContentEntity(this.component.type.name, fileName, this.namespace);
        const containerMemberObject = {
            MetadataContainerId: id,
            FullName: fileName,
            Body: body,
            Metadata: metadataField,
            ...(entityId ? { contentEntityId: entityId } : {}),
        };
        const containerMember = await this.toolingCreate(toolingApi_1.deployTypes.get(this.component.type.name), containerMemberObject);
        if (!containerMember.success) {
            throw new core_1.SfError(messages.getMessage('beta_tapi_membertype_error', [this.component.type.name]), 'DeployError');
        }
        return containerMember;
    }
    async getContentEntity(metadataType, fileName, namespace) {
        const queryResult = (await this.connection.tooling.query(`Select Id from ${metadataType} where Name = '${fileName}' and NamespacePrefix = '${namespace}'`));
        return queryResult && queryResult.records.length === 1 ? queryResult.records[0].Id : undefined;
    }
    async createContainerAsyncRequest(container) {
        const contAsyncRequest = await this.toolingCreate(ContainerDeploy.CONTAINER_ASYNC_REQUEST, {
            MetadataContainerId: container.id,
        });
        if (!contAsyncRequest.success) {
            throw new core_1.SfError(messages.getMessage('beta_tapi_car_error'), 'DeployError');
        }
        return contAsyncRequest;
    }
    async pollContainerStatus(containerId) {
        let count = 0;
        let containerStatus;
        do {
            if (count > 0) {
                await (0, kit_1.sleep)(100);
            }
            containerStatus = (await this.connection.tooling.retrieve(ContainerDeploy.CONTAINER_ASYNC_REQUEST, containerId));
            count++;
        } while (containerStatus.State === "Queued" /* ToolingDeployStatus.Queued */ && count <= 30);
        return containerStatus;
    }
    buildSourceDeployResult(containerRequest) {
        const componentDeployment = {
            component: this.component,
            status: types_1.ComponentStatus.Unchanged,
            diagnostics: [],
        };
        const deployMessages = [];
        const { componentSuccesses, componentFailures } = containerRequest.DeployDetails;
        if (componentSuccesses) {
            if (Array.isArray(componentSuccesses)) {
                deployMessages.push(...componentSuccesses);
            }
            else {
                deployMessages.push(componentSuccesses);
            }
        }
        if (componentFailures) {
            if (Array.isArray(componentFailures)) {
                deployMessages.push(...componentFailures);
            }
            else {
                deployMessages.push(componentFailures);
            }
        }
        for (const message of deployMessages) {
            if (message.changed === true || message.changed === 'true') {
                componentDeployment.status = types_1.ComponentStatus.Changed;
            }
            else if (message.created === true || message.created === 'true') {
                componentDeployment.status = types_1.ComponentStatus.Created;
            }
            else if (message.deleted === true || message.deleted === 'true') {
                componentDeployment.status = types_1.ComponentStatus.Deleted;
            }
            else if (message.success === false || message.success === 'false') {
                componentDeployment.status = types_1.ComponentStatus.Failed;
                componentDeployment.diagnostics.push({
                    error: message.problem,
                    problemType: message.problemType,
                    filePath: this.component.content,
                    lineNumber: Number(message.lineNumber),
                    columnNumber: Number(message.columnNumber),
                });
            }
        }
        return {
            id: containerRequest.Id,
            status: containerRequest.State,
            success: containerRequest.State === "Completed" /* ToolingDeployStatus.Completed */,
            components: [componentDeployment],
        };
    }
}
exports.ContainerDeploy = ContainerDeploy;
ContainerDeploy.CONTAINER_ASYNC_REQUEST = 'ContainerAsyncRequest';
ContainerDeploy.METADATA_CONTAINER = 'MetadataContainer';
//# sourceMappingURL=containerDeploy.js.map