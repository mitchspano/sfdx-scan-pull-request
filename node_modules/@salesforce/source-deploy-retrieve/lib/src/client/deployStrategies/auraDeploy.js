"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuraDeploy = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const graceful_fs_1 = require("graceful-fs");
const utils_1 = require("../../utils");
const types_1 = require("../types");
const toolingApi_1 = require("../toolingApi");
const diagnosticUtil_1 = require("../diagnosticUtil");
const baseDeploy_1 = require("./baseDeploy");
class AuraDeploy extends baseDeploy_1.BaseDeploy {
    async deploy(component, namespace) {
        this.component = component;
        this.namespace = namespace;
        const auraDefinitions = await this.buildDefList();
        const componentDeployment = await this.upsert(auraDefinitions);
        let status = "Completed" /* ToolingDeployStatus.Completed */;
        if (componentDeployment.diagnostics.length > 0) {
            status =
                componentDeployment.status !== types_1.ComponentStatus.Failed
                    ? "CompletedPartial" /* ToolingDeployStatus.CompletedPartial */
                    : "Failed" /* ToolingDeployStatus.Failed */;
        }
        return {
            id: undefined,
            status,
            success: status === "Completed" /* ToolingDeployStatus.Completed */,
            components: [componentDeployment],
        };
    }
    async buildDefList() {
        const sourceFiles = this.component.walkContent();
        const auraDefinitions = [];
        const existingDefinitions = await this.findAuraDefinitions();
        const auraBundle = existingDefinitions[0]
            ? await this.upsertBundle(existingDefinitions[0].AuraDefinitionBundleId)
            : await this.upsertBundle();
        const bundleId = auraBundle.id;
        sourceFiles.forEach((sourceFile) => {
            const source = (0, graceful_fs_1.readFileSync)(sourceFile, 'utf8');
            const suffix = (0, utils_1.extName)(sourceFile);
            const defType = this.getAuraDefType(sourceFile, suffix);
            const format = this.getAuraFormat(suffix);
            let match;
            if (existingDefinitions.length > 0) {
                match = existingDefinitions.find((definition) => definition.DefType === defType);
            }
            // If definition exists in org, assign the matching Id
            // else, assign the id of the bundle it's associated with
            const auraDef = {
                FilePath: sourceFile,
                DefType: defType,
                Source: source,
                Format: format,
                ...(match ? { Id: match.Id } : { AuraDefinitionBundleId: bundleId }),
            };
            // This is to ensure we return the correct project path when reporting errors
            // must be the file associated with the specified aura type
            // eslint-disable-next-line no-unused-expressions
            AuraDeploy.AURA_DEF_TYPES.includes(auraDef.DefType)
                ? auraDefinitions.unshift(auraDef)
                : auraDefinitions.push(auraDef);
        });
        return auraDefinitions;
    }
    async upsert(auraDefinitions) {
        const type = this.component.type.name;
        const diagnosticUtil = new diagnosticUtil_1.DiagnosticUtil('tooling');
        const deployment = {
            status: types_1.ComponentStatus.Unchanged,
            component: this.component,
            diagnostics: [],
        };
        let partialSuccess = false;
        let allCreate = true;
        const deployPromises = auraDefinitions.map(async (definition) => {
            try {
                if (definition.Id) {
                    const formattedDef = {
                        Source: definition.Source,
                        Id: definition.Id,
                    };
                    await this.connection.tooling.update(toolingApi_1.deployTypes.get(type), formattedDef);
                    allCreate = false;
                    partialSuccess = true;
                }
                else {
                    const formattedDef = {
                        AuraDefinitionBundleId: definition.AuraDefinitionBundleId,
                        DefType: definition.DefType,
                        Format: definition.Format,
                        Source: definition.Source,
                    };
                    await this.toolingCreate(toolingApi_1.deployTypes.get(type), formattedDef);
                    partialSuccess = true;
                }
            }
            catch (e) {
                const diagnostic = diagnosticUtil.parseDeployDiagnostic(this.component, e.message);
                deployment.diagnostics.push(diagnostic);
            }
        });
        await Promise.all(deployPromises);
        if (deployment.diagnostics.length > 0) {
            deployment.status = partialSuccess ? types_1.ComponentStatus.Changed : types_1.ComponentStatus.Failed;
        }
        else if (allCreate) {
            deployment.status = types_1.ComponentStatus.Created;
        }
        else {
            deployment.status = types_1.ComponentStatus.Changed;
        }
        return deployment;
    }
    getAuraFormat(suffix) {
        switch (suffix) {
            case 'js':
                return 'JS';
            case 'css':
                return 'CSS';
            case 'svg':
                return 'SVG';
            default:
                return 'XML';
        }
    }
    getAuraDefType(sourcePath, suffix) {
        const fileName = (0, utils_1.baseName)(sourcePath);
        switch (suffix) {
            case 'app':
                return 'APPLICATION';
            case 'cmp':
                return 'COMPONENT';
            case 'auradoc':
                return 'DOCUMENTATION';
            case 'css':
                return 'STYLE';
            case 'evt':
                return 'EVENT';
            case 'design':
                return 'DESIGN';
            case 'svg':
                return 'SVG';
            case 'js':
                if (fileName.endsWith('Controller')) {
                    return 'CONTROLLER';
                }
                else if (fileName.endsWith('Helper')) {
                    return 'HELPER';
                }
                else if (fileName.endsWith('Renderer')) {
                    return 'RENDERER';
                }
                break;
            case 'tokens':
                return 'TOKENS';
            case 'intf':
                return 'INTERFACE';
            default:
                return '';
        }
    }
    async findAuraDefinitions() {
        const auraDefResult = await this.connection.tooling.query(`Select AuraDefinitionBundleId, Id, Format, Source, DefType from AuraDefinition where AuraDefinitionBundle.DeveloperName = '${this.component.fullName}' and AuraDefinitionBundle.NamespacePrefix = '${this.namespace}'`);
        return auraDefResult.records;
    }
}
exports.AuraDeploy = AuraDeploy;
AuraDeploy.AURA_DEF_TYPES = ['APPLICATION', 'COMPONENT', 'EVENT', 'INTERFACE'];
//# sourceMappingURL=auraDeploy.js.map