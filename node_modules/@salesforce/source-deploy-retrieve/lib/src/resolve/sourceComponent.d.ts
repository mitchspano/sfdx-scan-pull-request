import { JsonMap } from '@salesforce/ts-types';
import { SfdxFileFormat } from '../convert';
import { MetadataType } from '../registry';
import { DestructiveChangesType } from '../collections';
import { MetadataComponent, VirtualDirectory } from './types';
import { TreeContainer } from './treeContainers';
import { ForceIgnore } from './forceIgnore';
export declare type ComponentProperties = {
    name: string;
    type: MetadataType;
    xml?: string;
    content?: string;
    parent?: SourceComponent;
    parentType?: MetadataType;
};
/**
 * Representation of a MetadataComponent in a file tree.
 */
export declare class SourceComponent implements MetadataComponent {
    readonly name: string;
    readonly type: MetadataType;
    readonly xml?: string;
    readonly parent?: SourceComponent;
    parentType?: MetadataType;
    content?: string;
    private treeContainer;
    private forceIgnore;
    private markedForDelete;
    private destructiveChangesType;
    constructor(props: ComponentProperties, tree?: TreeContainer, forceIgnore?: ForceIgnore);
    /**
     *
     * @param props component properties (at a minimum, name and type)
     * @param fs VirtualTree.  If not provided, one will be constructed based on the name/type of the props
     * @param forceIgnore
     * @returns SourceComponent
     */
    static createVirtualComponent(props: ComponentProperties, fs?: VirtualDirectory[], forceIgnore?: ForceIgnore): SourceComponent;
    walkContent(): string[];
    /**
     * returns the children of a parent SourceComponent
     *
     * Ensures that the children of SourceComponent are valid child types.
     * Invalid child types can occur when projects are structured in an atypical way such as having
     * ApexClasses or Layouts within a CustomObject folder.
     *
     * @return SourceComponent[] containing valid children
     */
    getChildren(): SourceComponent[];
    parseXml<T = JsonMap>(xmlFilePath?: string): Promise<T>;
    parseXmlSync<T = JsonMap>(xmlFilePath?: string): T;
    /**
     * will return this instance of the forceignore, or will create one if undefined
     *
     * @return ForceIgnore
     */
    getForceIgnore(): ForceIgnore;
    /**
     * As a performance enhancement, use the already parsed parent xml source
     * to return the child section of xml source. This is useful for non-decomposed
     * transformers where all child source components reference the parent's
     * xml file to prevent re-reading the same file multiple times.
     *
     * @param parentXml parsed parent XMl source as an object
     * @returns child section of the parent's xml
     */
    parseFromParentXml<T = JsonMap>(parentXml: T): T;
    getPackageRelativePath(fsPath: string, format: SfdxFileFormat): string;
    /**
     * @returns whether this component should be part of destructive changes.
     */
    isMarkedForDelete(): boolean;
    getDestructiveChangesType(): DestructiveChangesType;
    setMarkedForDelete(destructiveChangeType?: DestructiveChangesType | boolean): void;
    private calculateRelativePath;
    private parse;
    private parseAndValidateXML;
    private getDecomposedChildren;
    private getNonDecomposedChildren;
    private walk;
    get fullName(): string;
    get tree(): TreeContainer;
    /**
     * Returns whether this component type is supported by the Metadata API
     * and therefore should have an entry added to the manifest.
     *
     * This is defined on the type in the registry. The type is required to
     * be in the registry for proper classification and for possible use in
     * decomposition/recomposition.
     *
     * Default value is true, so the only way to return false is to explicitly
     * set it in the registry as false.
     *
     * E.g., CustomFieldTranslation.
     */
    get isAddressable(): boolean;
}
