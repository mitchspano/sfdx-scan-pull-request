"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ForceIgnore = void 0;
const path_1 = require("path");
const index_1 = require("ignore/index");
const graceful_fs_1 = require("graceful-fs");
const core_1 = require("@salesforce/core");
const fileSystemHandler_1 = require("../utils/fileSystemHandler");
class ForceIgnore {
    constructor(forceIgnorePath = '') {
        this.DEFAULT_IGNORE = ['**/*.dup', '**/.*', '**/package2-descriptor.json', '**/package2-manifest.json'];
        try {
            let contents = (0, graceful_fs_1.readFileSync)(forceIgnorePath, 'utf-8');
            // check if file `.forceignore` exists
            if (contents !== undefined) {
                // check for windows style separators (\) and warn
                if (contents.includes('\\')) {
                    const lifecycle = core_1.Lifecycle.getInstance();
                    // cannot await a method in a constructor
                    void lifecycle.emitWarning('Your .forceignore file incorrectly uses the backslash ("\\") as a folder separator; it should use the slash ("/") instead. We currently accept both separators, but we plan to stop supporting the backslash soon.');
                    // TODO: change this in v56 to only emit warning but NOT fix file
                    contents = contents.replace(/\\/g, '/');
                }
                // add the default ignore paths, and then parse the .forceignore file
                this.parser = (0, index_1.default)().add(`${contents}\n${this.DEFAULT_IGNORE.join('\n')}`);
                this.forceIgnoreDirectory = (0, path_1.dirname)(forceIgnorePath);
            }
        }
        catch (e) {
            // TODO: log no force ignore
        }
    }
    /**
     * Performs an upward directory search for a `.forceignore` file and returns a
     * `ForceIgnore` object based on the result. If there is no `.forceignore` file,
     * the returned `ForceIgnore` object will accept everything.
     *
     * @param seed Path to begin the `.forceignore` search from
     */
    static findAndCreate(seed) {
        let potentialForceIgnorePath = '';
        const projectConfigPath = (0, fileSystemHandler_1.searchUp)(seed, ForceIgnore.FILE_NAME);
        if (projectConfigPath) {
            potentialForceIgnorePath = (0, path_1.join)((0, path_1.dirname)(projectConfigPath), ForceIgnore.FILE_NAME);
        }
        return new ForceIgnore(potentialForceIgnorePath);
    }
    denies(fsPath) {
        try {
            return this.parser.ignores((0, path_1.relative)(this.forceIgnoreDirectory, fsPath));
        }
        catch (e) {
            return false;
        }
    }
    accepts(fsPath) {
        try {
            return !this.parser.ignores((0, path_1.relative)(this.forceIgnoreDirectory, fsPath));
        }
        catch (e) {
            return true;
        }
    }
}
exports.ForceIgnore = ForceIgnore;
ForceIgnore.FILE_NAME = '.forceignore';
//# sourceMappingURL=forceIgnore.js.map