"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DecomposedSourceAdapter = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
const sourceComponent_1 = require("../sourceComponent");
const utils_1 = require("../../utils");
const mixedContentSourceAdapter_1 = require("./mixedContentSourceAdapter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/source-deploy-retrieve', 'sdr', ['error_unexpected_child_type']);
/**
 * Handles decomposed types. A flavor of mixed content where a component can
 * have additional -meta.xml files that represent child components of the main
 * component.
 *
 * __Example Types__:
 *
 * CustomObject, CustomObjectTranslation
 *
 * __Example Structures__:
 *
 *```text
 * foos/
 * ├── MyFoo__c/
 * |   ├── MyFoo__c.foo-meta.xml
 * |   ├── bars/
 * |      ├── a.bar-meta.xml
 * |      ├── b.bar-meta.xml
 * |      ├── c.bar-meta.xml
 *
 * foos/
 * ├── MyFoo__c/
 * |   ├── a.bar-meta.xml
 * |   ├── MyFoo__c.foo-meta.xml
 * |   ├── b.bar-meta.xml
 * |   ├── c.bar-meta.xml
 *```
 */
class DecomposedSourceAdapter extends mixedContentSourceAdapter_1.MixedContentSourceAdapter {
    constructor() {
        super(...arguments);
        this.ownFolder = true;
        this.metadataWithContent = false;
    }
    getComponent(path, isResolvingSource = true) {
        let rootMetadata = super.parseAsRootMetadataXml(path);
        if (!rootMetadata) {
            const rootMetadataPath = this.getRootMetadataXmlPath(path);
            if (rootMetadataPath) {
                rootMetadata = (0, utils_1.parseMetadataXml)(rootMetadataPath);
            }
        }
        let component;
        if (rootMetadata) {
            const componentName = this.type.folderType
                ? `${(0, utils_1.parentName)(rootMetadata.path)}/${rootMetadata.fullName}`
                : rootMetadata.fullName;
            component = new sourceComponent_1.SourceComponent({
                name: componentName,
                type: this.type,
                xml: rootMetadata.path,
            }, this.tree, this.forceIgnore);
        }
        return this.populate(path, component, isResolvingSource);
    }
    /**
     * If the trigger turns out to be part of a child component, `populate` will build
     * the child component, set its parent property to the one created by the
     * `BaseSourceAdapter`, and return the child component instead.
     */
    populate(trigger, component, isResolvingSource) {
        const metaXml = (0, utils_1.parseMetadataXml)(trigger);
        if (metaXml) {
            const pathToContent = this.trimPathToContent(trigger);
            const childTypeId = this.type.children.suffixes[metaXml.suffix];
            const triggerIsAChild = !!childTypeId;
            const strategy = this.type.strategies.decomposition;
            if (triggerIsAChild) {
                if (strategy === "folderPerType" /* DecompositionStrategy.FolderPerType */ || isResolvingSource) {
                    let parent = component;
                    if (!parent) {
                        parent = new sourceComponent_1.SourceComponent({
                            name: (0, utils_1.baseName)(pathToContent),
                            type: this.type,
                        }, this.tree, this.forceIgnore);
                    }
                    parent.content = pathToContent;
                    return new sourceComponent_1.SourceComponent({
                        name: metaXml.fullName,
                        type: this.type.children.types[childTypeId],
                        xml: trigger,
                        parent,
                    }, this.tree, this.forceIgnore);
                }
            }
            else {
                if (!component) {
                    // This is most likely metadata found within a CustomObject folder that is not a
                    // child type of CustomObject. E.g., Layout, SharingRules, ApexClass.
                    throw new core_1.SfError(messages.getMessage('error_unexpected_child_type', [trigger, this.type.name]), 'TypeInferenceError');
                }
            }
            if (component) {
                component.content = pathToContent;
            }
        }
        return component;
    }
}
exports.DecomposedSourceAdapter = DecomposedSourceAdapter;
//# sourceMappingURL=decomposedSourceAdapter.js.map