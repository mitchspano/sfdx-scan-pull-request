"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MixedContentSourceAdapter = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path_1 = require("path");
const core_1 = require("@salesforce/core");
const path_2 = require("../../utils/path");
const sourceComponent_1 = require("../sourceComponent");
const baseSourceAdapter_1 = require("./baseSourceAdapter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/source-deploy-retrieve', 'sdr', ['error_expected_source_files']);
/**
 * Handles types with mixed content. Mixed content means there are one or more additional
 * file(s) associated with a component with any file extension. Even an entire folder
 * can be considered "the content".
 *
 * __Example Types__:
 *
 * StaticResources, Documents, Bundle Types
 *
 * __Example Structures__:
 *
 *```text
 * foos/
 * ├── myFoo/
 * |   ├── fooFolder/
 * |      ├── foofighters.x
 * |   ├── foo.y
 * |   ├── fooBar.z
 * ├── myFoo.ext-meta.xml
 * bars/
 * ├── myBar.xyz
 * ├── myBar.ext2-meta.xml
 *```
 */
class MixedContentSourceAdapter extends baseSourceAdapter_1.BaseSourceAdapter {
    getRootMetadataXmlPath(trigger) {
        if (this.ownFolder) {
            const componentRoot = this.trimPathToContent(trigger);
            return this.tree.find('metadataXml', (0, path_1.basename)(componentRoot), componentRoot);
        }
        return this.findMetadataFromContent(trigger);
    }
    populate(trigger, component) {
        let contentPath = this.trimPathToContent(trigger);
        if (contentPath === component?.xml) {
            contentPath = this.tree.find('content', (0, path_2.baseName)(contentPath), (0, path_1.dirname)(contentPath));
        }
        // Content path might be undefined for staticResource where all files are ignored and only the xml is included.
        if (!contentPath || !this.tree.exists(contentPath)) {
            throw new core_1.SfError(messages.getMessage('error_expected_source_files', [trigger, this.type.name]), 'ExpectedSourceFilesError');
        }
        if (component) {
            component.content = contentPath;
        }
        else {
            component = new sourceComponent_1.SourceComponent({
                name: (0, path_2.baseName)(contentPath),
                type: this.type,
                content: contentPath,
            }, this.tree, this.forceIgnore);
        }
        return component;
    }
    /**
     * Trim a path up until the root of a component's content. If the content is a file,
     * the given path will be returned back. If the content is a folder, the path to that
     * folder will be returned. Intended to be used exclusively for MixedContent types.
     *
     * @param path Path to trim
     * @param type MetadataType to determine content for
     */
    trimPathToContent(path) {
        const pathParts = path.split(path_1.sep);
        const typeFolderIndex = pathParts.lastIndexOf(this.type.directoryName);
        const offset = this.type.inFolder ? 3 : 2;
        return pathParts.slice(0, typeFolderIndex + offset).join(path_1.sep);
    }
    /**
     * A utility for finding a component's root metadata xml from a path to a component's
     * content. "Content" can either be a single file or an entire directory. If the content
     * is a directory, the path can be files or other directories inside of it.
     *
     * @param path Path to content or a child of the content
     */
    findMetadataFromContent(path) {
        const rootContentPath = this.trimPathToContent(path);
        const rootTypeDirectory = (0, path_1.dirname)(rootContentPath);
        const contentFullName = (0, path_2.baseName)(rootContentPath);
        return this.tree.find('metadataXml', contentFullName, rootTypeDirectory);
    }
}
exports.MixedContentSourceAdapter = MixedContentSourceAdapter;
//# sourceMappingURL=mixedContentSourceAdapter.js.map