"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MatchingContentSourceAdapter = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
const common_1 = require("../../common");
const path_1 = require("../../utils/path");
const baseSourceAdapter_1 = require("./baseSourceAdapter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/source-deploy-retrieve', 'sdr', [
    'error_no_source_ignore',
    'error_expected_source_files',
]);
/**
 * Handles types with a single content file with a matching file extension.
 *
 * __Example Types__:
 *
 * ApexClass, ApexTrigger, ApexComponent
 *
 * __Example Structure__:
 *
 * ```text
 * foos/
 * ├── foobar.ext
 * ├── foobar.ext-meta.xml
 *```
 */
class MatchingContentSourceAdapter extends baseSourceAdapter_1.BaseSourceAdapter {
    getRootMetadataXmlPath(trigger) {
        return `${trigger}${common_1.META_XML_SUFFIX}`;
    }
    populate(trigger, component) {
        let sourcePath;
        if (component.xml === trigger) {
            const fsPath = this.removeMetaXmlSuffix(trigger);
            if (this.tree.exists(fsPath)) {
                sourcePath = fsPath;
            }
        }
        else if (this.extensionMatchesType(trigger)) {
            sourcePath = trigger;
        }
        if (!sourcePath) {
            throw new core_1.SfError(messages.getMessage('error_expected_source_files', [trigger, this.type.name]), 'ExpectedSourceFilesError');
            // throw new ExpectedSourceFilesError(this.type, trigger);
        }
        else if (this.forceIgnore.denies(sourcePath)) {
            throw new core_1.SfError(messages.getMessage('error_no_source_ignore', [this.type.name, sourcePath]), 'UnexpectedForceIgnore');
        }
        component.content = sourcePath;
        return component;
    }
    removeMetaXmlSuffix(fsPath) {
        return fsPath.slice(0, fsPath.lastIndexOf(common_1.META_XML_SUFFIX));
    }
    extensionMatchesType(fsPath) {
        return this.registry.getTypeBySuffix((0, path_1.extName)(fsPath)) === this.type;
    }
}
exports.MatchingContentSourceAdapter = MatchingContentSourceAdapter;
//# sourceMappingURL=matchingContentSourceAdapter.js.map