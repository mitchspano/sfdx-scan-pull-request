import { MetadataXml, SourceAdapter } from '../types';
import { ForceIgnore } from '../forceIgnore';
import { TreeContainer } from '../treeContainers';
import { SourceComponent } from '../sourceComponent';
import { SourcePath } from '../../common';
import { MetadataType, RegistryAccess } from '../../registry';
export declare abstract class BaseSourceAdapter implements SourceAdapter {
    protected type: MetadataType;
    protected registry: RegistryAccess;
    protected forceIgnore: ForceIgnore;
    protected tree: TreeContainer;
    /**
     * Whether or not an adapter should expect a component to be in its own, self-named
     * folder, including its root metadata xml file.
     */
    protected ownFolder: boolean;
    protected metadataWithContent: boolean;
    constructor(type: MetadataType, registry?: RegistryAccess, forceIgnore?: ForceIgnore, tree?: TreeContainer);
    getComponent(path: SourcePath, isResolvingSource?: boolean): SourceComponent;
    /**
     * Control whether metadata and content metadata files are allowed for an adapter.
     */
    allowMetadataWithContent(): boolean;
    /**
     * If the path given to `getComponent` is the root metadata xml file for a component,
     * parse the name and return it. This is an optimization to not make a child adapter do
     * anymore work to find it.
     *
     * @param path File path of a metadata component
     */
    protected parseAsRootMetadataXml(path: SourcePath): MetadataXml;
    /**
     * If the path given to `getComponent` serves as the sole definition (metadata and content)
     * for a component, parse the name and return it. This allows matching files in metadata
     * format such as:
     *
     * .../tabs/MyTab.tab
     *
     * @param path File path of a metadata component
     */
    private parseAsContentMetadataXml;
    private parseAsFolderMetadataXml;
    private calculateName;
    /**
     * Determine the related root metadata xml when the path given to `getComponent` isn't one.
     *
     * @param trigger Path that `getComponent` was called with
     */
    protected abstract getRootMetadataXmlPath(trigger: SourcePath): SourcePath;
    /**
     * Populate additional properties on a SourceComponent, such as source files and child components.
     * The component passed to `populate` has its fullName, xml, and type properties already set.
     *
     * @param component Component to populate properties on
     * @param trigger Path that `getComponent` was called with
     */
    protected abstract populate(trigger: SourcePath, component?: SourceComponent, isResolvingSource?: boolean): SourceComponent;
}
