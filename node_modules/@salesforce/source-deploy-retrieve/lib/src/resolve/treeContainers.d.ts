/// <reference types="node" />
/// <reference types="node" />
import { Readable } from 'stream';
import { SourcePath } from '../common';
import { VirtualDirectory } from './types';
/**
 * A container for interacting with a file system. Operations such as component resolution,
 * conversion, and packaging perform I/O against `TreeContainer` abstractions.
 *
 * Extend this base class to implement a custom container.
 */
export declare abstract class TreeContainer {
    /**
     * Searches for a metadata component file in a container directory.
     *
     * @param fileType - The type of component file
     * @param name - The name of the file without a suffix
     * @param directory - The directory to search in
     * @returns The first path that meets the criteria, or `undefined` if none were found
     */
    find(fileType: 'content' | 'metadataXml', name: string, directory: string): string | undefined;
    /**
     * Whether or not a file path exists in the container.
     *
     * @param fsPath - File path to test
     * @returns `true` if the path exists
     */
    abstract exists(fsPath: SourcePath): boolean;
    /**
     * Whether or not a file path is a directory in the container.
     *
     * @param fsPath - File path to test
     * @returns `true` if the path is to a directory
     */
    abstract isDirectory(fsPath: SourcePath): boolean;
    /**
     * Reads the contents of a directory in the container.
     *
     * @param fsPath Path to directory
     * @returns An array of file and directory names in the directory
     */
    abstract readDirectory(fsPath: SourcePath): string[];
    /**
     * Reads the contents of a file.
     *
     * @param fsPath
     * @returns A buffer of the file contents
     */
    abstract readFile(fsPath: SourcePath): Promise<Buffer>;
    /**
     * Reads the contents of a file synchronously.
     *
     * @param fsPath
     * @returns A buffer of the file contents
     */
    abstract readFileSync(fsPath: SourcePath): Buffer;
    /**
     * Creates a readable stream of a file's contents.
     *
     * @param fsPath - File path to create a readable stream from
     * @returns A readable stream
     */
    abstract stream(fsPath: SourcePath): Readable;
}
/**
 * A {@link TreeContainer} that wraps the NodeJS `fs` module.
 */
export declare class NodeFSTreeContainer extends TreeContainer {
    isDirectory(fsPath: SourcePath): boolean;
    exists(fsPath: SourcePath): boolean;
    readDirectory(fsPath: SourcePath): string[];
    readFile(fsPath: SourcePath): Promise<Buffer>;
    readFileSync(fsPath: SourcePath): Buffer;
    stream(fsPath: SourcePath): Readable;
}
/**
 * A {@link TreeContainer} that utilizes the central directory of a zip file
 * to perform I/O without unzipping it to the disk first.
 */
export declare class ZipTreeContainer extends TreeContainer {
    private tree;
    private constructor();
    /**
     * Creates a `ZipTreeContainer` from a Buffer of a zip file.
     *
     * @param buffer - Buffer of the zip file
     * @returns A Promise of a `ZipTreeContainer`
     */
    static create(buffer: Buffer): Promise<ZipTreeContainer>;
    exists(fsPath: string): boolean;
    isDirectory(fsPath: string): boolean;
    readDirectory(fsPath: string): string[];
    readFile(fsPath: string): Promise<Buffer>;
    readFileSync(fsPath: string): Buffer;
    stream(fsPath: string): Readable;
    private populate;
    private ensureDirPathExists;
}
/**
 * A {@link TreeContainer} useful for mocking a file system.
 */
export declare class VirtualTreeContainer extends TreeContainer {
    private tree;
    private fileContents;
    constructor(virtualFs: VirtualDirectory[]);
    /**
     * Designed for recreating virtual files from deleted files where the only information we have is the file's former location
     * Any use of MetadataResolver was trying to access the non-existent files and throwing
     *
     * @param paths full paths to files
     * @returns VirtualTreeContainer
     */
    static fromFilePaths(paths: string[]): VirtualTreeContainer;
    isDirectory(fsPath: string): boolean;
    exists(fsPath: string): boolean;
    readDirectory(fsPath: string): string[];
    readFile(fsPath: SourcePath): Promise<Buffer>;
    readFileSync(fsPath: SourcePath): Buffer;
    stream(fsPath: string): Readable;
    private populate;
}
