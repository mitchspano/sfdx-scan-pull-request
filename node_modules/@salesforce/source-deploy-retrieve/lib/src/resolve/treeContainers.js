"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VirtualTreeContainer = exports.ZipTreeContainer = exports.NodeFSTreeContainer = exports.TreeContainer = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path_1 = require("path");
const graceful_fs_1 = require("graceful-fs");
const unzipper = require("unzipper");
const core_1 = require("@salesforce/core");
const utils_1 = require("../utils");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/source-deploy-retrieve', 'sdr', [
    'error_no_directory_stream',
    'error_expected_file_path',
    'error_expected_directory_path',
    'error_path_not_found',
]);
/**
 * A container for interacting with a file system. Operations such as component resolution,
 * conversion, and packaging perform I/O against `TreeContainer` abstractions.
 *
 * Extend this base class to implement a custom container.
 */
class TreeContainer {
    /**
     * Searches for a metadata component file in a container directory.
     *
     * @param fileType - The type of component file
     * @param name - The name of the file without a suffix
     * @param directory - The directory to search in
     * @returns The first path that meets the criteria, or `undefined` if none were found
     */
    find(fileType, name, directory) {
        const fileName = this.readDirectory(directory).find((entry) => {
            const parsed = (0, utils_1.parseMetadataXml)((0, path_1.join)(directory, entry));
            const metaXmlCondition = fileType === 'metadataXml' ? !!parsed : !parsed;
            return (0, utils_1.baseName)(entry) === name && metaXmlCondition;
        });
        if (fileName) {
            return (0, path_1.join)(directory, fileName);
        }
    }
}
exports.TreeContainer = TreeContainer;
/**
 * A {@link TreeContainer} that wraps the NodeJS `fs` module.
 */
class NodeFSTreeContainer extends TreeContainer {
    isDirectory(fsPath) {
        // use stat instead of lstat to follow symlinks
        return (0, graceful_fs_1.statSync)(fsPath).isDirectory();
    }
    exists(fsPath) {
        return (0, graceful_fs_1.existsSync)(fsPath);
    }
    readDirectory(fsPath) {
        return (0, graceful_fs_1.readdirSync)(fsPath);
    }
    readFile(fsPath) {
        // significant enough performance increase using sync instead of fs.promise version
        return Promise.resolve((0, graceful_fs_1.readFileSync)(fsPath));
    }
    readFileSync(fsPath) {
        return (0, graceful_fs_1.readFileSync)(fsPath);
    }
    stream(fsPath) {
        return (0, graceful_fs_1.createReadStream)(fsPath);
    }
}
exports.NodeFSTreeContainer = NodeFSTreeContainer;
/**
 * A {@link TreeContainer} that utilizes the central directory of a zip file
 * to perform I/O without unzipping it to the disk first.
 */
class ZipTreeContainer extends TreeContainer {
    constructor(directory) {
        super();
        this.tree = new Map();
        this.populate(directory);
    }
    /**
     * Creates a `ZipTreeContainer` from a Buffer of a zip file.
     *
     * @param buffer - Buffer of the zip file
     * @returns A Promise of a `ZipTreeContainer`
     */
    static async create(buffer) {
        const directory = await unzipper.Open.buffer(buffer);
        return new ZipTreeContainer(directory);
    }
    exists(fsPath) {
        return this.tree.has(fsPath);
    }
    isDirectory(fsPath) {
        if (this.exists(fsPath)) {
            return Array.isArray(this.tree.get(fsPath));
        }
        throw new core_1.SfError(messages.getMessage('error_path_not_found', [fsPath]), 'LibraryError');
    }
    readDirectory(fsPath) {
        if (this.isDirectory(fsPath)) {
            return this.tree.get(fsPath).map((entry) => (0, path_1.basename)(entry.path));
        }
        throw new core_1.SfError(messages.getMessage('error_expected_directory_path', [fsPath]), 'LibraryError');
    }
    readFile(fsPath) {
        if (!this.isDirectory(fsPath)) {
            return this.tree.get(fsPath).buffer();
        }
        throw new core_1.SfError(messages.getMessage('error_expected_file_path', [fsPath]), 'LibraryError');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    readFileSync(fsPath) {
        throw new Error('Method not implemented');
    }
    stream(fsPath) {
        if (!this.isDirectory(fsPath)) {
            return this.tree.get(fsPath).stream();
        }
        throw new core_1.SfError(messages.getMessage('error_no_directory_stream', [this.constructor.name]), 'LibraryError');
    }
    populate(directory) {
        for (const { path, type, stream, buffer } of directory.files) {
            if (type === 'File') {
                // normalize path to use OS separator since zip entries always use forward slash
                const entry = { path: (0, path_1.normalize)(path), stream, buffer };
                this.tree.set(entry.path, entry);
                this.ensureDirPathExists(entry);
            }
        }
    }
    ensureDirPathExists(entry) {
        const dirPath = (0, path_1.dirname)(entry.path);
        if (dirPath === entry.path) {
            return;
        }
        else if (!this.exists(dirPath)) {
            this.tree.set(dirPath, [entry]);
            this.ensureDirPathExists({ path: dirPath });
        }
        else {
            this.tree.get(dirPath).push(entry);
        }
    }
}
exports.ZipTreeContainer = ZipTreeContainer;
/**
 * A {@link TreeContainer} useful for mocking a file system.
 */
class VirtualTreeContainer extends TreeContainer {
    constructor(virtualFs) {
        super();
        this.tree = new Map();
        this.fileContents = new Map();
        this.populate(virtualFs);
    }
    /**
     * Designed for recreating virtual files from deleted files where the only information we have is the file's former location
     * Any use of MetadataResolver was trying to access the non-existent files and throwing
     *
     * @param paths full paths to files
     * @returns VirtualTreeContainer
     */
    static fromFilePaths(paths) {
        // a map to reduce array iterations
        const virtualDirectoryByFullPath = new Map();
        paths.map((filename) => {
            const splits = filename.split(path_1.sep);
            for (let i = 0; i < splits.length - 1; i++) {
                const fullPathSoFar = splits.slice(0, i + 1).join(path_1.sep);
                const existing = virtualDirectoryByFullPath.get(fullPathSoFar);
                virtualDirectoryByFullPath.set(fullPathSoFar, {
                    dirPath: fullPathSoFar,
                    // only add to children if we don't already have it
                    children: Array.from(new Set(existing?.children ?? []).add(splits[i + 1])),
                });
            }
        });
        return new VirtualTreeContainer(Array.from(virtualDirectoryByFullPath.values()));
    }
    isDirectory(fsPath) {
        if (this.exists(fsPath)) {
            return this.tree.has(fsPath);
        }
        throw new core_1.SfError(messages.getMessage('error_path_not_found', [fsPath]), 'LibraryError');
    }
    exists(fsPath) {
        const files = this.tree.get((0, path_1.dirname)(fsPath));
        const isFile = files && files.has(fsPath);
        return isFile || this.tree.has(fsPath);
    }
    readDirectory(fsPath) {
        if (this.isDirectory(fsPath)) {
            return Array.from(this.tree.get(fsPath)).map((p) => (0, path_1.basename)(p));
        }
        throw new core_1.SfError(messages.getMessage('error_expected_directory_path', [fsPath]), 'LibraryError');
    }
    readFile(fsPath) {
        return Promise.resolve(this.readFileSync(fsPath));
    }
    readFileSync(fsPath) {
        if (this.exists(fsPath)) {
            let data = this.fileContents.get(fsPath);
            if (!data) {
                data = Buffer.from('');
                this.fileContents.set(fsPath, data);
            }
            return data;
        }
        throw new core_1.SfError(messages.getMessage('error_path_not_found', [fsPath]), 'LibraryError');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    stream(fsPath) {
        throw new Error('Method not implemented');
    }
    populate(virtualFs) {
        for (const dir of virtualFs) {
            const { dirPath, children } = dir;
            this.tree.set(dirPath, new Set());
            for (const child of children) {
                let childPath;
                let childData;
                if (typeof child === 'string') {
                    childPath = (0, path_1.join)(dirPath, child);
                }
                else {
                    childPath = (0, path_1.join)(dirPath, child.name);
                    childData = child.data;
                }
                this.tree.get(dirPath).add(childPath);
                if (childData) {
                    this.fileContents.set(childPath, childData);
                }
            }
        }
    }
}
exports.VirtualTreeContainer = VirtualTreeContainer;
//# sourceMappingURL=treeContainers.js.map