"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManifestResolver = void 0;
const fast_xml_parser_1 = require("fast-xml-parser");
const registry_1 = require("../registry");
const utils_1 = require("../utils");
const treeContainers_1 = require("./treeContainers");
/**
 * Resolve MetadataComponents from a manifest file (package.xml)
 */
class ManifestResolver {
    constructor(tree = new treeContainers_1.NodeFSTreeContainer(), registry = new registry_1.RegistryAccess()) {
        this.tree = tree;
        this.registry = registry;
    }
    async resolve(manifestPath) {
        const components = [];
        const file = await this.tree.readFile(manifestPath);
        const parsedManifest = (0, fast_xml_parser_1.parse)(file.toString(), {
            stopNodes: ['version'],
        }).Package;
        const packageTypeMembers = (0, utils_1.normalizeToArray)(parsedManifest.types);
        const apiVersion = parsedManifest.version;
        for (const typeMembers of packageTypeMembers) {
            const typeName = typeMembers.name;
            const type = this.registry.getTypeByName(typeName);
            const parentType = type.folderType ? this.registry.getTypeByName(type.folderType) : undefined;
            const members = (0, utils_1.normalizeToArray)(typeMembers.members);
            for (const fullName of members) {
                let mdType = type;
                if (this.isNestedInFolder(fullName, type, parentType, members)) {
                    mdType = parentType;
                }
                components.push({ fullName, type: mdType });
            }
        }
        return { components, apiVersion };
    }
    // Use the folderType instead of the type from the manifest when:
    //  1. InFolder types: (report, dashboard, emailTemplate, document)
    //    1a. type.inFolder === true (from metadataRegistry.json) AND
    //    1b. The fullName doesn't contain a forward slash character AND
    //    1c. The fullName with a slash appended is contained in another member entry
    // OR
    //  2. Non-InFolder, folder types: (territory2, territory2Model, territory2Type, territory2Rule)
    //    2a. type.inFolder !== true (from metadataRegistry.json) AND
    //    2b. type.folderType has a value (from metadataRegistry.json) AND
    //    2c. This type's parent type has a folderType that doesn't match its ID.
    isNestedInFolder(fullName, type, parentType, members) {
        // Quick short-circuit for non-folderTypes
        if (!type.folderType) {
            return false;
        }
        const isInFolderType = type.inFolder;
        const isNestedInFolder = !fullName.includes('/') || members.some((m) => m.includes(`${fullName}/`));
        const isNonMatchingFolder = parentType && parentType.folderType !== parentType.id;
        return (isInFolderType && isNestedInFolder) || (!isInFolderType && isNonMatchingFolder);
    }
}
exports.ManifestResolver = ManifestResolver;
//# sourceMappingURL=manifestResolver.js.map