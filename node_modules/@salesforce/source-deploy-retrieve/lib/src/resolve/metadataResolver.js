"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataResolver = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path_1 = require("path");
const core_1 = require("@salesforce/core");
const utils_1 = require("../utils");
const registry_1 = require("../registry");
const common_1 = require("../common");
const sourceAdapterFactory_1 = require("./adapters/sourceAdapterFactory");
const forceIgnore_1 = require("./forceIgnore");
const treeContainers_1 = require("./treeContainers");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/source-deploy-retrieve', 'sdr', [
    'error_path_not_found',
    'error_could_not_infer_type',
]);
/**
 * Resolver for metadata type and component objects.
 *
 * @internal
 */
class MetadataResolver {
    /**
     * @param registry Custom registry data
     * @param tree `TreeContainer` to traverse with
     */
    constructor(registry = new registry_1.RegistryAccess(), tree = new treeContainers_1.NodeFSTreeContainer(), useFsForceIgnore = true) {
        this.registry = registry;
        this.tree = tree;
        this.useFsForceIgnore = useFsForceIgnore;
        this.sourceAdapterFactory = new sourceAdapterFactory_1.SourceAdapterFactory(this.registry, tree);
        this.forceIgnoredPaths = new Set();
    }
    /**
     * Get the metadata component(s) from a file path.
     *
     * @param fsPath File path to metadata or directory
     * @param inclusiveFilter Set to filter which components are resolved
     */
    getComponentsFromPath(fsPath, inclusiveFilter) {
        if (!this.tree.exists(fsPath)) {
            throw new core_1.SfError(messages.getMessage('error_path_not_found', [fsPath]), 'TypeInferenceError');
        }
        // use the default ignore if we aren't using a real one
        this.forceIgnore = this.useFsForceIgnore ? forceIgnore_1.ForceIgnore.findAndCreate(fsPath) : new forceIgnore_1.ForceIgnore();
        if (this.tree.isDirectory(fsPath) && !this.resolveDirectoryAsComponent(fsPath)) {
            return this.getComponentsFromPathRecursive(fsPath, inclusiveFilter);
        }
        const component = this.resolveComponent(fsPath, true);
        return component ? [component] : [];
    }
    getComponentsFromPathRecursive(dir, inclusiveFilter) {
        const dirQueue = [];
        const components = [];
        const ignore = new Set();
        if (this.forceIgnore.denies(dir)) {
            return components;
        }
        for (const file of this.tree.readDirectory(dir)) {
            const fsPath = (0, path_1.join)(dir, file);
            if (ignore.has(fsPath)) {
                continue;
            }
            if (this.tree.isDirectory(fsPath)) {
                if (this.resolveDirectoryAsComponent(fsPath)) {
                    const component = this.resolveComponent(fsPath, true);
                    if (component && (!inclusiveFilter || inclusiveFilter.has(component))) {
                        components.push(component);
                        ignore.add(component.xml);
                    }
                }
                else {
                    dirQueue.push(fsPath);
                }
            }
            else if (this.isMetadata(fsPath)) {
                const component = this.resolveComponent(fsPath, false);
                if (component) {
                    if (!inclusiveFilter || inclusiveFilter.has(component)) {
                        components.push(component);
                        ignore.add(component.content);
                    }
                    else {
                        for (const child of component.getChildren()) {
                            if (inclusiveFilter.has(child)) {
                                components.push(child);
                            }
                        }
                    }
                    // don't traverse further if not in a root type directory. performance optimization
                    // for mixed content types and ensures we don't add duplicates of the component.
                    const typeDir = (0, path_1.basename)((0, path_1.dirname)(component.type.inFolder ? (0, path_1.dirname)(fsPath) : fsPath));
                    if (component.type.strictDirectoryName && typeDir !== component.type.directoryName) {
                        return components;
                    }
                }
            }
        }
        for (const directory of dirQueue) {
            components.push(...this.getComponentsFromPathRecursive(directory, inclusiveFilter));
        }
        return components;
    }
    resolveComponent(fsPath, isResolvingSource) {
        if (this.forceIgnore.denies(fsPath)) {
            // don't resolve the component if the path is denied
            this.forceIgnoredPaths.add(fsPath);
            return;
        }
        const type = this.resolveType(fsPath);
        if (type) {
            const adapter = this.sourceAdapterFactory.getAdapter(type, this.forceIgnore);
            // short circuit the component resolution unless this is a resolve for a
            // source path or allowed content-only path, otherwise the adapter
            // knows how to handle it
            const shouldResolve = this.parseAsRootMetadataXml(fsPath) ||
                isResolvingSource ||
                !this.parseAsContentMetadataXml(fsPath) ||
                !adapter.allowMetadataWithContent();
            return shouldResolve ? adapter.getComponent(fsPath, isResolvingSource) : undefined;
        }
        void core_1.Lifecycle.getInstance().emitTelemetry({
            eventName: 'metadata_resolver_type_inference_error',
            library: 'SDR',
            function: 'resolveComponent',
            path: fsPath,
        });
        throw new core_1.SfError(messages.getMessage('error_could_not_infer_type', [fsPath]), 'TypeInferenceError');
    }
    /**
     * Any metadata xml file (-meta.xml) is potentially a root metadata file.
     *
     * @param fsPath File path of a potential metadata xml file
     */
    parseAsRootMetadataXml(fsPath) {
        return !!(0, utils_1.parseMetadataXml)(fsPath);
    }
    resolveTypeFromStrictFolder(fsPath) {
        const pathParts = fsPath.split(path_1.sep);
        // first, filter out types that don't appear in the path
        // then iterate using for/of to allow for early break
        return this.registry
            .getStrictFolderTypes()
            .filter((type) => 
        // the type's directory is in the path, AND
        pathParts.includes(type.directoryName) &&
            // types with folders only have folder components living at the top level.
            // if the fsPath is a folder component, let a future strategy deal with it
            (!type.inFolder || (0, utils_1.parentName)(fsPath) !== type.directoryName))
            .find((type) => 
        // any of the following 3 options is considered a good match
        // mixedContent and bundles don't have a suffix to match
        ['mixedContent', 'bundle'].includes(type.strategies?.adapter) ||
            // the file suffix (in source or mdapi format) matches the type suffix we think it is
            (type.suffix && [type.suffix, `${type.suffix}${common_1.META_XML_SUFFIX}`].some((s) => fsPath.endsWith(s))) ||
            // the type has children and the file suffix (in source format) matches a child type suffix of the type we think it is
            (type.children?.types &&
                Object.values(type.children?.types)
                    .map((childType) => `${childType.suffix}${common_1.META_XML_SUFFIX}`)
                    .some((s) => fsPath.endsWith(s))));
    }
    resolveType(fsPath) {
        // attempt 1 - check if the file is part of a component that requires a strict type folder
        let resolvedType = this.resolveTypeFromStrictFolder(fsPath);
        // attempt 2 - check if it's a metadata xml file
        if (!resolvedType) {
            const parsedMetaXml = (0, utils_1.parseMetadataXml)(fsPath);
            if (parsedMetaXml) {
                resolvedType = this.registry.getTypeBySuffix(parsedMetaXml.suffix);
            }
        }
        // attempt 2.5 - test for a folder style xml file
        if (!resolvedType) {
            const metadataFolder = this.parseAsFolderMetadataXml(fsPath);
            if (metadataFolder) {
                // multiple matching directories may exist - folder components are not 'inFolder'
                resolvedType = this.registry.findType((type) => type.directoryName === metadataFolder && !type.inFolder);
            }
        }
        // attempt 3 - try treating the file extension name as a suffix
        if (!resolvedType) {
            resolvedType = this.registry.getTypeBySuffix((0, utils_1.extName)(fsPath));
        }
        return resolvedType;
    }
    /**
     * Whether or not a directory that represents a single component should be resolved as one,
     * or if it should be walked for additional components.
     *
     * If a type can be determined from a directory path, and the end part of the path isn't
     * the directoryName of the type itself, infer the path is part of a mixedContent component
     *
     * @param dirPath Path to a directory
     */
    resolveDirectoryAsComponent(dirPath) {
        let shouldResolve = true;
        const type = this.resolveType(dirPath);
        if (type) {
            const { directoryName, inFolder } = type;
            const parts = dirPath.split(path_1.sep);
            const folderOffset = inFolder ? 2 : 1;
            const typeDirectoryIndex = parts.lastIndexOf(directoryName);
            if (typeDirectoryIndex === -1 ||
                parts.length - folderOffset <= typeDirectoryIndex ||
                // ex: /lwc/folder/lwc/cmp
                this.tree.readDirectory(dirPath).includes(type.directoryName) ||
                // types with children may want to resolve them individually
                type.children) {
                shouldResolve = false;
            }
        }
        else {
            shouldResolve = false;
        }
        return shouldResolve;
    }
    /**
     * Any file with a registered suffix is potentially a content metadata file.
     *
     * @param fsPath File path of a potential content metadata file
     */
    parseAsContentMetadataXml(fsPath) {
        return !!this.registry.getTypeBySuffix((0, utils_1.extName)(fsPath));
    }
    // Get the array of directoryNames for types that have folderContentType
    getFolderContentTypeDirNames() {
        if (!this.folderContentTypeDirNames) {
            this.folderContentTypeDirNames = this.registry.getFolderContentTypes().map((t) => t.directoryName);
        }
        return this.folderContentTypeDirNames;
    }
    /**
     * Identify metadata xml for a folder component:
     * .../email/TestFolder-meta.xml
     * .../reports/foo/bar-meta.xml
     *
     * Do not match this pattern:
     * .../tabs/TestFolder.tab-meta.xml
     */
    parseAsFolderMetadataXml(fsPath) {
        let folderName;
        const match = new RegExp(/(.+)-meta\.xml/).exec((0, path_1.basename)(fsPath));
        if (match && !match[1].includes('.')) {
            const parts = fsPath.split(path_1.sep);
            if (parts.length > 1) {
                const folderContentTypesDirs = this.getFolderContentTypeDirNames();
                // check if the path contains a folder content name as a directory
                // e.g., `/reports/` and if it does return that folder name.
                folderContentTypesDirs.some((dirName) => {
                    if (fsPath.includes(`${path_1.sep}${dirName}${path_1.sep}`)) {
                        folderName = dirName;
                    }
                });
            }
        }
        return folderName;
    }
    isMetadata(fsPath) {
        return (!!(0, utils_1.parseMetadataXml)(fsPath) || this.parseAsContentMetadataXml(fsPath) || !!this.parseAsFolderMetadataXml(fsPath));
    }
}
exports.MetadataResolver = MetadataResolver;
//# sourceMappingURL=metadataResolver.js.map