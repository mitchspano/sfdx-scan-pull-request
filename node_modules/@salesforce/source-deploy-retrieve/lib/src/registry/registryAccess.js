"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegistryAccess = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
const registry_1 = require("./registry");
/**
 * Container for querying metadata registry data.
 */
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/source-deploy-retrieve', 'sdr', [
    'error_missing_child_type_definition',
    'error_missing_type_definition',
]);
class RegistryAccess {
    constructor(registry = registry_1.registry) {
        this.registry = registry;
    }
    /**
     * Query a metadata type by its name.
     *
     * @param name - Case-insensitive name of the metadata type
     * @returns The corresponding metadata type object
     */
    getTypeByName(name) {
        const lower = name.toLowerCase().trim();
        if (this.registry.childTypes[lower]) {
            const parentTypeId = this.registry.childTypes[lower];
            const childType = this.registry.types[parentTypeId].children?.types[lower];
            if (childType) {
                return childType;
            }
            throw new core_1.SfError(messages.getMessage('error_missing_child_type_definition', [parentTypeId, lower]), 'RegistryError');
        }
        if (!this.registry.types[lower]) {
            throw new core_1.SfError(messages.getMessage('error_missing_type_definition', [lower]), 'RegistryError');
        }
        // redirect via alias
        return this.registry.types[lower].aliasFor
            ? this.registry.types[this.registry.types[lower].aliasFor]
            : this.registry.types[lower];
    }
    /**
     * Query a metadata type by its file suffix.
     *
     * @param suffix - File suffix of the metadata type
     * @returns The corresponding metadata type object
     */
    getTypeBySuffix(suffix) {
        if (this.registry.suffixes[suffix]) {
            const typeId = this.registry.suffixes[suffix];
            return this.getTypeByName(typeId);
        }
    }
    /**
     * Searches for the first metadata type in the registry that returns `true`
     * for the given predicate function.
     *
     * @param predicate - Predicate to test types with
     * @returns The first metadata type object that fulfills the predicate
     */
    findType(predicate) {
        const firstMatch = Object.values(this.registry.types).find(predicate);
        return firstMatch.aliasFor ? this.registry.types[firstMatch.aliasFor] : firstMatch;
    }
    /**
     * Query the types that require a strict parent directory
     *
     * @see {@link MetadataType.strictDirectoryName}
     *
     * @returns An array of metadata type objects that require strict parent folder names
     */
    getStrictFolderTypes() {
        if (!this.strictFolderTypes) {
            this.strictFolderTypes = Object.values(this.registry.strictDirectoryNames).map((typeId) => this.registry.types[typeId]);
        }
        return this.strictFolderTypes;
    }
    /**
     * Query for the types that have the folderContentType property defined.
     * E.g., reportFolder, dashboardFolder, documentFolder, emailFolder
     *
     * @see {@link MetadataType.folderContentType}
     *
     * @returns An array of metadata type objects that have folder content
     */
    getFolderContentTypes() {
        if (!this.folderContentTypes) {
            this.folderContentTypes = Object.values(this.registry.types).filter((type) => type.folderContentType && !type.aliasFor);
        }
        return this.folderContentTypes;
    }
    /**
     * Query for the types that have the aliasFor property defined.
     * E.g., EmailTemplateFolder
     *
     * @see {@link MetadataType.aliasFor}
     *
     * @returns An array of metadata type objects that have aliasFor
     */
    getAliasTypes() {
        if (!this.aliasTypes) {
            this.aliasTypes = Object.values(this.registry.types).filter((type) => type.aliasFor);
        }
        return this.aliasTypes;
    }
}
exports.RegistryAccess = RegistryAccess;
//# sourceMappingURL=registryAccess.js.map