/// <reference types="node" />
/// <reference types="node" />
import { pipeline as cbPipeline, Readable, Stream, Transform, Writable } from 'stream';
import { JsonMap } from '@salesforce/ts-types';
import { MetadataResolver, SourceComponent } from '../resolve';
import { SourcePath } from '../common';
import { ComponentSet } from '../collections';
import { RegistryAccess } from '../registry';
import { ConvertContext } from './convertContext';
import { SfdxFileFormat, WriterFormat } from './types';
export declare const pipeline: typeof cbPipeline.__promisify__;
export declare const stream2buffer: (stream: Stream) => Promise<Buffer>;
export declare class ComponentReader extends Readable {
    private iter;
    constructor(components: Iterable<SourceComponent>);
    _read(): void;
    private createIterator;
}
export declare class ComponentConverter extends Transform {
    readonly context: ConvertContext;
    private targetFormat;
    private mergeSet;
    private transformerFactory;
    private defaultDirectory;
    constructor(targetFormat: SfdxFileFormat, registry: RegistryAccess, mergeSet?: ComponentSet, defaultDirectory?: string);
    _transform(chunk: SourceComponent, encoding: string, callback: (err: Error, data: WriterFormat) => void): Promise<void>;
    /**
     * Called at the end when all components have passed through the pipeline. Finalizers
     * take care of any additional work to be done at this stage e.g. recomposing child components.
     */
    _flush(callback: (err: Error, data?: WriterFormat) => void): Promise<void>;
}
export declare abstract class ComponentWriter extends Writable {
    forceIgnoredPaths?: Set<string>;
    protected rootDestination?: SourcePath;
    constructor(rootDestination?: SourcePath);
}
export declare class StandardWriter extends ComponentWriter {
    converted: SourceComponent[];
    private resolver;
    private logger;
    constructor(rootDestination: SourcePath, resolver?: MetadataResolver);
    _write(chunk: WriterFormat, encoding: string, callback: (err?: Error) => void): Promise<void>;
}
export declare class ZipWriter extends ComponentWriter {
    private zip;
    private buffers;
    constructor(rootDestination?: SourcePath);
    _write(chunk: WriterFormat, encoding: string, callback: (err?: Error) => void): Promise<void>;
    _final(callback: (err?: Error) => void): Promise<void>;
    addToZip(contents: string | Readable | Buffer, path: SourcePath): void;
    private getOutputStream;
    get buffer(): Buffer | undefined;
}
/**
 * Convenient wrapper to serialize a js object to XML content. Implemented as a stream
 * to be used as a valid source for ComponentWriters in the conversion pipeline,
 * even though it's not beneficial in the typical way a stream is.
 */
export declare class JsToXml extends Readable {
    private xmlObject;
    constructor(xmlObject: JsonMap);
    _read(): void;
}
