import { JsonMap } from '@salesforce/ts-types';
import { ComponentSet } from '../collections';
import { MetadataComponent, SourceComponent, NodeFSTreeContainer, TreeContainer } from '../resolve';
import { WriteInfo, WriterFormat } from './types';
declare abstract class ConvertTransactionFinalizer<T> {
    protected abstract transactionState: T;
    setState(props: (state: T) => void): void;
    get state(): T;
    abstract finalize(defaultDirectory?: string): Promise<WriterFormat[]>;
}
export interface RecompositionState {
    [componentKey: string]: {
        /**
         * Parent component that children are rolled up into
         */
        component?: SourceComponent;
        /**
         * Children to be rolled up into the parent file
         */
        children?: ComponentSet;
    };
}
/**
 * Merges child components that share the same parent in the conversion pipeline
 * into a single file.
 */
declare class RecompositionFinalizer extends ConvertTransactionFinalizer<RecompositionState> {
    protected transactionState: RecompositionState;
    private parsedXmlCache;
    finalize(): Promise<WriterFormat[]>;
    private recompose;
}
export interface DecompositionState {
    [componentKey: string]: {
        foundMerge?: boolean;
        writeInfo?: WriteInfo;
        origin?: MetadataComponent;
    };
}
/**
 * Creates write infos for any children that haven't been written yet. Children may
 * delay being written in order to find potential existing children to merge
 * with in the conversion pipeline.
 */
declare class DecompositionFinalizer extends ConvertTransactionFinalizer<DecompositionState> {
    protected transactionState: DecompositionState;
    finalize(): Promise<WriterFormat[]>;
}
export interface NonDecompositionState {
    childrenByUniqueElement: Map<string, JsonMap>;
    exampleComponent: SourceComponent;
}
/**
 * Merges child components that share the same parent in the conversion pipeline
 * into a single file.
 *
 * Inserts unclaimed child components into the parent that belongs to the default package
 */
declare class NonDecompositionFinalizer extends ConvertTransactionFinalizer<NonDecompositionState> {
    protected transactionState: NonDecompositionState;
    protected mergeMap: Map<string, Map<string, JsonMap>>;
    protected parentComponentMap: Map<string, SourceComponent>;
    protected tree: TreeContainer;
    finalize(defaultDirectory: string, tree?: NodeFSTreeContainer): Promise<WriterFormat[]>;
    private initChildMapping;
    /**
     * check both top-level maps and make sure there are defaults
     */
    private ensureDefaults;
    /**
     * Returns all the components of the incoming type in the project.
     *
     * Some components are not resolved during component resolution.
     * This typically only happens when a specific source path was resolved. This is problematic for
     * nondecomposed metadata types (like CustomLabels) because we need to know the location of each
     * child type before recomposing the final xml.
     * The labels could belong in any of the files OR need to go in the default location which already contains labels
     */
    private getAllComponentsOfType;
    /**
     * Populate the mergeMap with all the children of all the local components
     */
    private initMergeMap;
    /**
     * Return a json object that's built up from the mergeMap children
     */
    private recompose;
    /**
     * Return the default filepath for new metadata of this type
     */
    private getDefaultOutput;
}
/**
 * A state manager over the course of a single metadata conversion call.
 */
export declare class ConvertContext {
    readonly decomposition: DecompositionFinalizer;
    readonly recomposition: RecompositionFinalizer;
    readonly nonDecomposition: NonDecompositionFinalizer;
    executeFinalizers(defaultDirectory?: string): AsyncIterable<WriterFormat[]>;
}
export {};
