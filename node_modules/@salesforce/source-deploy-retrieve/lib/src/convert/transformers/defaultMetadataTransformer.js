"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultMetadataTransformer = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path_1 = require("path");
const common_1 = require("../../common");
const utils_1 = require("../../utils");
const baseMetadataTransformer_1 = require("./baseMetadataTransformer");
const ORIGINAL_SUFFIX_REGEX = new RegExp('(.)([a-zA-Z]+)(' + common_1.META_XML_SUFFIX + ')$');
/**
 * The default metadata transformer.
 *
 * If a metadata type doesn't have a transformer assigned to it, this one is used
 * during the conversion process. It leaves the component's metadata xml and source
 * files as-is.
 */
class DefaultMetadataTransformer extends baseMetadataTransformer_1.BaseMetadataTransformer {
    // eslint-disable-next-line @typescript-eslint/require-await
    async toMetadataFormat(component) {
        return this.getWriteInfos(component, 'metadata');
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async toSourceFormat(component, mergeWith) {
        return this.getWriteInfos(component, 'source', mergeWith);
    }
    getWriteInfos(component, targetFormat, mergeWith) {
        const writeInfos = [];
        if (component.content) {
            for (const source of component.walkContent()) {
                writeInfos.push({
                    source: component.tree.stream(source),
                    output: this.getContentSourceDestination(source, targetFormat, component, mergeWith),
                });
            }
        }
        if (component.xml) {
            writeInfos.push({
                source: component.tree.stream(component.xml),
                output: this.getXmlDestination(targetFormat, component, mergeWith),
            });
        }
        return writeInfos;
    }
    // assumes component has content
    getContentSourceDestination(source, targetFormat, component, mergeWith) {
        if (mergeWith?.content) {
            if (component.tree.isDirectory(component.content)) {
                const relative = (0, utils_1.trimUntil)(source, (0, path_1.basename)(component.content));
                return (0, path_1.join)((0, path_1.dirname)(mergeWith.content), relative);
            }
            return mergeWith.content;
        }
        return component.getPackageRelativePath(source, targetFormat);
    }
    // assumes component has xml
    getXmlDestination(targetFormat, component, mergeWith) {
        if (mergeWith?.xml && targetFormat === 'source') {
            return mergeWith.xml;
        }
        const { folderContentType, suffix, legacySuffix } = component.type;
        let xmlDestination = component.getPackageRelativePath(component.xml, targetFormat);
        // quirks:
        // - append or strip the -meta.xml suffix to the path if there's no content
        //  for folder components:
        //    - remove file extension but preserve -meta.xml suffix if folder type and to 'metadata format'
        //    - insert file extension behind the -meta.xml suffix if folder type and to 'source format'
        if (!component.content) {
            if (targetFormat === 'metadata') {
                xmlDestination = folderContentType
                    ? xmlDestination.replace(`.${suffix}`, '')
                    : xmlDestination.slice(0, xmlDestination.lastIndexOf(common_1.META_XML_SUFFIX));
            }
            else {
                xmlDestination = folderContentType
                    ? xmlDestination.replace(common_1.META_XML_SUFFIX, `.${suffix}${common_1.META_XML_SUFFIX}`)
                    : `${xmlDestination}${common_1.META_XML_SUFFIX}`;
            }
        }
        else if (suffix) {
            if (component.type.name === 'Document' && targetFormat === 'metadata') {
                xmlDestination = xmlDestination.replace(new RegExp('.' + suffix + common_1.META_XML_SUFFIX + '$'), '.' + (0, utils_1.extName)(component.content) + common_1.META_XML_SUFFIX);
            }
            else {
                xmlDestination = xmlDestination.replace(ORIGINAL_SUFFIX_REGEX, '.' + suffix + common_1.META_XML_SUFFIX);
            }
        }
        if (legacySuffix && suffix && xmlDestination.includes(legacySuffix)) {
            xmlDestination = xmlDestination.replace(legacySuffix, suffix);
        }
        return xmlDestination;
    }
}
exports.DefaultMetadataTransformer = DefaultMetadataTransformer;
//# sourceMappingURL=defaultMetadataTransformer.js.map