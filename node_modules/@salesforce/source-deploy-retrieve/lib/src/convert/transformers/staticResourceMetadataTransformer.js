"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StaticResourceMetadataTransformer = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path_1 = require("path");
const archiver_1 = require("archiver");
const mime_1 = require("mime");
const unzipper_1 = require("unzipper");
const graceful_fs_1 = require("graceful-fs");
const core_1 = require("@salesforce/core");
const utils_1 = require("../../utils");
const fileSystemHandler_1 = require("../../utils/fileSystemHandler");
const streams_1 = require("../streams");
const baseMetadataTransformer_1 = require("./baseMetadataTransformer");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/source-deploy-retrieve', 'sdr', [
    'error_static_resource_expected_archive_type',
    'error_static_resource_missing_resource_file',
]);
class StaticResourceMetadataTransformer extends baseMetadataTransformer_1.BaseMetadataTransformer {
    async toMetadataFormat(component) {
        const { content, type, xml } = component;
        let contentSource;
        if (await this.componentIsExpandedArchive(component)) {
            // toolbelt was using level 9 for static resources, so we'll do the same.
            // Otherwise, you'll see errors like https://github.com/forcedotcom/cli/issues/1098
            const zip = (0, archiver_1.create)('zip', { zlib: { level: 9 } });
            zip.directory(content, false);
            void zip.finalize();
            contentSource = zip;
        }
        else {
            contentSource = component.tree.stream(content);
        }
        return [
            {
                source: contentSource,
                output: (0, path_1.join)(type.directoryName, `${(0, utils_1.baseName)(content)}.${type.suffix}`),
            },
            {
                source: component.tree.stream(xml),
                output: (0, path_1.join)(type.directoryName, (0, path_1.basename)(xml)),
            },
        ];
    }
    async toSourceFormat(component, mergeWith) {
        const { xml, content } = component;
        if (!content) {
            return [];
        }
        const componentContentType = await this.getContentType(component);
        const mergeContentPath = mergeWith?.content;
        const baseContentPath = this.getBaseContentPath(component, mergeWith);
        // only unzip an archive component if there isn't a merge component, or the merge component is itself expanded
        const shouldUnzipArchive = StaticResourceMetadataTransformer.ARCHIVE_MIME_TYPES.has(componentContentType) &&
            (!mergeWith || mergeWith.tree.isDirectory(mergeContentPath));
        if (shouldUnzipArchive) {
            // for the bulk of static resource writing we'll start writing ASAP
            // we'll still defer writing the resource-meta.xml file by pushing it onto the writeInfos
            await Promise.all((await unzipper_1.Open.buffer(await component.tree.readFile(content))).files
                .filter((f) => f.type === 'File')
                .map(async (f) => {
                const path = (0, path_1.join)(baseContentPath, f.path);
                const fullDest = (0, path_1.isAbsolute)(path)
                    ? path
                    : (0, path_1.join)(this.defaultDirectory || component.getPackageRelativePath('', 'source'), path);
                // push onto the pipeline and start writing now
                return this.pipeline(f.stream(), fullDest);
            }));
        }
        return [
            {
                source: component.tree.stream(xml),
                output: mergeWith?.xml || component.getPackageRelativePath((0, path_1.basename)(xml), 'source'),
            },
        ].concat(shouldUnzipArchive
            ? []
            : [
                {
                    source: component.tree.stream(content),
                    output: `${baseContentPath}.${this.getExtensionFromType(componentContentType)}`,
                },
            ]);
    }
    /**
     * Only separated into its own method for unit testing purposes
     * I was unable to find a way to stub/spy a pipline() call
     *
     * @param stream the data to be written
     * @param destination the destination path to be written
     * @private
     */
    async pipeline(stream, destination) {
        (0, fileSystemHandler_1.ensureFileExists)(destination);
        await (0, streams_1.pipeline)(stream, (0, graceful_fs_1.createWriteStream)(destination));
    }
    getBaseContentPath(component, mergeWith) {
        const baseContentPath = mergeWith?.content || component.getPackageRelativePath(component.content, 'source');
        return (0, path_1.join)((0, path_1.dirname)(baseContentPath), (0, utils_1.baseName)(baseContentPath));
    }
    /**
     * "Expanded" refers to a component whose content file is a zip file, and its current
     * state is unzipped.
     */
    async componentIsExpandedArchive(component) {
        const { content, tree } = component;
        if (tree.isDirectory(content)) {
            const contentType = await this.getContentType(component);
            if (StaticResourceMetadataTransformer.ARCHIVE_MIME_TYPES.has(contentType)) {
                return true;
            }
            throw new core_1.SfError(messages.getMessage('error_static_resource_expected_archive_type', [contentType, component.name]), 'LibraryError');
        }
        return false;
    }
    async getContentType(component) {
        const resource = (await component.parseXml()).StaticResource;
        if (!resource || !Object.prototype.hasOwnProperty.call(resource, 'contentType')) {
            throw new core_1.SfError(messages.getMessage('error_static_resource_missing_resource_file', [(0, path_1.join)('staticresources', component.name)]), 'LibraryError');
        }
        return resource.contentType;
    }
    getExtensionFromType(contentType) {
        // return registered ext, fallback, or the default (application/octet-stream -> bin)
        return ((0, mime_1.getExtension)(contentType) ||
            StaticResourceMetadataTransformer.FALLBACK_TYPE_MAP.get(contentType) ||
            (0, mime_1.getExtension)(StaticResourceMetadataTransformer.DEFAULT_CONTENT_TYPE));
    }
}
exports.StaticResourceMetadataTransformer = StaticResourceMetadataTransformer;
StaticResourceMetadataTransformer.ARCHIVE_MIME_TYPES = new Set([
    'application/zip',
    'application/x-zip-compressed',
    'application/jar',
]);
StaticResourceMetadataTransformer.DEFAULT_CONTENT_TYPE = 'application/octet-stream';
StaticResourceMetadataTransformer.FALLBACK_TYPE_MAP = new Map([
    ['text/javascript', 'js'],
    ['application/x-javascript', 'js'],
    ['application/x-zip-compressed', 'zip'],
    ['text/x-haml', 'haml'],
    ['image/x-png', 'png'],
    ['text/xml', 'xml'],
]);
//# sourceMappingURL=staticResourceMetadataTransformer.js.map