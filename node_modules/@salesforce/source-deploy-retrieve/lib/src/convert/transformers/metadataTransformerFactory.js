"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataTransformerFactory = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
const convertContext_1 = require("../convertContext");
const defaultMetadataTransformer_1 = require("./defaultMetadataTransformer");
const decomposedMetadataTransformer_1 = require("./decomposedMetadataTransformer");
const staticResourceMetadataTransformer_1 = require("./staticResourceMetadataTransformer");
const nonDecomposedMetadataTransformer_1 = require("./nonDecomposedMetadataTransformer");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/source-deploy-retrieve', 'sdr', ['error_missing_transformer']);
class MetadataTransformerFactory {
    constructor(registry, context = new convertContext_1.ConvertContext()) {
        this.registry = registry;
        this.context = context;
    }
    getTransformer(component) {
        // transformer is determined by the parent, if the component has one
        const type = component.parent ? component.parent.type : component.type;
        const transformerId = type.strategies?.transformer;
        switch (transformerId) {
            case "standard" /* TransformerStrategy.Standard */:
            case undefined:
                return new defaultMetadataTransformer_1.DefaultMetadataTransformer(this.registry, this.context);
            case "decomposed" /* TransformerStrategy.Decomposed */:
                return new decomposedMetadataTransformer_1.DecomposedMetadataTransformer(this.registry, this.context);
            case "staticResource" /* TransformerStrategy.StaticResource */:
                return new staticResourceMetadataTransformer_1.StaticResourceMetadataTransformer(this.registry, this.context);
            case "nonDecomposed" /* TransformerStrategy.NonDecomposed */:
                return new nonDecomposedMetadataTransformer_1.NonDecomposedMetadataTransformer(this.registry, this.context);
            default:
                throw new core_1.SfError(messages.getMessage('error_missing_transformer', [type.name, transformerId]), 'RegistryError');
        }
    }
}
exports.MetadataTransformerFactory = MetadataTransformerFactory;
//# sourceMappingURL=metadataTransformerFactory.js.map