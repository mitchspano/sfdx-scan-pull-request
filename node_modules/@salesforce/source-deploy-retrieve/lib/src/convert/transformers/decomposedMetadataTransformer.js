"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DecomposedMetadataTransformer = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path_1 = require("path");
const streams_1 = require("../streams");
const common_1 = require("../../common");
const collections_1 = require("../../collections");
const utils_1 = require("../../utils");
const baseMetadataTransformer_1 = require("./baseMetadataTransformer");
class DecomposedMetadataTransformer extends baseMetadataTransformer_1.BaseMetadataTransformer {
    // eslint-disable-next-line @typescript-eslint/require-await
    async toMetadataFormat(component) {
        if (component.parent) {
            const { fullName: parentName } = component.parent;
            this.context.recomposition.setState((state) => {
                if (state[parentName]) {
                    state[parentName].children.add(component);
                }
                else {
                    state[parentName] = {
                        component: component.parent,
                        children: new collections_1.ComponentSet([component], this.registry),
                    };
                }
            });
        }
        else {
            const { fullName } = component;
            this.context.recomposition.setState((state) => {
                if (!state[fullName]) {
                    state[fullName] = { component, children: new collections_1.ComponentSet([], this.registry) };
                }
                const children = component.getChildren();
                if (children) {
                    children.map((child) => {
                        state[fullName].children.add(child);
                    });
                }
            });
        }
        // noop since the finalizer will push the writes to the component writer
        return [];
    }
    async toSourceFormat(component, mergeWith) {
        const writeInfos = [];
        const childrenOfMergeComponent = new collections_1.ComponentSet(mergeWith?.getChildren());
        const { type, fullName: parentFullName } = component;
        const forceIgnore = component.getForceIgnore();
        let parentXmlObject;
        const composedMetadata = await this.getComposedMetadataEntries(component);
        for (const [tagKey, tagValue] of composedMetadata) {
            const childTypeId = type.children?.directories[tagKey];
            if (childTypeId) {
                const childType = type.children.types[childTypeId];
                const tagValues = (0, utils_1.normalizeToArray)(tagValue);
                for (const value of tagValues) {
                    const entryName = value.fullName || value.name;
                    const childComponent = {
                        fullName: `${parentFullName}.${entryName}`,
                        type: childType,
                        parent: component,
                    };
                    // only process child types that aren't forceignored
                    if (forceIgnore.accepts(this.getDefaultOutput(childComponent))) {
                        const source = new streams_1.JsToXml({
                            [childType.name]: Object.assign({ [common_1.XML_NS_KEY]: common_1.XML_NS_URL }, value),
                        });
                        /*
                         composedMetadata is a representation of the parent's xml
                         if there is no CustomObjectTranslation in the org, the composedMetadata will be 2 entries
                         the xml declaration, and a fields attribute, which points to the child CustomObjectFieldTranslation
                         because CustomObjectFieldTranslation is the only metadata type with 'requiresParent' = true we can
                         calculate if a CustomObjectTranslation was retrieved from the org (composedMetadata.length > 2), or,
                         if we'll have to write an empty CustomObjectTranslation file (composedMetadata.length <=2).
                         CustomObjectFieldTranslations are only addressable through their parent, and require a
                         CustomObjectTranslation file to be present
                         */
                        if (childType.unaddressableWithoutParent && composedMetadata.length <= 2) {
                            parentXmlObject = {
                                [component.type.name]: '',
                            };
                            this.setDecomposedState(childComponent, {
                                foundMerge: false,
                                writeInfo: {
                                    source: new streams_1.JsToXml(parentXmlObject),
                                    output: this.getDefaultOutput(component),
                                },
                            });
                        }
                        // if there's nothing to merge with, push write operation now to default location
                        if (!mergeWith) {
                            writeInfos.push({
                                source,
                                output: this.getDefaultOutput(childComponent),
                            });
                        }
                        // if the merge parent has a child that can be merged with, push write
                        // operation now and mark it as merged in the state
                        else if (childrenOfMergeComponent.has(childComponent)) {
                            const mergeChild = childrenOfMergeComponent.getSourceComponents(childComponent).first();
                            writeInfos.push({
                                source,
                                output: mergeChild.xml,
                            });
                            this.setDecomposedState(childComponent, { foundMerge: true });
                        }
                        // if no child component is found to merge with yet, mark it as so in
                        // the state
                        else if (!this.getDecomposedState(childComponent)?.foundMerge) {
                            this.setDecomposedState(childComponent, {
                                foundMerge: false,
                                writeInfo: {
                                    source,
                                    output: this.getDefaultOutput(childComponent),
                                },
                            });
                        }
                    }
                }
            }
            else {
                // tag entry isn't a child type, so add it to the parent xml
                if (tagKey !== common_1.XML_NS_KEY) {
                    if (!parentXmlObject) {
                        parentXmlObject = { [type.name]: { [common_1.XML_NS_KEY]: common_1.XML_NS_URL } };
                    }
                    const tagGroup = parentXmlObject[type.name];
                    tagGroup[tagKey] = tagValue;
                }
            }
        }
        const parentState = this.getDecomposedState(component);
        if (!parentState && parentXmlObject) {
            const parentSource = new streams_1.JsToXml(parentXmlObject);
            if (!mergeWith) {
                writeInfos.push({
                    source: parentSource,
                    output: this.getDefaultOutput(component),
                });
            }
            else if (mergeWith.xml) {
                writeInfos.push({
                    source: parentSource,
                    output: mergeWith.xml,
                });
                this.setDecomposedState(component, { foundMerge: true });
            }
            else if (!parentState?.foundMerge) {
                this.setDecomposedState(component, {
                    foundMerge: false,
                    writeInfo: {
                        source: parentSource,
                        output: this.getDefaultOutput(component),
                    },
                });
            }
        }
        return writeInfos;
    }
    async getComposedMetadataEntries(component) {
        const composedMetadata = (await component.parseXml())[component.type.name];
        // composedMetadata might be undefined if you call toSourceFormat() from a non-source-backed Component
        return composedMetadata ? Object.entries(composedMetadata) : [];
    }
    /**
     * Helper for setting the decomposed transaction state
     *
     * @param forComponent
     * @param props
     */
    setDecomposedState(forComponent, props = {}) {
        const key = `${forComponent.type.name}#${forComponent.fullName}`;
        const withOrigin = Object.assign({ origin: forComponent.parent ?? forComponent }, props);
        this.context.decomposition.setState((state) => {
            state[key] = Object.assign(state[key] ?? {}, withOrigin);
        });
    }
    getDecomposedState(forComponent) {
        const key = `${forComponent.type.name}#${forComponent.fullName}`;
        return this.context.decomposition.state[key];
    }
    getDefaultOutput(component) {
        const { parent, fullName, type } = component;
        const [baseName, childName] = fullName.split('.');
        const baseComponent = (parent ?? component);
        let output = `${childName ?? baseName}.${component.type.suffix}${common_1.META_XML_SUFFIX}`;
        if (parent?.type.strategies.decomposition === "folderPerType" /* DecompositionStrategy.FolderPerType */) {
            output = (0, path_1.join)(type.directoryName, output);
        }
        return (0, path_1.join)(baseComponent.getPackageRelativePath(baseName, 'source'), output);
    }
}
exports.DecomposedMetadataTransformer = DecomposedMetadataTransformer;
//# sourceMappingURL=decomposedMetadataTransformer.js.map