"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDedupedConflictsFromChanges = exports.findConflictsInComponentSet = exports.throwIfConflicts = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path_1 = require("path");
const types_1 = require("./types");
const functions_1 = require("./functions");
const populateTypesAndNames_1 = require("./populateTypesAndNames");
const throwIfConflicts = (conflicts) => {
    if (conflicts.length > 0) {
        const conflictError = new types_1.SourceConflictError(`${conflicts.length} conflicts detected`, 'SourceConflictError');
        conflictError.setData(conflicts);
        throw conflictError;
    }
};
exports.throwIfConflicts = throwIfConflicts;
/**
 *
 * @param cs ComponentSet to compare
 * @param conflicts ChangeResult[] representing conflicts from SourceTracking.getConflicts
 * @returns ConflictResponse[] de-duped and formatted for json or table display
 */
const findConflictsInComponentSet = (cs, conflicts) => {
    // map do dedupe by name-type-filename
    const conflictMap = new Map();
    conflicts
        .filter((cr) => cr.name && cr.type && cs.has({ fullName: cr.name, type: cr.type }))
        .forEach((cr) => {
        var _a;
        (_a = cr.filenames) === null || _a === void 0 ? void 0 : _a.forEach((f) => {
            conflictMap.set(`${cr.name}#${cr.type}#${f}`, {
                state: 'Conflict',
                // the following 2 type assertions are valid because of previous filter statement
                // they can be removed once TS is smarter about filtering
                fullName: cr.name,
                type: cr.type,
                filePath: (0, path_1.resolve)(f),
            });
        });
    });
    const reformattedConflicts = Array.from(conflictMap.values());
    return reformattedConflicts;
};
exports.findConflictsInComponentSet = findConflictsInComponentSet;
const getDedupedConflictsFromChanges = ({ localChanges = [], remoteChanges = [], projectPath, forceIgnore, }) => {
    // index the remoteChanges by filename
    const fileNameIndex = new Map();
    const metadataKeyIndex = new Map();
    remoteChanges.map((change) => {
        var _a;
        if (change.name && change.type) {
            metadataKeyIndex.set((0, functions_1.getMetadataKey)(change.name, change.type), change);
        }
        (_a = change.filenames) === null || _a === void 0 ? void 0 : _a.map((filename) => {
            fileNameIndex.set(filename, change);
        });
    });
    const conflicts = new Set();
    (0, populateTypesAndNames_1.populateTypesAndNames)({ elements: localChanges, excludeUnresolvable: true, projectPath, forceIgnore }).map((change) => {
        var _a;
        const metadataKey = (0, functions_1.getMetadataKey)(change.name, change.type);
        // option 1: name and type match
        if (metadataKeyIndex.has(metadataKey)) {
            conflicts.add({ ...metadataKeyIndex.get(metadataKey) });
        }
        else {
            // option 2: some of the filenames match
            (_a = change.filenames) === null || _a === void 0 ? void 0 : _a.map((filename) => {
                if (fileNameIndex.has(filename)) {
                    conflicts.add({ ...fileNameIndex.get(filename) });
                }
            });
        }
    });
    // deeply de-dupe
    return Array.from(conflicts);
};
exports.getDedupedConflictsFromChanges = getDedupedConflictsFromChanges;
//# sourceMappingURL=conflicts.js.map