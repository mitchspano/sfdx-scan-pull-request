"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShadowRepo = void 0;
const path = require("path");
const os = require("os");
const fs = require("graceful-fs");
const core_1 = require("@salesforce/core");
const git = require("isomorphic-git");
const functions_1 = require("./functions");
/** returns the full path to where we store the shadow repo */
const getGitDir = (orgId, projectPath, useSfdxTrackingFiles = false) => {
    return path.join(projectPath, useSfdxTrackingFiles ? '.sfdx' : '.sf', 'orgs', orgId, 'localSourceTracking');
};
// filenames were normalized when read from isogit
const toFilenames = (rows) => rows.map((row) => row[FILE]);
// array members for status results
const FILE = 0;
const HEAD = 1;
const WORKDIR = 2;
class ShadowRepo {
    constructor(options) {
        this.gitDir = getGitDir(options.orgId, options.projectPath, options.hasSfdxTrackingFiles);
        this.projectPath = options.projectPath;
        this.packageDirs = options.packageDirs;
        this.isWindows = os.type() === 'Windows_NT';
        this.maxFileAdd = this.isWindows ? 8000 : 15000;
    }
    // think of singleton behavior but unique to the projectPath
    static async getInstance(options) {
        if (!ShadowRepo.instanceMap.has(options.projectPath)) {
            const newInstance = new ShadowRepo(options);
            await newInstance.init();
            ShadowRepo.instanceMap.set(options.projectPath, newInstance);
        }
        return ShadowRepo.instanceMap.get(options.projectPath);
    }
    async init() {
        this.logger = await core_1.Logger.child('ShadowRepo');
        // initialize the shadow repo if it doesn't exist
        if (!fs.existsSync(this.gitDir)) {
            this.logger.debug('initializing git repo');
            await this.gitInit();
        }
    }
    /**
     * Initialize a new source tracking shadow repo.  Think of git init
     *
     */
    async gitInit() {
        await fs.promises.mkdir(this.gitDir, { recursive: true });
        await git.init({ fs, dir: this.projectPath, gitdir: this.gitDir, defaultBranch: 'main' });
    }
    /**
     * Delete the local tracking files
     *
     * @returns the deleted directory
     */
    async delete() {
        if (typeof fs.promises.rm === 'function') {
            await fs.promises.rm(this.gitDir, { recursive: true, force: true });
        }
        else {
            await fs.promises.rm(this.gitDir, { recursive: true });
        }
        return this.gitDir;
    }
    /**
     * If the status already exists, return it.  Otherwise, set the status before returning.
     * It's kinda like a cache
     *
     * @params noCache: if true, force a redo of the status using FS even if it exists
     *
     * @returns StatusRow[]
     */
    async getStatus(noCache = false) {
        if (!this.status || noCache) {
            // iso-git uses relative, posix paths
            // but packageDirs has already resolved / normalized them
            // so we need to make them project-relative again and convert if windows
            const filepaths = this.packageDirs
                .map((dir) => path.relative(this.projectPath, dir.fullPath))
                .map((p) => (this.isWindows ? p.split(path.sep).join(path.posix.sep) : p));
            // status hasn't been initalized yet
            this.status = await git.statusMatrix({
                fs,
                dir: this.projectPath,
                gitdir: this.gitDir,
                filepaths,
                ignored: true,
                filter: (f) => 
                // no hidden files
                !f.includes(`${path.sep}.`) &&
                    // no lwc tests
                    !(0, functions_1.isLwcLocalOnlyTest)(f) &&
                    // no gitignore files
                    !f.endsWith('.gitignore') &&
                    // isogit uses `startsWith` for filepaths so it's possible to get a false positive
                    filepaths.some((pkgDir) => (0, functions_1.pathIsInFolder)(f, pkgDir)),
            });
            // isomorphic-git stores things in unix-style tree.  Convert to windows-style if necessary
            if (this.isWindows) {
                this.status = this.status.map((row) => [path.normalize(row[FILE]), row[HEAD], row[WORKDIR], row[3]]);
            }
        }
        return this.status;
    }
    /**
     * returns any change (add, modify, delete)
     */
    async getChangedRows() {
        return (await this.getStatus()).filter((file) => file[HEAD] !== file[WORKDIR]);
    }
    /**
     * returns any change (add, modify, delete)
     */
    async getChangedFilenames() {
        return toFilenames(await this.getChangedRows());
    }
    async getDeletes() {
        return (await this.getStatus()).filter((file) => file[WORKDIR] === 0);
    }
    async getDeleteFilenames() {
        return toFilenames(await this.getDeletes());
    }
    /**
     * returns adds and modifies but not deletes
     */
    async getNonDeletes() {
        return (await this.getStatus()).filter((file) => file[WORKDIR] === 2);
    }
    /**
     * returns adds and modifies but not deletes
     */
    async getNonDeleteFilenames() {
        return toFilenames(await this.getNonDeletes());
    }
    async getAdds() {
        return (await this.getStatus()).filter((file) => file[HEAD] === 0 && file[WORKDIR] === 2);
    }
    async getAddFilenames() {
        return toFilenames(await this.getAdds());
    }
    /**
     * returns files that were not added or deleted, but changed locally
     */
    async getModifies() {
        return (await this.getStatus()).filter((file) => file[HEAD] === 1 && file[WORKDIR] === 2);
    }
    async getModifyFilenames() {
        return toFilenames(await this.getModifies());
    }
    /**
     * Look through status and stage all changes, then commit
     *
     * @param fileList list of files to commit (full paths)
     * @param message: commit message (include org username and id)
     *
     * @returns sha (string)
     */
    async commitChanges({ deployedFiles = [], deletedFiles = [], message = 'sfdx source tracking', needsUpdatedStatus = true, } = {}) {
        // if no files are specified, commit all changes
        if (deployedFiles.length === 0 && deletedFiles.length === 0) {
            // this is valid, might not be an error
            return 'no files to commit';
        }
        // these are stored in posix/style/path format.  We have to convert inbound stuff from windows
        if (os.type() === 'Windows_NT') {
            deployedFiles = deployedFiles.map((filepath) => path.normalize(filepath).split(path.sep).join(path.posix.sep));
            deletedFiles = deletedFiles.map((filepath) => path.normalize(filepath).split(path.sep).join(path.posix.sep));
        }
        if (deployedFiles.length) {
            const chunks = (0, functions_1.chunkArray)([...new Set(deployedFiles)], this.maxFileAdd);
            for (const chunk of chunks) {
                try {
                    // these need to be done sequentially (it's already batched) because isogit manages file locking
                    // eslint-disable-next-line no-await-in-loop
                    await git.add({
                        fs,
                        dir: this.projectPath,
                        gitdir: this.gitDir,
                        filepath: chunk,
                        force: true,
                    });
                }
                catch (e) {
                    if (e instanceof git.Errors.MultipleGitError) {
                        this.logger.error('multiple errors on git.add', e.errors.slice(0, 5));
                        const error = new core_1.SfError(e.message, e.name, [], 1);
                        error.setData(e.errors);
                        throw error;
                    }
                    throw e;
                }
            }
        }
        for (const filepath of [...new Set(deletedFiles)]) {
            // these need to be done sequentially because isogit manages file locking.  Isogit remove does not support multiple files at once
            // eslint-disable-next-line no-await-in-loop
            await git.remove({ fs, dir: this.projectPath, gitdir: this.gitDir, filepath });
        }
        const sha = await git.commit({
            fs,
            dir: this.projectPath,
            gitdir: this.gitDir,
            message,
            author: { name: 'sfdx source tracking' },
        });
        // status changed as a result of the commit.  This prevents users from having to run getStatus(true) to avoid cache
        if (needsUpdatedStatus) {
            await this.getStatus(true);
        }
        return sha;
    }
}
exports.ShadowRepo = ShadowRepo;
ShadowRepo.instanceMap = new Map();
//# sourceMappingURL=localShadowRepo.js.map