"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registrySupportsType = exports.mappingsForSourceMemberTypesToMetadataType = exports.getMetadataKeyFromFileResponse = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path_1 = require("path");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const core_1 = require("@salesforce/core");
const functions_1 = require("./functions");
// See UT for examples of the complexity this must handle
// keys always use forward slashes, even on Windows
const pathAfterFullName = (fileResponse) => (fileResponse === null || fileResponse === void 0 ? void 0 : fileResponse.filePath)
    ? (0, path_1.join)((0, path_1.dirname)(fileResponse.filePath).substring((0, path_1.dirname)(fileResponse.filePath).lastIndexOf(fileResponse.fullName)), (0, path_1.basename)(fileResponse.filePath)).replace(/\\/gi, '/')
    : '';
const registry = new source_deploy_retrieve_1.RegistryAccess();
// only compute once
const aliasTypes = registry
    .getAliasTypes()
    .map((aliasType) => [aliasType.name, registry.getTypeByName(aliasType.aliasFor).name]);
const reverseAliasTypes = new Map(aliasTypes.map(([alias, type]) => [type, alias]));
// handle all "weird" type/name translation between SourceMember and SDR FileResponse
// These get de-duplicated in a set later, so it's ok to have one per file
const getMetadataKeyFromFileResponse = (fileResponse) => {
    // also create an element for the parent object
    if (fileResponse.type === 'CustomField' && fileResponse.filePath) {
        const splits = (0, path_1.normalize)(fileResponse.filePath).split(path_1.sep);
        const objectFolderIndex = splits.indexOf('objects');
        return [
            (0, functions_1.getMetadataKey)('CustomObject', splits[objectFolderIndex + 1]),
            (0, functions_1.getMetadataKey)(fileResponse.type, fileResponse.fullName),
        ];
    }
    // Aura/LWC need to have both the bundle level and file level keys
    if (fileResponse.type === 'LightningComponentBundle' && fileResponse.filePath) {
        return [
            `LightningComponentResource__${pathAfterFullName(fileResponse)}`,
            (0, functions_1.getMetadataKey)(fileResponse.type, fileResponse.fullName),
        ];
    }
    if (fileResponse.type === 'AuraDefinitionBundle' && fileResponse.filePath) {
        return [
            `AuraDefinition__${pathAfterFullName(fileResponse)}`,
            (0, functions_1.getMetadataKey)(fileResponse.type, fileResponse.fullName),
        ];
    }
    // CustomLabels (file) => CustomLabel[] (how they're storedin SourceMembers)
    if (fileResponse.type === 'CustomLabels' && fileResponse.filePath) {
        return source_deploy_retrieve_1.ComponentSet.fromSource(fileResponse.filePath)
            .getSourceComponents()
            .toArray()
            .flatMap((component) => component.getChildren().map((child) => (0, functions_1.getMetadataKey)('CustomLabel', child.fullName)));
    }
    // if we've aliased a type, we'll have to possibly sync both types--you can't tell from the sourceComponent retrieved which way it was stored on the server
    if (reverseAliasTypes.has(fileResponse.type)) {
        return [
            (0, functions_1.getMetadataKey)(fileResponse.type, fileResponse.fullName),
            (0, functions_1.getMetadataKey)(reverseAliasTypes.get(fileResponse.type), fileResponse.fullName),
        ];
    }
    // standard key for everything else
    return [(0, functions_1.getMetadataKey)(fileResponse.type, fileResponse.fullName)];
};
exports.getMetadataKeyFromFileResponse = getMetadataKeyFromFileResponse;
exports.mappingsForSourceMemberTypesToMetadataType = new Map([
    ...aliasTypes,
    ['AuraDefinition', 'AuraDefinitionBundle'],
    ['LightningComponentResource', 'LightningComponentBundle'],
]);
const registrySupportsType = (type) => {
    try {
        if (exports.mappingsForSourceMemberTypesToMetadataType.has(type)) {
            return true;
        }
        // this must use getTypeByName because findType doesn't support addressable child types (ex: customField!)
        registry.getTypeByName(type);
        return true;
    }
    catch (e) {
        void core_1.Lifecycle.getInstance().emitWarning(`Unable to find type ${type} in registry`);
        return false;
    }
};
exports.registrySupportsType = registrySupportsType;
//# sourceMappingURL=metadataKeys.js.map