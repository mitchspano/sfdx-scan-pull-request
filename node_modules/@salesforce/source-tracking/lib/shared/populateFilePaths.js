"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.populateFilePaths = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os_1 = require("os");
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const guards_1 = require("./guards");
const functions_1 = require("./functions");
const logger = core_1.Logger.childFromRoot('SourceTracking.PopulateFilePaths');
/**
 * Will build a component set, crawling your local directory, to get paths for remote changes
 *
 * @param elements ChangeResults that may or may not have filepaths in their filenames parameters
 * @param packageDirPaths Array of paths from PackageDirectories
 * @returns
 */
const populateFilePaths = (elements, packageDirPaths) => {
    if (elements.length === 0) {
        return [];
    }
    logger.debug('populateFilePaths for change elements', elements);
    // component set generated from an array of MetadataMember from all the remote changes
    // but exclude the ones that aren't in the registry
    const remoteChangesAsMetadataMember = elements
        .map((element) => {
        if (typeof element.type === 'string' && typeof element.name === 'string') {
            return {
                type: element.type,
                fullName: element.name,
            };
        }
    })
        .filter(guards_1.metadataMemberGuard);
    const remoteChangesAsComponentSet = new source_deploy_retrieve_1.ComponentSet(remoteChangesAsMetadataMember);
    logger.debug(` the generated component set has ${remoteChangesAsComponentSet.size.toString()} items`);
    if (remoteChangesAsComponentSet.size < elements.length) {
        // there *could* be something missing
        // some types (ex: LWC) show up as multiple files in the remote changes, but only one in the component set
        // iterate the elements to see which ones didn't make it into the component set
        const missingComponents = elements.filter((element) => !remoteChangesAsComponentSet.has({ type: element === null || element === void 0 ? void 0 : element.type, fullName: element === null || element === void 0 ? void 0 : element.name }));
        // Throw if anything was actually missing
        if (missingComponents.length > 0) {
            throw new Error(`unable to generate complete component set for ${elements
                .map((element) => `${element.name} (${element.type})`)
                .join(os_1.EOL)}`);
        }
    }
    const matchingLocalSourceComponentsSet = source_deploy_retrieve_1.ComponentSet.fromSource({
        fsPaths: packageDirPaths,
        include: remoteChangesAsComponentSet,
    });
    logger.debug(` local source-backed component set has ${matchingLocalSourceComponentsSet.size.toString()} items from remote`);
    // make it simpler to find things later
    const elementMap = new Map(elements.map((e) => [(0, functions_1.getKeyFromObject)(e), e]));
    // iterates the local components and sets their filenames
    for (const matchingComponent of matchingLocalSourceComponentsSet.getSourceComponents().toArray()) {
        if (matchingComponent.fullName && matchingComponent.type.name) {
            logger.debug(`${matchingComponent.fullName}|${matchingComponent.type.name} matches ${matchingComponent.xml} and maybe ${matchingComponent.walkContent().toString()}`);
            const key = (0, functions_1.getMetadataKey)(matchingComponent.type.name, matchingComponent.fullName);
            elementMap.set(key, {
                ...elementMap.get(key),
                modified: true,
                origin: 'remote',
                filenames: [matchingComponent.xml, ...matchingComponent.walkContent()].filter((filename) => filename),
            });
        }
    }
    return Array.from(elementMap.values());
};
exports.populateFilePaths = populateFilePaths;
//# sourceMappingURL=populateFilePaths.js.map