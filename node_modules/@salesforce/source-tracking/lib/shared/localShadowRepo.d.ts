import { NamedPackageDir } from '@salesforce/core';
interface ShadowRepoOptions {
    orgId: string;
    projectPath: string;
    packageDirs: NamedPackageDir[];
    hasSfdxTrackingFiles: boolean;
}
declare type StatusRow = [file: string, head: number, workdir: number, stage: number];
interface CommitRequest {
    deployedFiles?: string[];
    deletedFiles?: string[];
    message?: string;
    needsUpdatedStatus?: boolean;
}
export declare class ShadowRepo {
    private static instanceMap;
    gitDir: string;
    projectPath: string;
    private packageDirs;
    private status;
    private logger;
    private isWindows;
    /** do not try to add more than this many files at a time through isogit.  You'll hit EMFILE: too many open files even with graceful-fs */
    private maxFileAdd;
    private constructor();
    static getInstance(options: ShadowRepoOptions): Promise<ShadowRepo>;
    init(): Promise<void>;
    /**
     * Initialize a new source tracking shadow repo.  Think of git init
     *
     */
    gitInit(): Promise<void>;
    /**
     * Delete the local tracking files
     *
     * @returns the deleted directory
     */
    delete(): Promise<string>;
    /**
     * If the status already exists, return it.  Otherwise, set the status before returning.
     * It's kinda like a cache
     *
     * @params noCache: if true, force a redo of the status using FS even if it exists
     *
     * @returns StatusRow[]
     */
    getStatus(noCache?: boolean): Promise<StatusRow[]>;
    /**
     * returns any change (add, modify, delete)
     */
    getChangedRows(): Promise<StatusRow[]>;
    /**
     * returns any change (add, modify, delete)
     */
    getChangedFilenames(): Promise<string[]>;
    getDeletes(): Promise<StatusRow[]>;
    getDeleteFilenames(): Promise<string[]>;
    /**
     * returns adds and modifies but not deletes
     */
    getNonDeletes(): Promise<StatusRow[]>;
    /**
     * returns adds and modifies but not deletes
     */
    getNonDeleteFilenames(): Promise<string[]>;
    getAdds(): Promise<StatusRow[]>;
    getAddFilenames(): Promise<string[]>;
    /**
     * returns files that were not added or deleted, but changed locally
     */
    getModifies(): Promise<StatusRow[]>;
    getModifyFilenames(): Promise<string[]>;
    /**
     * Look through status and stage all changes, then commit
     *
     * @param fileList list of files to commit (full paths)
     * @param message: commit message (include org username and id)
     *
     * @returns sha (string)
     */
    commitChanges({ deployedFiles, deletedFiles, message, needsUpdatedStatus, }?: CommitRequest): Promise<string>;
}
export {};
