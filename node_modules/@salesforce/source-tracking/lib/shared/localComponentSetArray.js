"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getComponentSets = exports.getGroupedFiles = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fs = require("fs");
const path_1 = require("path");
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const guards_1 = require("./guards");
const functions_1 = require("./functions");
const getGroupedFiles = (input, byPackageDir = false) => {
    return (byPackageDir ? getSequential(input) : getNonSequential(input)).filter((group) => group.deletes.length || group.nonDeletes.length);
};
exports.getGroupedFiles = getGroupedFiles;
const getSequential = ({ packageDirs, nonDeletes, deletes }) => packageDirs.map((pkgDir) => ({
    path: pkgDir.name,
    nonDeletes: nonDeletes.filter((f) => (0, functions_1.pathIsInFolder)(f, pkgDir.name)),
    deletes: deletes.filter((f) => (0, functions_1.pathIsInFolder)(f, pkgDir.name)),
}));
const getNonSequential = ({ packageDirs, nonDeletes: nonDeletes, deletes: deletes, }) => [
    {
        nonDeletes,
        deletes,
        path: packageDirs.map((dir) => dir.name).join(';'),
    },
];
const getComponentSets = (groupings, sourceApiVersion) => {
    const logger = core_1.Logger.childFromRoot('localComponentSetArray');
    // optimistic resolution...some files may not be possible to resolve
    const resolverForNonDeletes = new source_deploy_retrieve_1.MetadataResolver();
    return groupings
        .map((grouping) => {
        logger.debug(`building componentSet for ${grouping.path} (deletes: ${grouping.deletes.length} nonDeletes: ${grouping.nonDeletes.length})`);
        const componentSet = new source_deploy_retrieve_1.ComponentSet();
        if (sourceApiVersion) {
            componentSet.sourceApiVersion = sourceApiVersion;
        }
        // we need virtual components for the deletes.
        // TODO: could we use the same for the non-deletes?
        const resolverForDeletes = new source_deploy_retrieve_1.MetadataResolver(undefined, source_deploy_retrieve_1.VirtualTreeContainer.fromFilePaths(grouping.deletes));
        grouping.deletes
            .flatMap((filename) => resolverForDeletes.getComponentsFromPath(filename))
            .filter(guards_1.sourceComponentGuard)
            .map((component) => {
            // if the component is a file in a bundle type AND there are files from the bundle that are not deleted, set the bundle for deploy, not for delete
            if ((0, functions_1.isBundle)(component) && component.content && fs.existsSync(component.content)) {
                // all bundle types have a directory name
                try {
                    resolverForNonDeletes
                        .getComponentsFromPath((0, path_1.resolve)(component.content))
                        .filter(guards_1.sourceComponentGuard)
                        .map((nonDeletedComponent) => componentSet.add(nonDeletedComponent));
                }
                catch (e) {
                    logger.warn(`unable to find component at ${component.content}.  That's ok if it was supposed to be deleted`);
                }
            }
            else {
                componentSet.add(component, source_deploy_retrieve_1.DestructiveChangesType.POST);
            }
        });
        grouping.nonDeletes
            .flatMap((filename) => {
            try {
                return resolverForNonDeletes.getComponentsFromPath((0, path_1.resolve)(filename));
            }
            catch (e) {
                logger.warn(`unable to resolve ${filename}`);
                return undefined;
            }
        })
            .filter(guards_1.sourceComponentGuard)
            .map((component) => componentSet.add(component));
        return componentSet;
    })
        .filter((componentSet) => componentSet.size > 0);
};
exports.getComponentSets = getComponentSets;
//# sourceMappingURL=localComponentSetArray.js.map