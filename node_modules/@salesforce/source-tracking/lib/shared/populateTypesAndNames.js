"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.populateTypesAndNames = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const guards_1 = require("./guards");
const functions_1 = require("./functions");
const logger = core_1.Logger.childFromRoot('SourceTracking.PopulateTypesAndNames');
/**
 * uses SDR to translate remote metadata records into local file paths (which only typically have the filename).
 *
 * @input elements: ChangeResult[]
 * @input projectPath
 * @input forceIgnore: ForceIgnore.  If provided, result will indicate whether the file is ignored
 * @input excludeUnresolvable: boolean Filter out components where you can't get the name and type (that is, it's probably not a valid source component)
 * @input resolveDeleted: constructs a virtualTree instead of the actual filesystem--useful when the files no longer exist
 */
const populateTypesAndNames = ({ elements, projectPath, forceIgnore, excludeUnresolvable = false, resolveDeleted = false, }) => {
    if (elements.length === 0) {
        return [];
    }
    logger.debug(`populateTypesAndNames for ${elements.length} change elements`);
    const filenames = elements.flatMap((element) => element.filenames).filter(ts_types_1.isString);
    // component set generated from the filenames on all local changes
    const resolver = new source_deploy_retrieve_1.MetadataResolver(undefined, resolveDeleted ? source_deploy_retrieve_1.VirtualTreeContainer.fromFilePaths(filenames) : undefined, !!forceIgnore);
    const sourceComponents = filenames
        .flatMap((filename) => {
        try {
            return resolver.getComponentsFromPath(filename);
        }
        catch (e) {
            logger.warn(`unable to resolve ${filename}`);
            return undefined;
        }
    })
        .filter(guards_1.sourceComponentGuard);
    logger.debug(` matching SourceComponents have ${sourceComponents.length} items from local`);
    // make it simpler to find things later
    const elementMap = new Map();
    elements.map((element) => {
        var _a;
        (_a = element.filenames) === null || _a === void 0 ? void 0 : _a.map((filename) => {
            elementMap.set((0, functions_1.ensureRelative)(filename, projectPath), element);
        });
    });
    // iterates the local components and sets their filenames
    sourceComponents.map((matchingComponent) => {
        if ((matchingComponent === null || matchingComponent === void 0 ? void 0 : matchingComponent.fullName) && (matchingComponent === null || matchingComponent === void 0 ? void 0 : matchingComponent.type.name)) {
            const filenamesFromMatchingComponent = [matchingComponent.xml, ...matchingComponent.walkContent()];
            const ignored = filenamesFromMatchingComponent
                .filter(ts_types_1.isString)
                .filter((f) => !(0, functions_1.isLwcLocalOnlyTest)(f))
                .some((f) => forceIgnore === null || forceIgnore === void 0 ? void 0 : forceIgnore.denies(f));
            filenamesFromMatchingComponent.map((filename) => {
                if (filename && elementMap.has(filename)) {
                    // add the type/name from the componentSet onto the element
                    elementMap.set(filename, {
                        origin: 'remote',
                        ...elementMap.get(filename),
                        type: matchingComponent.type.name,
                        name: matchingComponent.fullName,
                        ignored,
                    });
                }
            });
        }
    });
    return excludeUnresolvable
        ? Array.from(new Set(elementMap.values())).filter((changeResult) => changeResult.name && changeResult.type)
        : Array.from(new Set(elementMap.values()));
};
exports.populateTypesAndNames = populateTypesAndNames;
//# sourceMappingURL=populateTypesAndNames.js.map