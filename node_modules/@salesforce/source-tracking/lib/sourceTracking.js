"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceTracking = void 0;
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fs = require("fs");
const path_1 = require("path");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const remoteSourceTrackingService_1 = require("./shared/remoteSourceTrackingService");
const localShadowRepo_1 = require("./shared/localShadowRepo");
const conflicts_1 = require("./shared/conflicts");
const guards_1 = require("./shared/guards");
const functions_1 = require("./shared/functions");
const metadataKeys_1 = require("./shared/metadataKeys");
const compatibility_1 = require("./compatibility");
const populateFilePaths_1 = require("./shared/populateFilePaths");
const populateTypesAndNames_1 = require("./shared/populateTypesAndNames");
const localComponentSetArray_1 = require("./shared/localComponentSetArray");
/**
 * Manages source tracking files (remote and local)
 *
 * const tracking = await SourceTracking.create({org: this.org, project: this.project});
 *
 */
class SourceTracking extends kit_1.AsyncCreatable {
    constructor(options) {
        var _a, _b, _c;
        super(options);
        this.org = options.org;
        this.orgId = this.org.getOrgId();
        this.projectPath = options.project.getPath();
        this.packagesDirs = options.project.getPackageDirectories();
        this.logger = core_1.Logger.childFromRoot('SourceTracking');
        this.project = options.project;
        this.ignoreConflicts = (_a = options.ignoreConflicts) !== null && _a !== void 0 ? _a : false;
        this.ignoreLocalCache = (_b = options.ignoreLocalCache) !== null && _b !== void 0 ? _b : false;
        this.subscribeSDREvents = (_c = options.subscribeSDREvents) !== null && _c !== void 0 ? _c : false;
        this.hasSfdxTrackingFiles = (0, compatibility_1.hasSfdxTrackingFiles)(this.orgId, this.projectPath);
    }
    // eslint-disable-next-line class-methods-use-this
    async init() {
        await this.maybeSubscribeLifecycleEvents();
    }
    /**
     *
     * @param byPackageDir if true, returns a ComponentSet for each packageDir that has any changes
     * * if false, returns an array containing one ComponentSet with all changes
     * * if not specified, this method will follow what sfdx-project.json says
     * @returns ComponentSet[]
     */
    async localChangesAsComponentSet(byPackageDir) {
        const [projectConfig] = await Promise.all([
            this.project.resolveProjectConfig(),
            this.ensureLocalTracking(),
        ]);
        const sourceApiVersion = projectConfig.sourceApiVersion;
        const [nonDeletes, deletes] = await Promise.all([
            this.localRepo.getNonDeleteFilenames(),
            this.localRepo.getDeleteFilenames(),
        ]);
        // it'll be easier to filter filenames and work with smaller component sets than to filter SourceComponents
        const groupings = (0, localComponentSetArray_1.getGroupedFiles)({
            packageDirs: this.packagesDirs,
            nonDeletes,
            deletes,
        }, byPackageDir !== null && byPackageDir !== void 0 ? byPackageDir : Boolean(projectConfig.pushPackageDirectoriesSequentially)); // if the users specified true or false for the param, that overrides the project config
        this.logger.debug(`will build array of ${groupings.length} componentSet(s)`);
        return (0, localComponentSetArray_1.getComponentSets)(groupings, sourceApiVersion);
    }
    async remoteNonDeletesAsComponentSet() {
        const [changeResults, sourceBackedComponents] = await Promise.all([
            // all changes based on remote tracking
            this.getChanges({
                origin: 'remote',
                state: 'nondelete',
                format: 'ChangeResult',
            }),
            // only returns source-backed components (SBC)
            this.getChanges({
                origin: 'remote',
                state: 'nondelete',
                format: 'SourceComponent',
            }),
        ]);
        const componentSet = new source_deploy_retrieve_1.ComponentSet(sourceBackedComponents);
        // there may be remote adds not in the SBC.  So we add those manually
        changeResults.forEach((cr) => {
            if (cr.type && cr.name && !componentSet.has({ type: cr.type, fullName: cr.name })) {
                componentSet.add({
                    type: cr.type,
                    fullName: cr.name,
                });
            }
        });
        return componentSet;
    }
    /**
     * Does most of the work for the force:source:status command.
     * Outputs need a bit of massage since this aims to provide nice json.
     *
     * @param local you want local status
     * @param remote you want remote status
     * @returns StatusOutputRow[]
     */
    async getStatus({ local, remote }) {
        let results = [];
        if (local) {
            results = results.concat(await this.getLocalStatusRows());
        }
        if (remote) {
            await this.ensureRemoteTracking(true);
            const [remoteDeletes, remoteModifies] = await Promise.all([
                this.getChanges({ origin: 'remote', state: 'delete', format: 'ChangeResult' }),
                this.getChanges({ origin: 'remote', state: 'nondelete', format: 'ChangeResultWithPaths' }),
            ]);
            results = results.concat((await Promise.all(remoteDeletes.concat(remoteModifies).map((item) => this.remoteChangesToOutputRows(item)))).flat(1));
        }
        if (local && remote) {
            // keys like ApexClass__MyClass.cls
            const conflictFiles = (await this.getConflicts()).flatMap((conflict) => conflict.filenames).filter(ts_types_1.isString);
            results = results.map((row) => ({
                ...row,
                conflict: !!row.filePath && conflictFiles.includes(row.filePath),
            }));
        }
        return results;
    }
    async getChanges(options) {
        if ((options === null || options === void 0 ? void 0 : options.origin) === 'local') {
            await this.ensureLocalTracking();
            const filenames = await this.getLocalChangesAsFilenames(options.state);
            if (options.format === 'string') {
                return filenames;
            }
            if (options.format === 'ChangeResult' || options.format === 'ChangeResultWithPaths') {
                return filenames.map((filename) => ({
                    filenames: [filename],
                    origin: 'local',
                }));
            }
            if (options.format === 'SourceComponent') {
                const resolver = options.state === 'delete'
                    ? new source_deploy_retrieve_1.MetadataResolver(undefined, source_deploy_retrieve_1.VirtualTreeContainer.fromFilePaths(filenames))
                    : new source_deploy_retrieve_1.MetadataResolver();
                return filenames
                    .flatMap((filename) => {
                    try {
                        return resolver.getComponentsFromPath(filename);
                    }
                    catch (e) {
                        this.logger.warn(`unable to resolve ${filename}`);
                        return undefined;
                    }
                })
                    .filter(guards_1.sourceComponentGuard);
            }
        }
        if ((options === null || options === void 0 ? void 0 : options.origin) === 'remote') {
            await this.ensureRemoteTracking();
            const remoteChanges = await this.remoteSourceTrackingService.retrieveUpdates();
            this.logger.debug('remoteChanges', remoteChanges);
            const filteredChanges = remoteChanges
                .filter(remoteFilterByState[options.state])
                // skip any remote types not in the registry.  Will emit warnings
                .filter((rce) => (0, metadataKeys_1.registrySupportsType)(rce.type));
            if (options.format === 'ChangeResult') {
                return filteredChanges.map((change) => (0, remoteSourceTrackingService_1.remoteChangeElementToChangeResult)(change));
            }
            if (options.format === 'ChangeResultWithPaths') {
                return (0, populateFilePaths_1.populateFilePaths)(filteredChanges.map((change) => (0, remoteSourceTrackingService_1.remoteChangeElementToChangeResult)(change)), this.project.getPackageDirectories().map((pkgDir) => pkgDir.path));
            }
            // turn it into a componentSet to resolve filenames
            const remoteChangesAsComponentSet = new source_deploy_retrieve_1.ComponentSet(filteredChanges.map((element) => ({
                type: element === null || element === void 0 ? void 0 : element.type,
                fullName: element === null || element === void 0 ? void 0 : element.name,
            })));
            const matchingLocalSourceComponentsSet = source_deploy_retrieve_1.ComponentSet.fromSource({
                fsPaths: this.packagesDirs.map((dir) => (0, path_1.resolve)(dir.fullPath)),
                include: remoteChangesAsComponentSet,
            });
            if (options.format === 'string') {
                return matchingLocalSourceComponentsSet
                    .getSourceComponents()
                    .toArray()
                    .flatMap((component) => [component.xml, ...component.walkContent()].filter((filename) => filename));
            }
            else if (options.format === 'SourceComponent') {
                return matchingLocalSourceComponentsSet.getSourceComponents().toArray();
            }
        }
        throw new Error(`unsupported options: ${JSON.stringify(options)}`);
    }
    /**
     *
     * Convenience method to reduce duplicated steps required to do a fka pull
     * It's full of side effects: retrieving remote deletes, deleting those files locall, and then updating tracking files
     * Most bizarrely, it then returns a ComponentSet of the remote nonDeletes.
     *
     * @returns the ComponentSet for what you would retrieve now that the deletes are done
     */
    async maybeApplyRemoteDeletesToLocal() {
        const changesToDelete = await this.getChanges({ origin: 'remote', state: 'delete', format: 'SourceComponent' });
        await this.deleteFilesAndUpdateTracking(changesToDelete);
        return this.remoteNonDeletesAsComponentSet();
    }
    /**
     *
     * returns immediately if there are no changesToDelete
     *
     * @param changesToDelete array of SourceComponent
     */
    async deleteFilesAndUpdateTracking(changesToDelete) {
        if (changesToDelete.length === 0) {
            return [];
        }
        const sourceComponentByFileName = new Map();
        changesToDelete.flatMap((component) => [component.xml, ...component.walkContent()]
            .filter((filename) => filename)
            .map((filename) => sourceComponentByFileName.set(filename, component)));
        const filenames = Array.from(sourceComponentByFileName.keys());
        // delete the files
        await Promise.all(filenames.map((filename) => fs.promises.unlink(filename)));
        // update the tracking files.  We're simulating SDR-style fileResponse
        await Promise.all([
            this.updateLocalTracking({ deletedFiles: filenames }),
            this.updateRemoteTracking(changesToDelete.map((component) => ({
                type: component.type.name,
                fullName: component.fullName,
                state: source_deploy_retrieve_1.ComponentStatus.Deleted,
            })), true // skip polling because it's a pull
            ),
        ]);
        return filenames.map((filename) => {
            var _a, _b;
            return ({
                state: 'Deleted',
                filename,
                type: (_a = sourceComponentByFileName.get(filename)) === null || _a === void 0 ? void 0 : _a.type.name,
                fullName: (_b = sourceComponentByFileName.get(filename)) === null || _b === void 0 ? void 0 : _b.fullName,
            });
        });
    }
    /**
     * Update tracking for the options passed.
     *
     * @param options the files to update
     */
    async updateLocalTracking(options) {
        var _a, _b;
        await this.ensureLocalTracking();
        // relative paths make smaller trees AND isogit wants them relative
        const relativeOptions = {
            files: ((_a = options.files) !== null && _a !== void 0 ? _a : []).map((file) => (0, functions_1.ensureRelative)(file, this.projectPath)),
            deletedFiles: ((_b = options.deletedFiles) !== null && _b !== void 0 ? _b : []).map((file) => (0, functions_1.ensureRelative)(file, this.projectPath)),
        };
        // plot twist: if you delete a member of a bundle (ex: lwc/foo/foo.css) and push, it'll not be in the fileResponses (deployedFiles) or deletedFiles
        // what got deleted?  Any local changes NOT in the fileResponses but part of a successfully deployed bundle
        const deployedFilesAsVirtualComponentSet = source_deploy_retrieve_1.ComponentSet.fromSource({
            // resolve from highest possible level.  TODO: can we use [.]
            fsPaths: relativeOptions.files.length ? [relativeOptions.files[0].split(path_1.sep)[0]] : [],
            tree: source_deploy_retrieve_1.VirtualTreeContainer.fromFilePaths(relativeOptions.files),
        });
        // these are top-level bundle paths like lwc/foo
        const bundlesWithDeletedFiles = (await this.getChanges({ origin: 'local', state: 'delete', format: 'SourceComponent' }))
            .filter(functions_1.isBundle)
            .filter((cmp) => deployedFilesAsVirtualComponentSet.has({ type: cmp.type, fullName: cmp.fullName }))
            .map((cmp) => cmp.content)
            .filter(ts_types_1.isString);
        await this.localRepo.commitChanges({
            deployedFiles: relativeOptions.files,
            deletedFiles: relativeOptions.deletedFiles.concat((await this.localRepo.getDeleteFilenames()).filter((deployedFile) => bundlesWithDeletedFiles.some((bundlePath) => (0, functions_1.pathIsInFolder)(deployedFile, bundlePath)) &&
                !relativeOptions.files.includes(deployedFile))),
        });
    }
    /**
     * Mark remote source tracking files so say that we have received the latest version from the server
     * Optionall skip polling for the SourceMembers to exist on the server and be updated in local files
     */
    async updateRemoteTracking(fileResponses, skipPolling = false) {
        // false to explicitly NOT query until we do the polling
        await this.ensureRemoteTracking(false);
        if (!skipPolling) {
            // poll to make sure we have the updates before syncing the ones from metadataKeys
            await this.remoteSourceTrackingService.pollForSourceTracking(fileResponses);
        }
        await this.remoteSourceTrackingService.syncSpecifiedElements(fileResponses);
    }
    async reReadLocalTrackingCache() {
        await this.localRepo.getStatus(true);
    }
    /**
     * If the local tracking shadowRepo doesn't exist, it will be created.
     * Does nothing if it already exists, unless you've instantiate SourceTracking to not cache local status, in which case it'll re-read your files
     * Useful before parallel operations
     */
    async ensureLocalTracking() {
        if (this.localRepo) {
            if (this.ignoreLocalCache) {
                await this.localRepo.getStatus(true);
            }
            return;
        }
        this.localRepo = await localShadowRepo_1.ShadowRepo.getInstance({
            orgId: this.orgId,
            projectPath: (0, path_1.normalize)(this.projectPath),
            packageDirs: this.packagesDirs,
            hasSfdxTrackingFiles: this.hasSfdxTrackingFiles,
        });
        // loads the status from file so that it's cached
        await this.localRepo.getStatus();
    }
    /**
     * If the remote tracking shadowRepo doesn't exist, it will be created.
     * Does nothing if it already exists.
     * Useful before parallel operations
     */
    async ensureRemoteTracking(initializeWithQuery = false) {
        if (this.remoteSourceTrackingService) {
            this.logger.debug('ensureRemoteTracking: remote tracking already exists');
            return;
        }
        this.logger.debug('ensureRemoteTracking: remote tracking does not exist yet; getting instance');
        this.remoteSourceTrackingService = await remoteSourceTrackingService_1.RemoteSourceTrackingService.getInstance({
            org: this.org,
            projectPath: this.projectPath,
            useSfdxTrackingFiles: this.hasSfdxTrackingFiles,
        });
        if (initializeWithQuery) {
            await this.remoteSourceTrackingService.retrieveUpdates();
        }
    }
    /**
     * Deletes the local tracking shadowRepo
     * return the list of files that were in it
     */
    async clearLocalTracking() {
        await this.ensureLocalTracking();
        return this.localRepo.delete();
    }
    /**
     * Commits all the local changes so that no changes are present in status
     */
    async resetLocalTracking() {
        await this.ensureLocalTracking();
        const [deletes, nonDeletes] = await Promise.all([
            this.localRepo.getDeleteFilenames(),
            this.localRepo.getNonDeleteFilenames(),
        ]);
        await this.localRepo.commitChanges({
            deletedFiles: deletes,
            deployedFiles: nonDeletes,
            message: 'via resetLocalTracking',
        });
        return [...deletes, ...nonDeletes];
    }
    /**
     * Deletes the remote tracking files
     */
    async clearRemoteTracking() {
        return remoteSourceTrackingService_1.RemoteSourceTrackingService.delete(this.orgId, this.hasSfdxTrackingFiles);
    }
    /**
     * Sets the files to max revision so that no changes appear
     */
    async resetRemoteTracking(serverRevision) {
        await this.ensureRemoteTracking();
        const resetMembers = await this.remoteSourceTrackingService.reset(serverRevision);
        return resetMembers.length;
    }
    /**
     * Compares local and remote changes to detect conflicts
     */
    async getConflicts() {
        var _a;
        // we're going to need have both initialized
        await Promise.all([this.ensureRemoteTracking(), this.ensureLocalTracking()]);
        // Strategy: check local changes first (since it'll be faster) to avoid callout
        // early return if either local or remote is empty
        const localChanges = await this.getChanges({
            state: 'nondelete',
            origin: 'local',
            format: 'ChangeResult',
        });
        if (localChanges.length === 0) {
            return [];
        }
        const remoteChanges = await this.getChanges({
            origin: 'remote',
            state: 'nondelete',
            // remote adds won't have a filename, so we ask for it to be resolved
            format: 'ChangeResultWithPaths',
        });
        if (remoteChanges.length === 0) {
            return [];
        }
        (_a = this.forceIgnore) !== null && _a !== void 0 ? _a : (this.forceIgnore = source_deploy_retrieve_1.ForceIgnore.findAndCreate(this.project.getDefaultPackage().path));
        return (0, conflicts_1.getDedupedConflictsFromChanges)({
            localChanges,
            remoteChanges,
            projectPath: this.projectPath,
            forceIgnore: this.forceIgnore,
        });
    }
    /**
     * handles both remote and local tracking
     *
     * @param result FileResponse[]
     */
    async updateTrackingFromDeploy(deployResult) {
        const successes = deployResult
            .getFileResponses()
            .filter((fileResponse) => fileResponse.state !== source_deploy_retrieve_1.ComponentStatus.Failed && fileResponse.filePath);
        if (!successes.length) {
            return;
        }
        await Promise.all([
            this.updateLocalTracking({
                // assertions allowed because filtered above
                files: successes
                    .filter((fileResponse) => fileResponse.state !== source_deploy_retrieve_1.ComponentStatus.Deleted)
                    .map((fileResponse) => fileResponse.filePath),
                deletedFiles: successes
                    .filter((fileResponse) => fileResponse.state === source_deploy_retrieve_1.ComponentStatus.Deleted)
                    .map((fileResponse) => fileResponse.filePath),
            }),
            this.updateRemoteTracking(successes.map(({ state, fullName, type, filePath }) => ({ state, fullName, type, filePath }))),
        ]);
    }
    /**
     * handles both remote and local tracking
     *
     * @param result FileResponse[]
     */
    async updateTrackingFromRetrieve(retrieveResult) {
        const successes = retrieveResult
            .getFileResponses()
            .filter((fileResponse) => fileResponse.state !== source_deploy_retrieve_1.ComponentStatus.Failed);
        if (!successes.length) {
            return;
        }
        await Promise.all([
            this.updateLocalTracking({
                // assertion allowed because it's filtering out undefined
                files: successes.map((fileResponse) => fileResponse.filePath).filter(Boolean),
            }),
            this.updateRemoteTracking(successes.map(({ state, fullName, type, filePath }) => ({ state, fullName, type, filePath })), true // retrieves don't need to poll for SourceMembers
            ),
        ]);
    }
    /**
     * If you've already got an instance of STL, but need to change the conflicts setting
     * normally you set this on instantiation
     *
     * @param value true/false
     */
    setIgnoreConflicts(value) {
        this.ignoreConflicts = value;
    }
    async maybeSubscribeLifecycleEvents() {
        if (this.subscribeSDREvents && (await this.org.tracksSource())) {
            const lifecycle = core_1.Lifecycle.getInstance();
            // the only thing STL uses pre events for is to check conflicts.  So if you don't care about conflicts, don't listen!
            if (!this.ignoreConflicts) {
                this.logger.debug('subscribing to predeploy/retrieve events');
                // subscribe to SDR `pre` events to handle conflicts before deploy/retrieve
                lifecycle.on('scopedPreDeploy', async (e) => {
                    this.logger.debug('received scopedPreDeploy event');
                    if (e.orgId === this.orgId) {
                        (0, conflicts_1.throwIfConflicts)((0, conflicts_1.findConflictsInComponentSet)(e.componentSet, await this.getConflicts()));
                    }
                });
                lifecycle.on('scopedPreRetrieve', async (e) => {
                    this.logger.debug('received scopedPreRetrieve event');
                    if (e.orgId === this.orgId) {
                        (0, conflicts_1.throwIfConflicts)((0, conflicts_1.findConflictsInComponentSet)(e.componentSet, await this.getConflicts()));
                    }
                });
            }
            // subscribe to SDR post-deploy event
            this.logger.debug('subscribing to postdeploy/retrieve events');
            // yes, the post hooks really have different payloads!
            lifecycle.on('scopedPostDeploy', async (e) => {
                this.logger.debug('received scopedPostDeploy event');
                if (e.orgId === this.orgId) {
                    await this.updateTrackingFromDeploy(e.deployResult);
                }
            });
            lifecycle.on('scopedPostRetrieve', async (e) => {
                this.logger.debug('received scopedPostRetrieve event');
                if (e.orgId === this.orgId) {
                    await this.updateTrackingFromRetrieve(e.retrieveResult);
                }
            });
        }
    }
    async getLocalStatusRows() {
        await this.ensureLocalTracking();
        let results = [];
        const localDeletes = (0, populateTypesAndNames_1.populateTypesAndNames)({
            elements: await this.getChanges({ origin: 'local', state: 'delete', format: 'ChangeResult' }),
            excludeUnresolvable: true,
            resolveDeleted: true,
            projectPath: this.projectPath,
        });
        const localAdds = (0, populateTypesAndNames_1.populateTypesAndNames)({
            elements: await this.getChanges({ origin: 'local', state: 'add', format: 'ChangeResult' }),
            excludeUnresolvable: true,
            projectPath: this.projectPath,
        });
        const localModifies = (0, populateTypesAndNames_1.populateTypesAndNames)({
            elements: await this.getChanges({ origin: 'local', state: 'modify', format: 'ChangeResult' }),
            excludeUnresolvable: true,
            projectPath: this.projectPath,
        });
        results = results.concat(localAdds.flatMap((item) => this.localChangesToOutputRow(item, 'add')), localModifies.flatMap((item) => this.localChangesToOutputRow(item, 'modify')), localDeletes.flatMap((item) => this.localChangesToOutputRow(item, 'delete')));
        return results;
    }
    async getLocalChangesAsFilenames(state) {
        if (state === 'modify') {
            return this.localRepo.getModifyFilenames();
        }
        if (state === 'nondelete') {
            return this.localRepo.getNonDeleteFilenames();
        }
        if (state === 'delete') {
            return this.localRepo.getDeleteFilenames();
        }
        if (state === 'add') {
            return this.localRepo.getAddFilenames();
        }
        throw new Error(`unable to get local changes for state ${state}`);
    }
    localChangesToOutputRow(input, localType) {
        var _a;
        this.logger.debug('converting ChangeResult to a row', input);
        (_a = this.forceIgnore) !== null && _a !== void 0 ? _a : (this.forceIgnore = source_deploy_retrieve_1.ForceIgnore.findAndCreate(this.project.getDefaultPackage().path));
        if (input.filenames) {
            return input.filenames.map((filename) => {
                var _a, _b;
                return ({
                    type: (_a = input.type) !== null && _a !== void 0 ? _a : '',
                    state: localType,
                    fullName: (_b = input.name) !== null && _b !== void 0 ? _b : '',
                    filePath: filename,
                    origin: 'local',
                    ignored: this.forceIgnore.denies(filename),
                });
            });
        }
        throw new Error('no filenames found for local ChangeResult');
    }
    // this will eventually have async call to figure out the target file locations for remote changes
    // eslint-disable-next-line @typescript-eslint/require-await
    async remoteChangesToOutputRows(input) {
        var _a, _b, _c, _d;
        this.logger.debug('converting ChangeResult to a row', input);
        (_a = this.forceIgnore) !== null && _a !== void 0 ? _a : (this.forceIgnore = source_deploy_retrieve_1.ForceIgnore.findAndCreate(this.project.getDefaultPackage().path));
        const baseObject = {
            type: (_b = input.type) !== null && _b !== void 0 ? _b : '',
            origin: input.origin,
            state: stateFromChangeResult(input),
            fullName: (_c = input.name) !== null && _c !== void 0 ? _c : '',
        };
        // it's easy to check ignores if the filePaths exist locally
        if ((_d = input.filenames) === null || _d === void 0 ? void 0 : _d.length) {
            return input.filenames.map((filename) => ({
                ...baseObject,
                filePath: filename,
                ignored: this.forceIgnore.denies(filename),
            }));
        }
        // when the file doesn't exist locally, there are no filePaths
        // So we can't say whether it's ignored or not
        return [baseObject];
    }
}
exports.SourceTracking = SourceTracking;
const remoteFilterByState = {
    add: (change) => !change.deleted && !change.modified,
    modify: (change) => change.modified === true,
    delete: (change) => change.deleted === true,
    nondelete: (change) => !change.deleted,
};
const stateFromChangeResult = (input) => {
    if (input.deleted) {
        return 'delete';
    }
    if (input.modified) {
        return 'modify';
    }
    return 'add';
};
//# sourceMappingURL=sourceTracking.js.map