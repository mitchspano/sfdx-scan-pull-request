"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceRenamedCommands = exports.throwIfInvalid = exports.getTrackingFileVersion = exports.hasSfdxTrackingFiles = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fs = require("fs");
const path = require("path");
const core_1 = require("@salesforce/core");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/source-tracking', 'compatibility', [
    'sourceTrackingFileVersionMismatch',
    'clearSuggestion',
    'useOtherVersion',
]);
const hasSfdxTrackingFiles = (orgId, projectPath) => fs.existsSync(path.join(projectPath, '.sfdx', 'orgs', orgId));
exports.hasSfdxTrackingFiles = hasSfdxTrackingFiles;
/**
 * A project can have "old" (toolbelt), "new" (plugin-source) or "none" tracking files
 *
 * @deprecated use only during transition to new source-tracking commands
 */
const getTrackingFileVersion = (org, projectPath) => {
    const orgsDir = path.join(projectPath, '.sfdx', 'orgs');
    const newFilesDir = path.join(orgsDir, org.getOrgId());
    // has new tracking files based on orgId
    if (fs.existsSync(newFilesDir) && fs.readdirSync(newFilesDir).length > 0) {
        return 'plugin-source';
    }
    const username = org.getUsername();
    if (typeof username === 'string') {
        if (
        // has both of the old files (org:create puts maxRevision.json in the username dir)
        fs.existsSync(path.join(orgsDir, username, 'sourcePathInfos.json')) &&
            fs.existsSync(path.join(orgsDir, username, 'maxRevision.json'))) {
            return 'toolbelt';
        }
    }
    return 'none';
};
exports.getTrackingFileVersion = getTrackingFileVersion;
/**
 * Convenient wrapper for throwing errors with helpful messages so commands don't have to
 *
 * @deprecated use only during transition to new source-tracking commands
 *
 * @param org: an Org, typically from a command's this.org
 * @param project: the project path, typically from this.project.
 * @param toValidate: whether your command lives in 'toolbelt' or 'plugin-source'
 * @param command: the command itself including all flags.  Echoed with modification for the user
 */
const throwIfInvalid = ({ org, projectPath, toValidate, command, }) => {
    const trackingFileVersion = (0, exports.getTrackingFileVersion)(org, projectPath);
    if (trackingFileVersion === 'none' || trackingFileVersion === toValidate) {
        return;
    }
    // We expected it to be the toolbelt version but it is using the new tracking files
    if (toValidate === 'toolbelt') {
        // some of the toolbelt commands aren't using SfdxCommand and the SfError actions won't be automatically displayed
        throw new core_1.SfError(`${messages.getMessage('sourceTrackingFileVersionMismatch', ['new/beta'])}\n\nTry this:\n${messages.getMessage('useOtherVersion', ['new/beta', (0, exports.replaceRenamedCommands)(command.replace(':legacy', ''))])}.\n${messages.getMessage('clearSuggestion', [
            'new/beta',
            (0, exports.replaceRenamedCommands)('sfdx force:source:tracking:clear'),
            (0, exports.replaceRenamedCommands)('sfdx force:source:tracking:reset', true),
        ])}.`, 'SourceTrackingFileVersionMismatch');
    }
    // We expected it to be the plugin-source version but it is using the old tracking files
    if (toValidate === 'plugin-source') {
        throw new core_1.SfError(messages.getMessage('sourceTrackingFileVersionMismatch', ['old/legacy']), 'SourceTrackingFileVersionMismatch', [
            messages.getMessage('useOtherVersion', ['old/legacy', (0, exports.replaceRenamedCommands)(command, true)]),
            messages.getMessage('clearSuggestion', [
                'old/legacy',
                'sfdx force:source:legacy:tracking:clear',
                'sfdx force:source:tracking:reset',
            ]),
        ]);
    }
};
exports.throwIfInvalid = throwIfInvalid;
/**
 * @deprecated use only during transition to new source-tracking commands
 * @param input the string that might contain things that would be replaced
 * @param reverse use the mappings backward
 * @returns string
 */
const replaceRenamedCommands = (input, reverse = false) => {
    renames.forEach((value, key) => {
        input = reverse ? input.replace(value, key) : input.replace(key, value);
    });
    return input;
};
exports.replaceRenamedCommands = replaceRenamedCommands;
const renames = new Map([
    ['force:source:legacy:status', 'force:source:status'],
    ['force:source:legacy:push', 'force:source:push'],
    ['force:source:legacy:pull', 'force:source:pull'],
    ['force:source:legacy:tracking:reset', 'force:source:tracking:reset'],
    ['force:source:legacy:tracking:clear', 'force:source:tracking:clear'],
]);
//# sourceMappingURL=compatibility.js.map