"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrgListCommand = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os_1 = require("os");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const orgListUtil_1 = require("../../../shared/orgListUtil");
const orgHighlighter_1 = require("../../../shared/orgHighlighter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-org', 'list');
class OrgListCommand extends command_1.SfdxCommand {
    constructor() {
        super(...arguments);
        this.sortFunction = (orgDetails) => {
            this.extractDefaultOrgStatus(orgDetails);
            return [orgDetails.alias, orgDetails.username];
        };
    }
    async run() {
        let fileNames = [];
        try {
            fileNames = (await core_1.AuthInfo.listAllAuthorizations()).map((auth) => auth.username);
        }
        catch (err) {
            const error = err;
            if (error.name === 'NoAuthInfoFound') {
                throw new core_1.SfError(messages.getMessage('noOrgsFound'), 'noOrgsFound', [
                    messages.getMessage('noOrgsFoundAction'),
                ]);
            }
            else {
                throw error;
            }
        }
        const metaConfigs = await orgListUtil_1.OrgListUtil.readLocallyValidatedMetaConfigsGroupedByOrgType(fileNames, this.flags);
        const groupedSortedOrgs = {
            nonScratchOrgs: (0, kit_1.sortBy)(metaConfigs.nonScratchOrgs, this.sortFunction),
            scratchOrgs: (0, kit_1.sortBy)(metaConfigs.scratchOrgs, this.sortFunction),
            expiredScratchOrgs: metaConfigs.scratchOrgs.filter((org) => !(0, orgListUtil_1.identifyActiveOrgByStatus)(org)),
        };
        if (this.flags.clean && groupedSortedOrgs.expiredScratchOrgs.length > 0) {
            await this.cleanScratchOrgs(groupedSortedOrgs.expiredScratchOrgs, !this.flags.noprompt);
        }
        if (groupedSortedOrgs.expiredScratchOrgs.length > 10 && !this.flags.clean) {
            this.ux.warn(messages.getMessage('deleteOrgs', [groupedSortedOrgs.expiredScratchOrgs.length]));
        }
        const result = {
            nonScratchOrgs: groupedSortedOrgs.nonScratchOrgs,
            scratchOrgs: this.flags.all
                ? groupedSortedOrgs.scratchOrgs
                : groupedSortedOrgs.scratchOrgs.filter(orgListUtil_1.identifyActiveOrgByStatus),
        };
        this.ux.styledHeader('Orgs');
        this.printOrgTable(result.nonScratchOrgs, this.flags.skipconnectionstatus);
        // separate the table by a blank line.
        this.ux.log();
        this.printScratchOrgTable(result.scratchOrgs);
        return result;
    }
    async cleanScratchOrgs(scratchOrgs, prompt) {
        if (prompt && (await this.ux.confirm(messages.getMessage('prompt', [scratchOrgs.length]))) === false) {
            return;
        }
        await Promise.all(scratchOrgs.map(async (fields) => {
            try {
                const authInfo = await core_1.AuthInfo.create({ username: fields.username });
                const connection = await core_1.Connection.create({
                    authInfo,
                    configAggregator: {
                        // Force an api version to prevent connection check with the server for expired orgs.
                        getInfo: () => ({ value: '47.0' }),
                    },
                });
                const org = await core_1.Org.create({ aliasOrUsername: fields.username, connection });
                await org.remove();
            }
            catch (e) {
                const err = e;
                this.logger.debug(`Error cleaning org ${fields.username}: ${err.message}`);
                this.ux.warn(`Unable to clean org with username ${fields.username}.  You can run "sfdx force:org:delete -u ${fields.username}" to remove it.`);
            }
        }));
    }
    printOrgTable(nonScratchOrgs, skipconnectionstatus) {
        // default columns for the non-scratch org list
        let nonScratchOrgColumns = {
            defaultMarker: {
                header: '',
                get: (data) => { var _a; return (_a = data.defaultMarker) !== null && _a !== void 0 ? _a : ''; },
            },
            alias: {
                header: 'ALIAS',
                get: (data) => { var _a; return (_a = data.alias) !== null && _a !== void 0 ? _a : ''; },
            },
            username: { header: 'USERNAME' },
            orgId: { header: 'ORG ID' },
        };
        if (!skipconnectionstatus) {
            nonScratchOrgColumns = Object.assign(nonScratchOrgColumns, {
                connectedStatus: { header: 'CONNECTED STATUS' },
            });
        }
        if (nonScratchOrgs.length) {
            this.ux.table(nonScratchOrgs.map((row) => (0, orgHighlighter_1.getStyledObject)(row)), nonScratchOrgColumns);
        }
        else {
            this.ux.log(messages.getMessage('noResultsFound'));
        }
    }
    printScratchOrgTable(scratchOrgs) {
        if (scratchOrgs.length === 0) {
            this.ux.log(messages.getMessage('noActiveScratchOrgs'));
        }
        else {
            // One or more rows are available.
            this.ux.table(scratchOrgs.map((row) => (0, orgHighlighter_1.getStyledObject)(row)), this.getScratchOrgColumnData());
        }
    }
    extractDefaultOrgStatus(val) {
        if (val.isDefaultDevHubUsername) {
            val.defaultMarker = '(D)';
        }
        else if (val.isDefaultUsername) {
            val.defaultMarker = '(U)';
        }
    }
    getScratchOrgColumnData() {
        // default columns for the scratch org list
        let scratchOrgColumns = {
            defaultMarker: {
                header: '',
                get: (data) => { var _a; return (_a = data.defaultMarker) !== null && _a !== void 0 ? _a : ''; },
            },
            alias: {
                header: 'ALIAS',
                get: (data) => { var _a; return (_a = data.alias) !== null && _a !== void 0 ? _a : ''; },
            },
            username: { header: 'USERNAME' },
            orgId: { header: 'ORG ID' },
        };
        if (this.flags.all || this.flags.verbose) {
            scratchOrgColumns = Object.assign(scratchOrgColumns, {
                status: { header: 'STATUS' },
            });
        }
        // scratch org verbose columns
        if (this.flags.verbose) {
            scratchOrgColumns = Object.assign(scratchOrgColumns, {
                devHubOrgId: { header: 'DEV HUB' },
                createdDate: { header: 'CREATED DATE' },
                instanceUrl: { header: 'INSTANCE URL' },
            });
        }
        // scratch org expiration date should be on the end.
        return Object.assign(scratchOrgColumns, {
            expirationDate: { header: 'EXPIRATION DATE' },
        });
    }
}
exports.OrgListCommand = OrgListCommand;
OrgListCommand.description = messages.getMessage('description');
OrgListCommand.examples = messages.getMessage('examples').split(os_1.EOL);
OrgListCommand.requiresProject = false;
OrgListCommand.flagsConfig = {
    verbose: command_1.flags.builtin({
        description: messages.getMessage('verbose'),
    }),
    all: command_1.flags.boolean({
        description: messages.getMessage('all'),
    }),
    clean: command_1.flags.boolean({
        description: messages.getMessage('clean'),
    }),
    noprompt: command_1.flags.boolean({
        char: 'p',
        description: messages.getMessage('noPrompt'),
        dependsOn: ['clean'],
    }),
    skipconnectionstatus: command_1.flags.boolean({
        description: messages.getMessage('skipConnectionStatus'),
    }),
};
//# sourceMappingURL=list.js.map