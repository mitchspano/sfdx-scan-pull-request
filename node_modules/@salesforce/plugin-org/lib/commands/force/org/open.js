"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrgOpenCommand = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os_1 = require("os");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const open = require("open");
const utils_1 = require("../../../shared/utils");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-org', 'open');
const sharedMessages = core_1.Messages.loadMessages('@salesforce/plugin-org', 'messages');
class OrgOpenCommand extends command_1.SfdxCommand {
    async run() {
        var _a;
        const frontDoorUrl = await this.buildFrontdoorUrl();
        const url = this.flags.path ? `${frontDoorUrl}&retURL=${this.flags.path}` : frontDoorUrl;
        const orgId = this.org.getOrgId();
        const username = this.org.getUsername();
        const output = { orgId, url, username };
        const containerMode = new kit_1.Env().getBoolean('SFDX_CONTAINER_MODE');
        // security warning only for --json OR --urlonly OR containerMode
        if (this.flags.urlonly || this.flags.json || containerMode) {
            this.ux.warn(sharedMessages.getMessage('SecurityWarning'));
            this.ux.log('');
        }
        if (containerMode) {
            // instruct the user that they need to paste the URL into the browser
            this.ux.styledHeader('Action Required!');
            this.ux.log(messages.getMessage('containerAction', [orgId, url]));
            return output;
        }
        if (this.flags.urlonly) {
            // this includes the URL
            this.ux.log(messages.getMessage('humanSuccess', [orgId, username, url]));
            return output;
        }
        this.ux.log(messages.getMessage('humanSuccessNoUrl', [orgId, username]));
        // we actually need to open the org
        try {
            this.ux.startSpinner(messages.getMessage('domainWaiting'));
            const sfdcUrl = new core_1.SfdcUrl(url);
            await sfdcUrl.checkLightningDomain();
        }
        catch (err) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,  @typescript-eslint/no-unsafe-call
            if ((_a = err.message) === null || _a === void 0 ? void 0 : _a.includes('timeout')) {
                const domain = `https://${/https?:\/\/([^.]*)/.exec(url)[1]}.lightning.force.com`;
                const timeout = new kit_1.Duration(new kit_1.Env().getNumber('SFDX_DOMAIN_RETRY', 240), kit_1.Duration.Unit.SECONDS);
                this.logger.debug(`Did not find IP for ${domain} after ${timeout.seconds} seconds`);
                throw new core_1.SfError(messages.getMessage('domainTimeoutError'), 'domainTimeoutError');
            }
            throw core_1.SfError.wrap(err);
        }
        const openOptions = typeof this.flags.browser === 'string' ? { app: { name: open.apps[this.flags.browser] } } : {};
        await (0, utils_1.openUrl)(url, openOptions);
        return output;
    }
    async buildFrontdoorUrl() {
        await this.org.refreshAuth(); // we need a live accessToken for the frontdoor url
        const conn = this.org.getConnection();
        const accessToken = conn.accessToken;
        const instanceUrl = this.org.getField(core_1.Org.Fields.INSTANCE_URL);
        const instanceUrlClean = instanceUrl.replace(/\/$/, '');
        return `${instanceUrlClean}/secur/frontdoor.jsp?sid=${accessToken}`;
    }
}
exports.OrgOpenCommand = OrgOpenCommand;
OrgOpenCommand.description = messages.getMessage('description');
OrgOpenCommand.examples = messages.getMessage('examples').split(os_1.EOL);
OrgOpenCommand.requiresUsername = true;
OrgOpenCommand.flagsConfig = {
    browser: command_1.flags.string({
        char: 'b',
        description: messages.getMessage('browser'),
        options: ['chrome', 'edge', 'firefox'],
        exclusive: ['urlonly'],
    }),
    path: command_1.flags.string({
        char: 'p',
        description: messages.getMessage('cliPath'),
        env: 'FORCE_OPEN_URL',
        parse: (input) => {
            return Promise.resolve(encodeURIComponent(decodeURIComponent(input)));
        },
    }),
    urlonly: command_1.flags.boolean({
        char: 'r',
        description: messages.getMessage('urlonly'),
    }),
};
//# sourceMappingURL=open.js.map