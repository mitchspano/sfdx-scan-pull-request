"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.identifyActiveOrgByStatus = exports.OrgListUtil = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path_1 = require("path");
const fs = require("fs/promises");
const core_1 = require("@salesforce/core");
const lib_1 = require("@salesforce/kit/lib");
const utils_1 = require("./utils");
class OrgListUtil {
    static async retrieveLogger() {
        if (!OrgListUtil.logger) {
            OrgListUtil.logger = await core_1.Logger.child('OrgListUtil');
        }
        return OrgListUtil.logger;
    }
    /**
     * This method takes all locally configured orgs and organizes them into the following buckets:
     * { nonScratchOrgs: [{}], scratchOrgs: [{}] }
     * the scratchOrgInfo query.
     *
     * @param {string[]|null} userFilenames- an array of strings that are validated against the server.
     * @param {object} flags - the result of this.flags on an sfdx command
     */
    static async readLocallyValidatedMetaConfigsGroupedByOrgType(userFilenames, flags) {
        const contents = await OrgListUtil.readAuthFiles(userFilenames);
        const orgs = await OrgListUtil.groupOrgs(contents);
        // parallelize two very independent operations
        const [nonScratchOrgs, scratchOrgs] = await Promise.all([
            Promise.all(orgs.nonScratchOrgs.map(async (fields) => {
                if (!flags.skipconnectionstatus) {
                    // skip completely if we're skipping the connection
                    fields.connectedStatus = await OrgListUtil.determineConnectedStatusForNonScratchOrg(fields.username);
                    if (!fields.isDevHub && fields.connectedStatus === 'Connected') {
                        // activating DevHub setting is irreversible so don't waste time checking any org we already know is a hub
                        fields.isDevHub = await OrgListUtil.checkNonScratchOrgIsDevHub(fields.username);
                    }
                }
                return fields;
            })),
            OrgListUtil.processScratchOrgs(orgs.scratchOrgs),
        ]);
        return {
            nonScratchOrgs,
            scratchOrgs,
        };
    }
    /**
     * Organizes the scratchOrgs by DevHub to optimize calls to retrieveScratchOrgInfoFromDevHub(), then calls reduceScratchOrgInfo()
     *
     * @param {ExtendedAuthFields[]} scratchOrgs- an array of strings that are validated against the server.
     * @returns the same scratch org list, but with updated information from the server.
     */
    static async processScratchOrgs(scratchOrgs) {
        const orgIdsGroupedByDevHub = scratchOrgs
            .filter((fields) => fields.devHubUsername)
            .reduce((accum, fields) => {
            var _a;
            accum[fields.devHubUsername] = [...((_a = accum[fields.devHubUsername]) !== null && _a !== void 0 ? _a : []), core_1.sfdc.trimTo15(fields.orgId)];
            return accum;
        }, {});
        const updatedContents = (await Promise.all(Object.entries(orgIdsGroupedByDevHub).map(async ([devHubUsername, orgIds]) => OrgListUtil.retrieveScratchOrgInfoFromDevHub(devHubUsername, orgIds)))).reduce((accumulator, iterator) => [...accumulator, ...iterator], []);
        return OrgListUtil.reduceScratchOrgInfo(updatedContents, scratchOrgs);
    }
    /**
     * Used to retrieve authInfo of the auth files
     *
     * @param fileNames All the filenames in the global hidden folder
     */
    static async readAuthFiles(fileNames) {
        const orgFileNames = (await fs.readdir(core_1.Global.SFDX_DIR)).filter((filename) => filename.match(/^00D.{15}\.json$/g));
        const allAuths = await Promise.all(fileNames.map(async (fileName) => {
            try {
                const orgUsername = (0, path_1.basename)(fileName, '.json');
                const auth = await core_1.AuthInfo.create({ username: orgUsername });
                const userId = auth === null || auth === void 0 ? void 0 : auth.getFields().userId;
                // no userid?  Definitely an org primary user
                if (!userId) {
                    return auth;
                }
                const orgId = auth.getFields().orgId;
                const orgFileName = `${orgId}.json`;
                // if userId, it could be created from password:generate command.  If <orgId>.json doesn't exist, it's also not a secondary user auth file
                if (orgId && !orgFileNames.includes(orgFileName)) {
                    return auth;
                }
                // Theory: within <orgId>.json, if the userId is the first entry, that's the primary username.
                if (orgFileNames.includes(orgFileName)) {
                    const orgFileContent = JSON.parse(await fs.readFile((0, path_1.join)(core_1.Global.SFDX_STATE_FOLDER, orgFileName), 'utf8'));
                    const usernames = orgFileContent.usernames;
                    if (usernames && usernames[0] === auth.getFields().username) {
                        return auth;
                    }
                }
            }
            catch (error) {
                const err = error;
                const logger = await OrgListUtil.retrieveLogger();
                logger.warn(`Problem reading file: ${fileName} skipping`);
                logger.warn(err.message);
            }
        }));
        return allAuths.filter((auth) => !!auth);
    }
    /**
     * Helper to group orgs by {scratchOrg, nonScratchOrgs}
     * Also identifies which are default orgs from config
     *
     * @param {object} contents -The authinfo retrieved from the auth files
     * @param {string[]} excludeProperties - properties to exclude from the grouped configs ex. ['refreshToken', 'clientSecret']
     * @private
     */
    static async groupOrgs(authInfos) {
        const output = {
            scratchOrgs: [],
            nonScratchOrgs: [],
        };
        const config = (await core_1.SfdxConfigAggregator.create()).getConfig();
        for (const authInfo of authInfos) {
            let currentValue;
            try {
                currentValue = OrgListUtil.removeRestrictedInfoFromConfig(authInfo.getFields(true));
            }
            catch (error) {
                const logger = await OrgListUtil.retrieveLogger();
                logger.warn(`Error decrypting ${authInfo.getUsername()}`);
                currentValue = OrgListUtil.removeRestrictedInfoFromConfig(authInfo.getFields());
            }
            const [alias, lastUsed] = await Promise.all([
                (0, utils_1.getAliasByUsername)(currentValue.username),
                fs.stat((0, path_1.join)(core_1.Global.SFDX_DIR, `${currentValue.username}.json`)),
            ]);
            currentValue.alias = alias;
            currentValue.lastUsed = lastUsed.atime;
            OrgListUtil.identifyDefaultOrgs(currentValue, config);
            if (currentValue.devHubUsername) {
                output.scratchOrgs.push(currentValue);
            }
            else {
                output.nonScratchOrgs.push(currentValue);
            }
        }
        return output;
    }
    /**
     * Helper utility to remove sensitive information from a scratch org auth config. By default refreshTokens and client secrets are removed.
     *
     * @param {*} config - scratch org auth object.
     * @param {string[]} properties - properties to exclude ex ['refreshToken', 'clientSecret']
     * @returns the config less the sensitive information.
     */
    static removeRestrictedInfoFromConfig(config, properties = ['refreshToken', 'clientSecret']) {
        return (0, lib_1.omit)(config, properties);
    }
    /** Identify the default orgs */
    static identifyDefaultOrgs(orgInfo, config) {
        if (config['target-org'] && (orgInfo.username === config['target-org'] || orgInfo.alias === config['target-org'])) {
            orgInfo.isDefaultUsername = true;
        }
        else if (config['target-dev-hub'] &&
            (orgInfo.username === config['target-dev-hub'] || orgInfo.alias === config['target-dev-hub'])) {
            orgInfo.isDefaultDevHubUsername = true;
        }
    }
    static async retrieveScratchOrgInfoFromDevHub(devHubUsername, orgIdsToQuery) {
        const fields = [
            'CreatedDate',
            'Edition',
            'Status',
            'ExpirationDate',
            'Namespace',
            'OrgName',
            'CreatedBy.Username',
            'SignupUsername',
        ];
        try {
            const devHubOrg = await core_1.Org.create({ aliasOrUsername: devHubUsername });
            const conn = devHubOrg.getConnection();
            const data = await conn
                .sobject('ScratchOrgInfo')
                .find({ ScratchOrg: { $in: orgIdsToQuery } }, fields);
            return data.map((org) => ({
                ...org,
                devHubOrgId: devHubOrg.getOrgId(),
            }));
        }
        catch (err) {
            const logger = await OrgListUtil.retrieveLogger();
            logger.warn(`Error querying ${devHubUsername} for ${orgIdsToQuery.length} orgIds`);
            return [];
        }
    }
    static async reduceScratchOrgInfo(updatedContents, orgs) {
        // Reduce the information to key value pairs with signupUsername as key
        const contentMap = updatedContents.reduce((map, scratchOrgInfo) => {
            if (scratchOrgInfo) {
                map[scratchOrgInfo.SignupUsername] = scratchOrgInfo;
            }
            return map;
        }, {});
        for (const scratchOrgInfo of orgs) {
            const updatedOrgInfo = contentMap[scratchOrgInfo.username];
            if (updatedOrgInfo) {
                scratchOrgInfo.signupUsername = updatedOrgInfo.SignupUsername;
                scratchOrgInfo.createdBy = updatedOrgInfo.CreatedBy.Username;
                scratchOrgInfo.createdDate = updatedOrgInfo.CreatedDate;
                scratchOrgInfo.devHubOrgId = updatedOrgInfo.devHubOrgId;
                scratchOrgInfo.attributes = updatedOrgInfo.attributes;
                scratchOrgInfo.orgName = updatedOrgInfo.OrgName;
                scratchOrgInfo.edition = updatedOrgInfo.Edition;
                scratchOrgInfo.status = updatedOrgInfo.Status;
                scratchOrgInfo.expirationDate = updatedOrgInfo.ExpirationDate;
                scratchOrgInfo.isExpired = updatedOrgInfo.Status === 'Deleted';
                scratchOrgInfo.namespace = updatedOrgInfo.Namespace;
            }
            else {
                const logger = await OrgListUtil.retrieveLogger();
                logger.warn(`Can't find ${scratchOrgInfo.username} in the updated contents`);
            }
        }
        return orgs;
    }
    /**
     * Asks the org if it's a devHub.  Because the dev hub setting can't be deactivated, only ask orgs that aren't already stored as hubs.
     * This has a number of side effects, including updating the AuthInfo files and
     *
     * @param username org to check for devHub status
     * @returns {Promise.<boolean>}
     */
    static async checkNonScratchOrgIsDevHub(username) {
        try {
            const org = await core_1.Org.create({ aliasOrUsername: username });
            // true forces a server check instead of relying on AuthInfo file cache
            return org.determineIfDevHubOrg(true);
        }
        catch {
            return false;
        }
    }
    /**
     * retrieves the connection info of an nonscratch org
     *
     * @param username The username used when the org was authenticated
     * @returns {Promise.<string>}
     */
    static async determineConnectedStatusForNonScratchOrg(username) {
        var _a, _b, _c;
        try {
            const org = await core_1.Org.create({ aliasOrUsername: username });
            if (org.getField(core_1.Org.Fields.DEV_HUB_USERNAME)) {
                return;
            }
            try {
                await org.refreshAuth();
                return 'Connected';
            }
            catch (err) {
                const error = err;
                const logger = await OrgListUtil.retrieveLogger();
                logger.trace(`error refreshing auth for org: ${org.getUsername()}`);
                logger.trace(error);
                return ((_a = error.code) !== null && _a !== void 0 ? _a : error.message);
            }
        }
        catch (err) {
            const error = err;
            const logger = await OrgListUtil.retrieveLogger();
            logger.trace(`error refreshing auth for org: ${username}`);
            logger.trace(error);
            return ((_c = (_b = error.code) !== null && _b !== void 0 ? _b : error.message) !== null && _c !== void 0 ? _c : 'Unknown');
        }
    }
}
exports.OrgListUtil = OrgListUtil;
const identifyActiveOrgByStatus = (org) => {
    return org.status === 'Active';
};
exports.identifyActiveOrgByStatus = identifyActiveOrgByStatus;
//# sourceMappingURL=orgListUtil.js.map