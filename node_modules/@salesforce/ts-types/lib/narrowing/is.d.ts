import { AnyConstructor, AnyFunction, AnyJson, Dictionary, JsonArray, JsonMap, KeyOf, Optional } from '../types';
/**
 * Tests whether an `unknown` value is a `string`.
 *
 * @param value The value to test.
 */
export declare function isString(value: unknown): value is string;
/**
 * Tests whether an `unknown` value is a `number`.
 *
 * @param value The value to test.
 */
export declare function isNumber(value: unknown): value is number;
/**
 * Tests whether an `unknown` value is a `boolean`.
 *
 * @param value The value to test.
 */
export declare function isBoolean(value: unknown): value is boolean;
/**
 * Tests whether an `unknown` value is an `Object` subtype (e.g., arrays, functions, objects, regexes,
 * new Number(0), new String(''), and new Boolean(true)). Tests that wish to distinguish objects that
 * were created from literals or that otherwise were not created via a non-`Object` constructor and do
 * not have a prototype chain should instead use {@link isPlainObject}.
 *
 * Use of the type parameter `T` to further narrow the type signature of the value being tested is
 * strongly discouraged unless you are completely confident that the value is of the necessary shape to
 * conform with `T`. This function does nothing at either compile time or runtime to prove the value is of
 * shape `T`, so doing so amounts to nothing more than performing a type assertion, which is generally a
 * bad practice unless you have performed some other due diligence in proving that the value must be of
 * shape `T`. Use of the functions in the `has` co-library are useful for performing such full or partial
 * proofs.
 *
 * @param value The value to test.
 */
export declare function isObject<T extends object = object>(value: unknown): value is T;
/**
 * Tests whether an `unknown` value is a `function`.
 *
 * @param value The value to test.
 */
export declare function isFunction<T extends Function = AnyFunction>(value: unknown): value is T;
/**
 * Tests whether or not an `unknown` value is a plain JavaScript object. That is, if it is an object created
 * by the Object constructor or one with a null `prototype`.
 *
 * Use of the type parameter `T` to further narrow the type signature of the value being tested is
 * strongly discouraged unless you are completely confident that the value is of the necessary shape to
 * conform with `T`. This function does nothing at either compile time or runtime to prove the value is of
 * shape `T`, so doing so amounts to nothing more than performing a type assertion, which is generally a
 * bad practice unless you have performed some other due diligence in proving that the value must be of
 * shape `T`. Use of the functions in the `has` co-library are useful for performing such full or partial
 * proofs.
 *
 * @param value The value to test.
 */
export declare function isPlainObject<T extends object = object>(value: unknown): value is T;
/**
 * A shortcut for testing the suitability of a value to be used as a `Dictionary<T>` type.  Shorthand for
 * writing `isPlainObject<Dictionary<T>>(value)`.  While some non-plain-object types are compatible with
 * index signatures, they were less typically used as such, so this function focuses on the 80% case.
 *
 * Use of the type parameter `T` to further narrow the type signature of the value being tested is
 * strongly discouraged unless you are completely confident that the value is of the necessary shape to
 * conform with `T`. This function does nothing at either compile time or runtime to prove the value is of
 * shape `T`, so doing so amounts to nothing more than performing a type assertion, which is generally a
 * bad practice unless you have performed some other due diligence in proving that the value must be of
 * shape `T`. Use of the functions in the `has` co-library are useful for performing such full or partial
 * proofs.
 *
 * @param value The value to test.
 */
export declare function isDictionary<T = unknown>(value: unknown): value is Dictionary<T>;
/**
 * Tests whether an `unknown` value is a `function`.
 *
 * @param value The value to test.
 */
export declare function isInstance<C extends AnyConstructor>(value: unknown, ctor: C): value is InstanceType<C>;
/**
 * Tests whether an `unknown` value is a class constructor that is either equal to or extends another class
 * constructor.
 *
 * @param value The value to test.
 * @param cls The class to test against.
 */
export declare function isClassAssignableTo<C extends AnyConstructor>(value: unknown, cls: C): value is C;
/**
 * Tests whether an `unknown` value is an `Array`.
 *
 * Use of the type parameter `T` to further narrow the type signature of the value being tested is
 * strongly discouraged unless you are completely confident that the value is of the necessary shape to
 * conform with `T`. This function does nothing at either compile time or runtime to prove the value is of
 * shape `T`, so doing so amounts to nothing more than performing a type assertion, which is generally a
 * bad practice unless you have performed some other due diligence in proving that the value must be of
 * shape `T`. Use of the functions in the `has` co-library are useful for performing such full or partial
 * proofs.
 *
 * @param value The value to test.
 */
export declare function isArray<T = unknown>(value: unknown): value is T[];
/**
 * Tests whether an `unknown` value conforms to {@link AnyArrayLike}.
 *
 * Use of the type parameter `T` to further narrow the type signature of the value being tested is
 * strongly discouraged unless you are completely confident that the value is of the necessary shape to
 * conform with `T`. This function does nothing at either compile time or runtime to prove the value is of
 * shape `T`, so doing so amounts to nothing more than performing a type assertion, which is generally a
 * bad practice unless you have performed some other due diligence in proving that the value must be of
 * shape `T`. Use of the functions in the `has` co-library are useful for performing such full or partial
 * proofs.
 *
 * @param value The value to test.
 */
export declare function isArrayLike<T = unknown>(value: unknown): value is ArrayLike<T>;
/**
 * Tests whether `unknown` value is a valid JSON type. Note that objects and arrays are only checked using a shallow
 * test. To be sure that a given value is JSON-compatible at runtime, see {@link toAnyJson}.
 *
 * @param value The value to test.
 */
export declare function isAnyJson(value: unknown): value is AnyJson;
/**
 * Tests whether an `AnyJson` value is an object.
 *
 * @param value The value to test.
 */
export declare function isJsonMap(value: Optional<AnyJson>): value is JsonMap;
/**
 * Tests whether an `AnyJson` value is an array.
 *
 * @param value The value to test.
 */
export declare function isJsonArray(value: Optional<AnyJson>): value is JsonArray;
/**
 * Tests whether or not a `key` string is a key of the given object type `T`.
 *
 * @param obj The target object to check the key in.
 * @param key The string to test as a key of the target object.
 */
export declare function isKeyOf<T extends object, K extends KeyOf<T>>(obj: T, key: string): key is K;
