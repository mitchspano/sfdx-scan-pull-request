"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasJsonArray = exports.hasJsonMap = exports.hasAnyJson = exports.hasFunction = exports.hasArray = exports.hasInstance = exports.hasDictionary = exports.hasPlainObject = exports.hasObject = exports.hasBoolean = exports.hasNumber = exports.hasString = exports.has = void 0;
const is_1 = require("./is");
/**
 * Tests whether a value of type `T` contains one or more property `keys`. If so, the type of the tested value is
 * narrowed to reflect the existence of those keys for convenient access in the same scope. Returns false if the
 * property key does not exist on the target type, which must be an object. Returns true if the property key exists,
 * even if the associated value is `undefined` or `null`.
 *
 * ```
 * // type of obj -> unknown
 * if (has(obj, 'name')) {
 *   // type of obj -> { name: unknown }
 *   if (has(obj, 'data')) {
 *     // type of obj -> { name: unknown } & { data: unknown }
 *   } else if (has(obj, ['error', 'status'])) {
 *     // type of obj -> { name: unknown } & { error: unknown, status: unknown }
 *   }
 * }
 * ```
 *
 * @param value The value to test.
 * @param keys One or more `string` keys to check for existence.
 */
function has(value, keys) {
    return is_1.isObject(value) && (is_1.isArray(keys) ? keys.every((k) => k in value) : keys in value);
}
exports.has = has;
/**
 * Tests whether a value of type `T` contains a property `key` of type `string`. If so, the type of the tested value is
 * narrowed to reflect the existence of that key for convenient access in the same scope. Returns `false` if the
 * property key does not exist on the object or the value stored by that key is not of type `string`.
 *
 * ```
 * // type of obj -> unknown
 * if (hasString(obj, 'name')) {
 *   // type of obj -> { name: string }
 *   if (hasString(obj, 'message')) {
 *     // type of obj -> { name: string } & { message: string }
 *   }
 * }
 * ```
 *
 * @param value The value to test.
 * @param keys A `string` key to check for existence.
 */
function hasString(value, key) {
    return has(value, key) && is_1.isString(value[key]);
}
exports.hasString = hasString;
/**
 * Tests whether a value of type `T` contains a property `key` of type `number`. If so, the type of the tested value is
 * narrowed to reflect the existence of that key for convenient access in the same scope. Returns `false` if the
 * property key does not exist on the object or the value stored by that key is not of type `number`.
 *
 * ```
 * // type of obj -> unknown
 * if (hasNumber(obj, 'offset')) {
 *   // type of obj -> { offset: number }
 *   if (hasNumber(obj, 'page') && hasArray(obj, 'items')) {
 *     // type of obj -> { offset: number } & { page: number } & { items: unknown[] }
 *   }
 * }
 * ```
 *
 * @param value The value to test.
 * @param keys A `number` key to check for existence.
 */
function hasNumber(value, key) {
    return has(value, key) && is_1.isNumber(value[key]);
}
exports.hasNumber = hasNumber;
/**
 * Tests whether a value of type `T` contains a property `key` of type `boolean`. If so, the type of the tested value is
 * narrowed to reflect the existence of that key for convenient access in the same scope. Returns `false` if the
 * property key does not exist on the object or the value stored by that key is not of type `boolean`.
 *
 * ```
 * // type of obj -> unknown
 * if (hasBoolean(obj, 'enabled')) {
 *   // type of obj -> { enabled: boolean }
 *   if (hasBoolean(obj, 'hidden')) {
 *     // type of obj -> { enabled: boolean } & { hidden: boolean }
 *   }
 * }
 * ```
 *
 * @param value The value to test.
 * @param keys A `boolean` key to check for existence.
 */
function hasBoolean(value, key) {
    return has(value, key) && is_1.isBoolean(value[key]);
}
exports.hasBoolean = hasBoolean;
/**
 * Tests whether a value of type `T` contains a property `key` of type `object`. If so, the type of the tested value is
 * narrowed to reflect the existence of that key for convenient access in the same scope. Returns `false` if the
 * property key does not exist on the object or the value stored by that key is not of type `object`.
 *
 * ```
 * // type of obj -> unknown
 * if (hasNumber(obj, 'status')) {
 *   // type of obj -> { status: number }
 *   if (hasObject(obj, 'data')) {
 *     // type of obj -> { status: number } & { data: object }
 *   } else if (hasString('error')) {
 *     // type of obj -> { status: number } & { error: string }
 *   }
 * }
 * ```
 *
 * @param value The value to test.
 * @param keys An `object` key to check for existence.
 */
function hasObject(value, key) {
    return has(value, key) && is_1.isObject(value[key]);
}
exports.hasObject = hasObject;
/**
 * Tests whether a value of type `T` contains a property `key` whose type tests positively when tested with
 * {@link isPlainObject}. If so, the type of the tested value is narrowed to reflect the existence of that key for
 * convenient access in the same scope. Returns `false` if the property key does not exist on the object or the value
 * stored by that key is not of type `object`.
 *
 * ```
 * // type of obj -> unknown
 * if (hasNumber(obj, 'status')) {
 *   // type of obj -> { status: number }
 *   if (hasPlainObject(obj, 'data')) {
 *     // type of obj -> { status: number } & { data: object }
 *   } else if (hasString('error')) {
 *     // type of obj -> { status: number } & { error: string }
 *   }
 * }
 * ```
 *
 * @param value The value to test.
 * @param keys A "plain" `object` key to check for existence.
 */
function hasPlainObject(value, key) {
    return has(value, key) && is_1.isPlainObject(value[key]);
}
exports.hasPlainObject = hasPlainObject;
/**
 * Tests whether a value of type `T` contains a property `key` whose type tests positively when tested with
 * {@link isDictionary}. If so, the type of the tested value is narrowed to reflect the existence of that key for
 * convenient access in the same scope. Returns `false` if the property key does not exist on the object or the value
 * stored by that key is not of type `object`.
 *
 * ```
 * // type of obj -> unknown
 * if (hasNumber(obj, 'status')) {
 *   // type of obj -> { status: number }
 *   if (hasDictionary(obj, 'data')) {
 *     // type of obj -> { status: number } & { data: Dictionary }
 *   } else if (hasString('error')) {
 *     // type of obj -> { status: number } & { error: string }
 *   }
 * }
 * ```
 *
 * @param value The value to test.
 * @param keys A "dictionary" `object` key to check for existence.
 */
function hasDictionary(value, key) {
    return has(value, key) && is_1.isDictionary(value[key]);
}
exports.hasDictionary = hasDictionary;
/**
 * Tests whether a value of type `T` contains a property `key` whose type tests positively when tested with
 * {@link isInstance} when compared with the given constructor type `C`. If so, the type of the tested value is
 * narrowed to reflect the existence of that key for convenient access in the same scope. Returns `false` if the
 * property key does not exist on the object or the value stored by that key is not an instance of `C`.
 *
 * ```
 * class ServerResponse { ... }
 * // type of obj -> unknown
 * if (hasNumber(obj, 'status')) {
 *   // type of obj -> { status: number }
 *   if (hasInstance(obj, 'data', ServerResponse)) {
 *     // type of obj -> { status: number } & { data: ServerResponse }
 *   } else if (hasString('error')) {
 *     // type of obj -> { status: number } & { error: string }
 *   }
 * }
 * ```
 *
 * @param value The value to test.
 * @param keys An instance of type `C` key to check for existence.
 */
function hasInstance(value, key, ctor) {
    return has(value, key) && value[key] instanceof ctor;
}
exports.hasInstance = hasInstance;
/**
 * Tests whether a value of type `T` contains a property `key` of type {@link AnyArray}. If so, the type of the tested
 * value is narrowed to reflect the existence of that key for convenient access in the same scope. Returns `false` if
 * the property key does not exist on the object or the value stored by that key is not of type {@link AnyArray}.
 *
 * ```
 * // type of obj -> unknown
 * if (hasNumber(obj, 'offset')) {
 *   // type of obj -> { offset: number }
 *   if (hasNumber(obj, 'page') && hasArray(obj, 'items')) {
 *     // type of obj -> { offset: number } & { page: number } & { items: AnyArray }
 *   }
 * }
 * ```
 *
 * @param value The value to test.
 * @param keys An `AnyArray` key to check for existence.
 */
function hasArray(value, key) {
    return has(value, key) && is_1.isArray(value[key]);
}
exports.hasArray = hasArray;
/**
 * Tests whether a value of type `T` contains a property `key` of type {@link AnyFunction}. If so, the type of the
 * tested value is narrowed to reflect the existence of that key for convenient access in the same scope. Returns
 * `false` if the property key does not exist on the object or the value stored by that key is not of type
 * {@link AnyFunction}.
 *
 * ```
 * // type of obj -> unknown
 * if (hasFunction(obj, 'callback')) {
 *   // type of obj -> { callback: AnyFunction }
 *   obj.callback(response);
 * }
 * ```
 *
 * @param value The value to test.
 * @param keys An `AnyFunction` key to check for existence.
 */
function hasFunction(value, key) {
    return has(value, key) && is_1.isFunction(value[key]);
}
exports.hasFunction = hasFunction;
/**
 * Tests whether a value of type `T` contains a property `key` of type {@link AnyJson}, _using a shallow test for
 * `AnyJson` compatibility_ (see {@link isAnyJson} for more information). If so, the type of the
 * tested value is narrowed to reflect the existence of that key for convenient access in the same scope. Returns
 * `false` if the property key does not exist on the object or the value stored by that key is not of type
 * {@link AnyJson}.
 *
 * ```
 * // type of obj -> unknown
 * if (hasAnyJson(obj, 'body')) {
 *   // type of obj -> { body: AnyJson }
 * }
 * ```
 *
 * @param value The value to test.
 * @param keys An `AnyJson` key to check for existence.
 */
function hasAnyJson(value, key) {
    return has(value, key) && is_1.isAnyJson(value[key]);
}
exports.hasAnyJson = hasAnyJson;
/**
 * Tests whether a value of type `T extends AnyJson` contains a property `key` of type {@link JsonMap}. If so, the type
 * of the tested value is narrowed to reflect the existence of that key for convenient access in the same scope. Returns
 * `false` if the property key does not exist on the object or the value stored by that key is not of type
 * {@link JsonMap}.
 *
 * ```
 * // type of obj -> unknown
 * if (hasJsonMap(obj, 'body')) {
 *   // type of obj -> { body: JsonMap }
 * }
 * ```
 *
 * @param value The value to test.
 * @param keys A `JsonMap` key to check for existence.
 */
function hasJsonMap(value, key) {
    return hasAnyJson(value, key) && is_1.isJsonMap(value[key]);
}
exports.hasJsonMap = hasJsonMap;
/**
 * Tests whether a value of type `T extends AnyJson` contains a property `key` of type {@link JsonArray}. If so, the
 * type of the tested value is narrowed to reflect the existence of that key for convenient access in the same scope.
 * Returns `false` if the property key does not exist on the object or the value stored by that key is not of type
 * {@link JsonArray}.
 *
 * ```
 * // type of obj -> unknown
 * if (hasJsonArray(obj, 'body')) {
 *   // type of obj -> { body: JsonArray }
 * }
 * ```
 *
 * @param value The value to test.
 * @param keys A `JsonArray` key to check for existence.
 */
function hasJsonArray(value, key) {
    return hasAnyJson(value, key) && is_1.isJsonArray(value[key]);
}
exports.hasJsonArray = hasJsonArray;
//# sourceMappingURL=has.js.map