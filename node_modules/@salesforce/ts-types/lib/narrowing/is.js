"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isKeyOf = exports.isJsonArray = exports.isJsonMap = exports.isAnyJson = exports.isArrayLike = exports.isArray = exports.isClassAssignableTo = exports.isInstance = exports.isDictionary = exports.isPlainObject = exports.isFunction = exports.isObject = exports.isBoolean = exports.isNumber = exports.isString = void 0;
/**
 * Tests whether an `unknown` value is a `string`.
 *
 * @param value The value to test.
 */
function isString(value) {
    return typeof value === 'string';
}
exports.isString = isString;
/**
 * Tests whether an `unknown` value is a `number`.
 *
 * @param value The value to test.
 */
function isNumber(value) {
    return typeof value === 'number';
}
exports.isNumber = isNumber;
/**
 * Tests whether an `unknown` value is a `boolean`.
 *
 * @param value The value to test.
 */
function isBoolean(value) {
    return typeof value === 'boolean';
}
exports.isBoolean = isBoolean;
/**
 * Tests whether an `unknown` value is an `Object` subtype (e.g., arrays, functions, objects, regexes,
 * new Number(0), new String(''), and new Boolean(true)). Tests that wish to distinguish objects that
 * were created from literals or that otherwise were not created via a non-`Object` constructor and do
 * not have a prototype chain should instead use {@link isPlainObject}.
 *
 * Use of the type parameter `T` to further narrow the type signature of the value being tested is
 * strongly discouraged unless you are completely confident that the value is of the necessary shape to
 * conform with `T`. This function does nothing at either compile time or runtime to prove the value is of
 * shape `T`, so doing so amounts to nothing more than performing a type assertion, which is generally a
 * bad practice unless you have performed some other due diligence in proving that the value must be of
 * shape `T`. Use of the functions in the `has` co-library are useful for performing such full or partial
 * proofs.
 *
 * @param value The value to test.
 */
function isObject(value) {
    return value != null && (typeof value === 'object' || typeof value === 'function');
}
exports.isObject = isObject;
/**
 * Tests whether an `unknown` value is a `function`.
 *
 * @param value The value to test.
 */
function isFunction(value) {
    return typeof value === 'function';
}
exports.isFunction = isFunction;
/**
 * Tests whether or not an `unknown` value is a plain JavaScript object. That is, if it is an object created
 * by the Object constructor or one with a null `prototype`.
 *
 * Use of the type parameter `T` to further narrow the type signature of the value being tested is
 * strongly discouraged unless you are completely confident that the value is of the necessary shape to
 * conform with `T`. This function does nothing at either compile time or runtime to prove the value is of
 * shape `T`, so doing so amounts to nothing more than performing a type assertion, which is generally a
 * bad practice unless you have performed some other due diligence in proving that the value must be of
 * shape `T`. Use of the functions in the `has` co-library are useful for performing such full or partial
 * proofs.
 *
 * @param value The value to test.
 */
function isPlainObject(value) {
    const isObjectObject = (o) => isObject(o) && Object.prototype.toString.call(o) === '[object Object]';
    if (!isObjectObject(value))
        return false;
    const ctor = value.constructor;
    if (!isFunction(ctor))
        return false;
    if (!isObjectObject(ctor.prototype))
        return false;
    // eslint-disable-next-line no-prototype-builtins
    if (!ctor.prototype.hasOwnProperty('isPrototypeOf'))
        return false;
    return true;
}
exports.isPlainObject = isPlainObject;
/**
 * A shortcut for testing the suitability of a value to be used as a `Dictionary<T>` type.  Shorthand for
 * writing `isPlainObject<Dictionary<T>>(value)`.  While some non-plain-object types are compatible with
 * index signatures, they were less typically used as such, so this function focuses on the 80% case.
 *
 * Use of the type parameter `T` to further narrow the type signature of the value being tested is
 * strongly discouraged unless you are completely confident that the value is of the necessary shape to
 * conform with `T`. This function does nothing at either compile time or runtime to prove the value is of
 * shape `T`, so doing so amounts to nothing more than performing a type assertion, which is generally a
 * bad practice unless you have performed some other due diligence in proving that the value must be of
 * shape `T`. Use of the functions in the `has` co-library are useful for performing such full or partial
 * proofs.
 *
 * @param value The value to test.
 */
function isDictionary(value) {
    return isPlainObject(value);
}
exports.isDictionary = isDictionary;
/**
 * Tests whether an `unknown` value is a `function`.
 *
 * @param value The value to test.
 */
function isInstance(value, ctor) {
    return value instanceof ctor;
}
exports.isInstance = isInstance;
/**
 * Tests whether an `unknown` value is a class constructor that is either equal to or extends another class
 * constructor.
 *
 * @param value The value to test.
 * @param cls The class to test against.
 */
function isClassAssignableTo(value, cls) {
    // avoid circular dependency with has.ts
    const has = (v, k) => isObject(v) && k in v;
    return value === cls || (has(value, 'prototype') && value.prototype instanceof cls);
}
exports.isClassAssignableTo = isClassAssignableTo;
/**
 * Tests whether an `unknown` value is an `Array`.
 *
 * Use of the type parameter `T` to further narrow the type signature of the value being tested is
 * strongly discouraged unless you are completely confident that the value is of the necessary shape to
 * conform with `T`. This function does nothing at either compile time or runtime to prove the value is of
 * shape `T`, so doing so amounts to nothing more than performing a type assertion, which is generally a
 * bad practice unless you have performed some other due diligence in proving that the value must be of
 * shape `T`. Use of the functions in the `has` co-library are useful for performing such full or partial
 * proofs.
 *
 * @param value The value to test.
 */
function isArray(value) {
    return Array.isArray(value);
}
exports.isArray = isArray;
/**
 * Tests whether an `unknown` value conforms to {@link AnyArrayLike}.
 *
 * Use of the type parameter `T` to further narrow the type signature of the value being tested is
 * strongly discouraged unless you are completely confident that the value is of the necessary shape to
 * conform with `T`. This function does nothing at either compile time or runtime to prove the value is of
 * shape `T`, so doing so amounts to nothing more than performing a type assertion, which is generally a
 * bad practice unless you have performed some other due diligence in proving that the value must be of
 * shape `T`. Use of the functions in the `has` co-library are useful for performing such full or partial
 * proofs.
 *
 * @param value The value to test.
 */
function isArrayLike(value) {
    // avoid circular dependency with has.ts
    const hasLength = (v) => isObject(v) && 'length' in v;
    return !isFunction(value) && (isString(value) || hasLength(value));
}
exports.isArrayLike = isArrayLike;
/**
 * Tests whether `unknown` value is a valid JSON type. Note that objects and arrays are only checked using a shallow
 * test. To be sure that a given value is JSON-compatible at runtime, see {@link toAnyJson}.
 *
 * @param value The value to test.
 */
function isAnyJson(value) {
    return (value === null || isString(value) || isNumber(value) || isBoolean(value) || isPlainObject(value) || isArray(value));
}
exports.isAnyJson = isAnyJson;
/**
 * Tests whether an `AnyJson` value is an object.
 *
 * @param value The value to test.
 */
function isJsonMap(value) {
    return isPlainObject(value);
}
exports.isJsonMap = isJsonMap;
/**
 * Tests whether an `AnyJson` value is an array.
 *
 * @param value The value to test.
 */
function isJsonArray(value) {
    return isArray(value);
}
exports.isJsonArray = isJsonArray;
/**
 * Tests whether or not a `key` string is a key of the given object type `T`.
 *
 * @param obj The target object to check the key in.
 * @param key The string to test as a key of the target object.
 */
function isKeyOf(obj, key) {
    return Object.keys(obj).includes(key);
}
exports.isKeyOf = isKeyOf;
//# sourceMappingURL=is.js.map