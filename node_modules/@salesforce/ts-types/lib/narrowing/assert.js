"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertJsonArray = exports.assertJsonMap = exports.assertAnyJson = exports.assertFunction = exports.assertArray = exports.assertInstance = exports.assertDictionary = exports.assertPlainObject = exports.assertObject = exports.assertBoolean = exports.assertNumber = exports.assertString = exports.assertNonNull = exports.assert = void 0;
const errors_1 = require("../errors");
const as_1 = require("./as");
const to_1 = require("./to");
/**
 * Asserts that a given `condition` is true, or raises an error otherwise.
 *
 * @param condition The condition to test.
 * @param message The error message to use if the condition is false.
 * @throws {@link AssertionFailedError} If the assertion failed.
 */
function assert(condition, message) {
    if (!condition) {
        throw new errors_1.AssertionFailedError(message || 'Assertion condition was false');
    }
}
exports.assert = assert;
/**
 * Narrows a type `Nullable<T>` to a `T` or raises an error.
 *
 * Use of the type parameter `T` to further narrow the type signature of the value being tested is
 * strongly discouraged unless you are completely confident that the value is of the necessary shape to
 * conform with `T`. This function does nothing at either compile time or runtime to prove the value is of
 * shape `T`, so doing so amounts to nothing more than performing a type assertion, which is generally a
 * bad practice unless you have performed some other due diligence in proving that the value must be of
 * shape `T`. Use of the functions in the `has` co-library are useful for performing such full or partial
 * proofs.
 *
 * @param value The value to test.
 * @param message The error message to use if `value` is `undefined` or `null`.
 * @throws {@link AssertionFailedError} If the value was undefined.
 */
function assertNonNull(value, message) {
    assert(value != null, message || 'Value is not defined');
}
exports.assertNonNull = assertNonNull;
/**
 * Narrows an `unknown` value to a `string` if it is type-compatible, or raises an error otherwise.
 *
 * @param value The value to test.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link AssertionFailedError} If the value was undefined.
 */
function assertString(value, message) {
    assertNonNull(as_1.asString(value), message || 'Value is not a string');
}
exports.assertString = assertString;
/**
 * Narrows an `unknown` value to a `number` if it is type-compatible, or raises an error otherwise.
 *
 * @param value The value to test.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link AssertionFailedError} If the value was undefined.
 */
function assertNumber(value, message) {
    assertNonNull(as_1.asNumber(value), message || 'Value is not a number');
}
exports.assertNumber = assertNumber;
/**
 * Narrows an `unknown` value to a `boolean` if it is type-compatible, or raises an error otherwise.
 *
 * @param value The value to test.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link AssertionFailedError} If the value was undefined.
 */
function assertBoolean(value, message) {
    assertNonNull(as_1.asBoolean(value), message || 'Value is not a boolean');
}
exports.assertBoolean = assertBoolean;
/**
 * Narrows an `unknown` value to an `object` if it is type-compatible, or raises an error otherwise.
 *
 * @param value The value to test.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link AssertionFailedError} If the value was undefined.
 */
function assertObject(value, message) {
    assertNonNull(as_1.asObject(value), message || 'Value is not an object');
}
exports.assertObject = assertObject;
/**
 * Narrows an `unknown` value to an `object` if it is type-compatible and tests positively with {@link isPlainObject},
 * or raises an error otherwise.
 *
 * @param value The value to test.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link AssertionFailedError} If the value was undefined.
 */
function assertPlainObject(value, message) {
    assertNonNull(as_1.asPlainObject(value), message || 'Value is not a plain object');
}
exports.assertPlainObject = assertPlainObject;
/**
 * Narrows an `unknown` value to a `Dictionary<T>` if it is type-compatible and tests positively
 * with {@link isDictionary}, or raises an error otherwise.
 *
 * @param value The value to test.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link AssertionFailedError} If the value was undefined.
 */
function assertDictionary(value, message) {
    assertNonNull(as_1.asDictionary(value), message || 'Value is not a dictionary object');
}
exports.assertDictionary = assertDictionary;
/**
 * Narrows an `unknown` value to instance of constructor type `T` if it is type-compatible, or raises an error
 * otherwise.
 *
 * @param value The value to test.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link AssertionFailedError} If the value was undefined.
 */
function assertInstance(value, ctor, message) {
    assertNonNull(as_1.asInstance(value, ctor), message || `Value is not an instance of ${ctor.name}`);
}
exports.assertInstance = assertInstance;
/**
 * Narrows an `unknown` value to an `Array` if it is type-compatible, or raises an error otherwise.
 *
 * @param value The value to test.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link AssertionFailedError} If the value was undefined.
 */
function assertArray(value, message) {
    assertNonNull(as_1.asArray(value), message || 'Value is not an array');
}
exports.assertArray = assertArray;
/**
 * Narrows an `unknown` value to an `AnyFunction` if it is type-compatible, or raises an error otherwise.
 *
 * @param value The value to test.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link AssertionFailedError} If the value was undefined.
 */
function assertFunction(value, message) {
    assertNonNull(as_1.asFunction(value), message || 'Value is not a function');
}
exports.assertFunction = assertFunction;
/**
 * Narrows an `unknown` value to an `AnyJson` if it is type-compatible, or returns `undefined` otherwise.
 *
 * See also caveats noted in {@link isAnyJson}.
 *
 * @param value The value to test.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link AssertionFailedError} If the value was not a JSON value type.
 */
function assertAnyJson(value, message) {
    assertNonNull(to_1.toAnyJson(value), message || 'Value is not a JSON-compatible value type');
}
exports.assertAnyJson = assertAnyJson;
/**
 * Narrows an `AnyJson` value to a `JsonMap` if it is type-compatible, or raises an error otherwise.
 *
 * @param value The value to test.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link AssertionFailedError} If the value was undefined.
 */
function assertJsonMap(value, message) {
    assertNonNull(as_1.asJsonMap(value), message || 'Value is not a JsonMap');
}
exports.assertJsonMap = assertJsonMap;
/**
 * Narrows an `AnyJson` value to a `JsonArray` if it is type-compatible, or raises an error otherwise.
 *
 * @param value The value to test.
 * @param message The error message to use if `value` is not type-compatible.
 * @throws {@link AssertionFailedError} If the value was undefined.
 */
function assertJsonArray(value, message) {
    assertNonNull(as_1.asJsonArray(value), message || 'Value is not a JsonArray');
}
exports.assertJsonArray = assertJsonArray;
//# sourceMappingURL=assert.js.map