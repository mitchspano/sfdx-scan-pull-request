"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverse = exports.resolveProjectPathSync = exports.resolveProjectPath = exports.SFDX_PROJECT_JSON = void 0;
const fs = require("fs");
const path_1 = require("path");
const messages_1 = require("../messages");
messages_1.Messages.importMessagesDirectory(__dirname);
const messages = messages_1.Messages.load('@salesforce/core', 'config', ['invalidProjectWorkspace']);
/**
 * The name of the project config file.
 *
 * @ignore
 */
// This has to be defined on util to prevent circular deps with project and configFile.
exports.SFDX_PROJECT_JSON = 'sfdx-project.json';
/**
 * Performs an upward directory search for an sfdx project file. Returns the absolute path to the project.
 *
 * **See** {@link SFDX_PROJECT_JSON}
 *
 * **See** {@link traverseForFile}
 *
 * **Throws** *{@link SfError}{ name: 'InvalidProjectWorkspaceError' }* If the current folder is not located in a workspace.
 *
 * @param dir The directory path to start traversing from.
 * @ignore
 */
async function resolveProjectPath(dir = process.cwd()) {
    const projectPath = await exports.traverse.forFile(dir, exports.SFDX_PROJECT_JSON);
    if (!projectPath) {
        throw messages.createError('invalidProjectWorkspace');
    }
    return projectPath;
}
exports.resolveProjectPath = resolveProjectPath;
/**
 * Performs a synchronous upward directory search for an sfdx project file. Returns the absolute path to the project.
 *
 * **See** {@link SFDX_PROJECT_JSON}
 *
 * **See** {@link traverseForFile}
 *
 * **Throws** *{@link SfError}{ name: 'InvalidProjectWorkspaceError' }* If the current folder is not located in a workspace.
 *
 * @param dir The directory path to start traversing from.
 * @ignore
 */
function resolveProjectPathSync(dir = process.cwd()) {
    const projectPath = exports.traverse.forFileSync(dir, exports.SFDX_PROJECT_JSON);
    if (!projectPath) {
        throw messages.createError('invalidProjectWorkspace');
    }
    return projectPath;
}
exports.resolveProjectPathSync = resolveProjectPathSync;
/**
 * These methods were moved from the deprecated 'fs' module in v2 and are only used in sfdx-core above
 *
 * They were migrated into the 'traverse' constant in order to stub them in unit tests
 */
exports.traverse = {
    /**
     * Searches a file path in an ascending manner (until reaching the filesystem root) for the first occurrence a
     * specific file name.  Resolves with the directory path containing the located file, or `null` if the file was
     * not found.
     *
     * @param dir The directory path in which to start the upward search.
     * @param file The file name to look for.
     */
    forFile: async (dir, file) => {
        let foundProjectDir;
        try {
            fs.statSync((0, path_1.join)(dir, file));
            foundProjectDir = dir;
        }
        catch (err) {
            if (err && err.code === 'ENOENT') {
                const nextDir = (0, path_1.resolve)(dir, '..');
                if (nextDir !== dir) {
                    // stop at root
                    foundProjectDir = await exports.traverse.forFile(nextDir, file);
                }
            }
        }
        return foundProjectDir;
    },
    /**
     * Searches a file path synchronously in an ascending manner (until reaching the filesystem root) for the first occurrence a
     * specific file name.  Resolves with the directory path containing the located file, or `null` if the file was
     * not found.
     *
     * @param dir The directory path in which to start the upward search.
     * @param file The file name to look for.
     */
    forFileSync: (dir, file) => {
        let foundProjectDir;
        try {
            fs.statSync((0, path_1.join)(dir, file));
            foundProjectDir = dir;
        }
        catch (err) {
            if (err && err.code === 'ENOENT') {
                const nextDir = (0, path_1.resolve)(dir, '..');
                if (nextDir !== dir) {
                    // stop at root
                    foundProjectDir = exports.traverse.forFileSync(nextDir, file);
                }
            }
        }
        return foundProjectDir;
    },
};
//# sourceMappingURL=internal.js.map