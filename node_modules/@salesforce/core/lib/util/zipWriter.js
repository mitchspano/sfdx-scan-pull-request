"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZipWriter = void 0;
const fs_1 = require("fs");
const stream_1 = require("stream");
const util_1 = require("util");
const archiver_1 = require("archiver");
const pipeline = (0, util_1.promisify)(stream_1.pipeline);
class ZipWriter extends stream_1.Writable {
    constructor(rootDestination) {
        super({ objectMode: true });
        this.rootDestination = rootDestination;
        // compression-/speed+ (0)<---(3)---------->(9) compression+/speed-
        // 3 appears to be a decent balance of compression and speed. It felt like
        // higher values = diminishing returns on compression and made conversion slower
        this.zip = (0, archiver_1.create)('zip', { zlib: { level: 3 } });
        this.buffers = [];
        void pipeline(this.zip, this.getOutputStream());
    }
    async addToStore(contents, path) {
        this.zip.append(contents, { name: path });
        return Promise.resolve();
    }
    async finalize() {
        await this.zip.finalize();
        await this.getInputBuffer();
    }
    getDestinationPath() {
        return this.rootDestination;
    }
    getOutputStream() {
        if (this.rootDestination) {
            return (0, fs_1.createWriteStream)(this.rootDestination);
        }
        else {
            const bufferWritable = new stream_1.Writable();
            // eslint-disable-next-line no-underscore-dangle
            bufferWritable._write = (chunk, encoding, cb) => {
                this.buffers.push(chunk);
                cb();
            };
            return bufferWritable;
        }
    }
    async getInputBuffer() {
        if (this.rootDestination) {
            const inputStream = (0, fs_1.createReadStream)(this.rootDestination);
            return new Promise((resolve, reject) => {
                inputStream.on('data', (chunk) => {
                    this.buffers.push(chunk);
                });
                inputStream.once('end', () => {
                    return resolve();
                });
                inputStream.once('error', (error) => {
                    return reject(error);
                });
            });
        }
    }
    get buffer() {
        return Buffer.concat(this.buffers);
    }
}
exports.ZipWriter = ZipWriter;
//# sourceMappingURL=zipWriter.js.map