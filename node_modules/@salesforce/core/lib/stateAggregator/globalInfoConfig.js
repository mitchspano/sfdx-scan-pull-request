"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalInfo = exports.deepCopy = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const ts_types_1 = require("@salesforce/ts-types");
const global_1 = require("../global");
const configFile_1 = require("../config/configFile");
const sfdxDataHandler_1 = require("./sfdxDataHandler");
const orgAccessor_1 = require("./accessors/orgAccessor");
const tokenAccessor_1 = require("./accessors/tokenAccessor");
const aliasAccessor_1 = require("./accessors/aliasAccessor");
const types_1 = require("./types");
const sandboxAccessor_1 = require("./accessors/sandboxAccessor");
function deepCopy(data) {
    return JSON.parse(JSON.stringify(data));
}
exports.deepCopy = deepCopy;
/**
 * @deprecated use StateAggregator instead.
 */
class GlobalInfo extends configFile_1.ConfigFile {
    constructor() {
        super(...arguments);
        this.sfdxHandler = new sfdxDataHandler_1.SfdxDataHandler();
    }
    static get emptyDataModel() {
        return deepCopy(GlobalInfo.EMPTY_DATA_MODEL);
    }
    static async getInstance() {
        if (!GlobalInfo.instance) {
            GlobalInfo.instance = await GlobalInfo.create();
        }
        return GlobalInfo.instance;
    }
    /**
     * Clear the cache to force reading from disk.
     *
     * *NOTE: Only call this method if you must and you know what you are doing.*
     */
    static clearInstance() {
        delete GlobalInfo.instance;
    }
    static getFileName() {
        return 'sf.json';
    }
    /**
     * Gets default options for the SfConfig
     */
    static getDefaultOptions() {
        return {
            isGlobal: true,
            isState: true,
            filename: GlobalInfo.getFileName(),
            stateFolder: global_1.Global.SF_STATE_FOLDER,
        };
    }
    get orgs() {
        return new orgAccessor_1.GlobalInfoOrgAccessor(this);
    }
    get tokens() {
        return new tokenAccessor_1.GlobaInfoTokenAccessor(this);
    }
    get aliases() {
        return new aliasAccessor_1.GlobalInfoAliasAccessor(this);
    }
    get sandboxes() {
        return new sandboxAccessor_1.GlobalInfoSandboxAccessor(this);
    }
    set(key, value) {
        if ((0, ts_types_1.isPlainObject)(value)) {
            value = this.timestamp(value);
        }
        super.set(key, value);
    }
    async write(newContents) {
        const result = await super.write(newContents);
        if (global_1.Global.SFDX_INTEROPERABILITY)
            await this.sfdxHandler.write(result);
        return result;
    }
    async init() {
        await this.initCrypto();
        const contents = global_1.Global.SFDX_INTEROPERABILITY ? await this.mergeWithSfdxData() : await this.loadSfData();
        this.setContents(contents);
    }
    timestamp(data) {
        return { ...data, timestamp: new Date() };
    }
    async loadSfData() {
        const data = await this.read();
        return { ...GlobalInfo.emptyDataModel, ...data };
    }
    async mergeWithSfdxData() {
        const sfData = await this.loadSfData();
        const merged = await this.sfdxHandler.merge(sfData);
        await this.write(merged);
        return merged;
    }
}
exports.GlobalInfo = GlobalInfo;
GlobalInfo.encryptedKeys = [/token/i, /password/i, /secret/i];
GlobalInfo.EMPTY_DATA_MODEL = {
    [types_1.SfInfoKeys.ORGS]: {},
    [types_1.SfInfoKeys.TOKENS]: {},
    [types_1.SfInfoKeys.ALIASES]: {},
    [types_1.SfInfoKeys.SANDBOXES]: {},
};
//# sourceMappingURL=globalInfoConfig.js.map