"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AliasAccessor = exports.GlobalInfoAliasAccessor = void 0;
const kit_1 = require("@salesforce/kit");
const aliasesConfig_1 = require("../../config/aliasesConfig");
const sfError_1 = require("../../sfError");
const types_1 = require("../types");
/**
 * @deprecated
 */
class GlobalInfoAliasAccessor {
    constructor(globalInfo) {
        this.globalInfo = globalInfo;
    }
    getAll(entity) {
        const all = this.globalInfo.get(types_1.SfInfoKeys.ALIASES) || {};
        if (entity) {
            const value = this.getNameOf(entity);
            return Object.entries(all)
                .filter((entry) => entry[1] === value)
                .map((entry) => entry[0]);
        }
        else {
            return all;
        }
    }
    /**
     * Returns the first alias found for a given entity
     *
     * @param entity the aliasable entity that you want to get the alias of
     */
    get(entity) {
        return this.getAll(entity).find((alias) => alias) ?? null;
    }
    /**
     * Returns the value that corresponds to the given alias if it exists
     *
     * @param alias the alias that corresponds to a value
     */
    getValue(alias) {
        return this.getAll()[alias] ?? null;
    }
    /**
     * Returns the username that corresponds to the given alias if it exists
     *
     * @param alias the alias that corresponds to a username
     */
    getUsername(alias) {
        return this.getAll()[alias] ?? null;
    }
    /**
     * If the provided string is an alias, it returns the corresponding value.
     * If the provided string is not an alias, we assume that the provided string
     * is the value and return it.
     *
     * This method is helpful when you don't know if the string you have is a value
     * or an alias.
     *
     * @param valueOrAlias a string that might be a value or might be an alias
     */
    resolveValue(valueOrAlias) {
        return this.getValue(valueOrAlias) ?? valueOrAlias;
    }
    /**
     * If the provided string is an alias, it returns the corresponding username.
     * If the provided string is not an alias, we assume that the provided string
     * is the username and return it.
     *
     * This method is helpful when you don't know if the string you have is a username
     * or an alias.
     *
     * @param usernameOrAlias a string that might be a username or might be an alias
     */
    resolveUsername(usernameOrAlias) {
        return this.getUsername(usernameOrAlias) ?? usernameOrAlias;
    }
    /**
     * Set an alias for the given aliasable entity
     *
     * @param alias the alias you want to set
     * @param entity the aliasable entity that's being aliased
     */
    set(alias, entity) {
        const value = this.getNameOf(entity);
        this.globalInfo.set(`${types_1.SfInfoKeys.ALIASES}["${alias}"]`, value);
    }
    /**
     * Updates the alias for the given aliasable entity
     *
     * @param alias the alias you want to set
     * @param entity the aliasable entity that's being aliased
     */
    update(alias, entity) {
        const value = this.getNameOf(entity);
        this.globalInfo.update(`${types_1.SfInfoKeys.ALIASES}["${alias}"]`, value);
    }
    unset(alias) {
        delete this.globalInfo.get(types_1.SfInfoKeys.ALIASES)[alias];
    }
    /**
     * This method unsets all the aliases for the given entity.
     *
     * @param entity the aliasable entity for which you want to unset all aliases
     */
    unsetAll(entity) {
        const aliases = this.getAll(entity);
        aliases.forEach((alias) => this.unset(alias));
    }
    /**
     * Returns the username of given aliasable entity
     */
    getNameOf(entity) {
        if (typeof entity === 'string')
            return entity;
        const aliaseeName = entity.username ?? entity.user;
        if (!aliaseeName) {
            throw new sfError_1.SfError(`Invalid aliasee, it must contain a user or username property: ${JSON.stringify(entity)}`);
        }
        return aliaseeName;
    }
}
exports.GlobalInfoAliasAccessor = GlobalInfoAliasAccessor;
class AliasAccessor extends kit_1.AsyncOptionalCreatable {
    getAll(entity) {
        // This will only return aliases under "orgs". This will need to be modified
        // if/when we want to support more aliases groups.
        const all = (this.config.getGroup() || {});
        if (entity) {
            const value = this.getNameOf(entity);
            return Object.entries(all)
                .filter((entry) => entry[1] === value)
                .map((entry) => entry[0]);
        }
        else {
            return all;
        }
    }
    /**
     * Returns the first alias found for a given entity
     *
     * @param entity the aliasable entity that you want to get the alias of
     */
    get(entity) {
        return this.getAll(entity).find((alias) => alias) ?? null;
    }
    /**
     * Returns the value that corresponds to the given alias if it exists
     *
     * @param alias the alias that corresponds to a value
     */
    getValue(alias) {
        return this.getAll()[alias] ?? null;
    }
    /**
     * Returns the username that corresponds to the given alias if it exists
     *
     * @param alias the alias that corresponds to a username
     */
    getUsername(alias) {
        return this.getAll()[alias] ?? null;
    }
    /**
     * If the provided string is an alias, it returns the corresponding value.
     * If the provided string is not an alias, we assume that the provided string
     * is the value and return it.
     *
     * This method is helpful when you don't know if the string you have is a value
     * or an alias.
     *
     * @param valueOrAlias a string that might be a value or might be an alias
     */
    resolveValue(valueOrAlias) {
        return this.getValue(valueOrAlias) ?? valueOrAlias;
    }
    /**
     * If the provided string is an alias, it returns the corresponding username.
     * If the provided string is not an alias, we assume that the provided string
     * is the username and return it.
     *
     * This method is helpful when you don't know if the string you have is a username
     * or an alias.
     *
     * @param usernameOrAlias a string that might be a username or might be an alias
     */
    resolveUsername(usernameOrAlias) {
        return this.getUsername(usernameOrAlias) ?? usernameOrAlias;
    }
    /**
     * If the provided string is an alias, return it.
     * If the provided string is not an alias, return the username of the provided alias
     *
     * This method is helpful when you don't know if the string you have is a username
     * or an alias.
     *
     * @param usernameOrAlias a string that might be a username or might be an alias
     */
    resolveAlias(usernameOrAlias) {
        if (this.has(usernameOrAlias))
            return usernameOrAlias;
        return Object.entries(this.getAll()).find(([, username]) => username === usernameOrAlias)?.[0];
    }
    /**
     * Set an alias for the given aliasable entity
     *
     * @param alias the alias you want to set
     * @param entity the aliasable entity that's being aliased
     */
    set(alias, entity) {
        this.config.set(alias, this.getNameOf(entity));
    }
    /**
     * Unset the given alias.
     *
     */
    unset(alias) {
        this.config.unset(alias);
    }
    /**
     * Unsets all the aliases for the given entity.
     *
     * @param entity the aliasable entity for which you want to unset all aliases
     */
    unsetAll(entity) {
        const aliases = this.getAll(entity);
        aliases.forEach((alias) => this.unset(alias));
    }
    async write() {
        return this.config.write();
    }
    /**
     * Returns true if the provided alias exists
     *
     * @param alias the alias you want to check
     */
    has(alias) {
        return this.config.has(alias);
    }
    async init() {
        this.config = await aliasesConfig_1.AliasesConfig.create(aliasesConfig_1.AliasesConfig.getDefaultOptions());
    }
    /**
     * Returns the username of given aliasable entity
     */
    getNameOf(entity) {
        if (typeof entity === 'string')
            return entity;
        const aliaseeName = entity.username ?? entity.user;
        if (!aliaseeName) {
            throw new sfError_1.SfError(`Invalid aliasee, it must contain a user or username property: ${JSON.stringify(entity)}`);
        }
        return aliaseeName;
    }
}
exports.AliasAccessor = AliasAccessor;
//# sourceMappingURL=aliasAccessor.js.map