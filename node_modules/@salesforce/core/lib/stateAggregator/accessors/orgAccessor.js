"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrgAccessor = exports.BaseOrgAccessor = exports.GlobalInfoOrgAccessor = void 0;
const fs = require("fs");
const path = require("path");
const kit_1 = require("@salesforce/kit");
const authInfoConfig_1 = require("../../config/authInfoConfig");
const global_1 = require("../../global");
const types_1 = require("../types");
const logger_1 = require("../../logger");
const messages_1 = require("../../messages");
/**
 * @deprecated
 */
class GlobalInfoOrgAccessor {
    constructor(globalInfo) {
        this.globalInfo = globalInfo;
    }
    getAll(decrypt = false) {
        return this.globalInfo.get(types_1.SfInfoKeys.ORGS, decrypt);
    }
    get(username, decrypt = false) {
        const auth = this.globalInfo.get(`${types_1.SfInfoKeys.ORGS}["${username}"]`, decrypt);
        // For legacy, some things wants the username in the returned auth info.
        if (auth && !auth.username)
            auth.username = username;
        return auth;
    }
    has(username) {
        return !!this.getAll()[username];
    }
    set(username, org) {
        // For legacy, and to keep things standard, some things wants the username in auth info.
        org.username ?? (org.username = username);
        this.globalInfo.set(`${types_1.SfInfoKeys.ORGS}["${username}"]`, org);
    }
    update(username, org) {
        // For legacy, and to keep things standard, some things wants the username in auth info.
        org.username ?? (org.username = username);
        this.globalInfo.update(`${types_1.SfInfoKeys.ORGS}["${username}"]`, org);
    }
    unset(username) {
        delete this.globalInfo.get(types_1.SfInfoKeys.ORGS)[username];
    }
}
exports.GlobalInfoOrgAccessor = GlobalInfoOrgAccessor;
function chunk(array, chunkSize) {
    const final = [];
    for (let i = 0, len = array.length; i < len; i += chunkSize)
        final.push(array.slice(i, i + chunkSize));
    return final;
}
class BaseOrgAccessor extends kit_1.AsyncOptionalCreatable {
    constructor() {
        super(...arguments);
        this.configs = new Map();
        this.contents = new Map();
    }
    /**
     * Read the auth file for the given username. Once the file has been read, it can be re-accessed with the `get` method.
     *
     * @param username username to read
     * @param decrypt if true, decrypt encrypted values
     * @param throwOnNotFound throw if file is not found for username
     */
    async read(username, decrypt = false, throwOnNotFound = true) {
        try {
            const config = await this.initAuthFile(username, throwOnNotFound);
            this.configs.set(username, config);
            return this.get(username, decrypt);
        }
        catch (err) {
            return null;
        }
    }
    /**
     * Read all the auth files under the global state directory
     *
     * @param decrypt if true, decrypt encrypted values
     */
    async readAll(decrypt = false) {
        const fileChunks = chunk(await this.getAllFiles(), 50);
        for (const fileChunk of fileChunks) {
            const promises = fileChunk.map(async (f) => {
                const username = this.parseUsername(f);
                const config = await this.initAuthFile(username);
                this.configs.set(username, config);
            });
            await Promise.all(promises);
        }
        return this.getAll(decrypt);
    }
    /**
     * Return the contents of the username's auth file from cache.
     * The `read` or `readAll` methods must be called first in order to populate the cache.
     * If throwOnNotFound is not true, an empty object {} is returned if the org is not found.
     *
     * @param username username to get
     * @param decrypt if true, decrypt encrypted values
     * @param throwOnNotFound if true, throw if the auth file does not already exist in the cache
     */
    get(username, decrypt = false, throwOnNotFound = false) {
        const config = this.configs.get(username);
        if (throwOnNotFound && config?.keys().length === 0) {
            messages_1.Messages.importMessagesDirectory(__dirname);
            const messages = messages_1.Messages.load('@salesforce/core', 'core', ['namedOrgNotFound']);
            throw messages.createError('namedOrgNotFound', [username]);
        }
        if (config) {
            this.contents.set(username, config.getContents(decrypt));
        }
        return this.contents.get(username);
    }
    /**
     * Return the contents of all the auth files from cache. The `read` or `readAll` methods must be called first in order to populate the cache.
     *
     * @param decrypt if true, decrypt encrypted values
     * @returns
     */
    getAll(decrypt = false) {
        return [...this.configs.keys()].map((username) => this.get(username, decrypt)).filter((org) => !(0, kit_1.isEmpty)(org));
    }
    /**
     * Returns true if the username has been cached.
     *
     * @param username
     */
    has(username) {
        return this.contents.has(username);
    }
    /**
     * Returns true if there is an auth file for the given username. The `read` or `readAll` methods must be called first in order to populate the cache.
     *
     * @param username
     */
    async exists(username) {
        const config = this.configs.get(username);
        return config ? await config.exists() : false;
    }
    /**
     * Return the file stats for a given userame's auth file.
     *
     * @param username
     */
    async stat(username) {
        const config = this.configs.get(username);
        return config ? await config.stat() : null;
    }
    /**
     * Returns true if there is an auth file for the given username
     *
     * @param username
     */
    async hasFile(username) {
        try {
            await fs.promises.access(this.parseFilename(username));
            return true;
        }
        catch {
            this.logger.debug(`No auth file found for ${username}`);
            return false;
        }
    }
    /**
     * Return all auth files under the global state directory.
     */
    async list() {
        return this.getAllFiles();
    }
    /**
     * Set the contents for a given username.
     *
     * @param username
     * @param org
     */
    set(username, org) {
        const config = this.configs.get(username);
        if (config) {
            config.setContentsFromObject(org);
            const contents = config.getContents();
            contents.username ?? (contents.username = username);
            this.contents.set(username, contents);
        }
        else {
            // @ts-ignore
            org.username ?? (org.username = username);
            this.contents.set(username, org);
        }
    }
    /**
     * Update the contents for a given username.
     *
     * @param username
     * @param org
     */
    update(username, org) {
        const existing = this.get(username) || {};
        const merged = Object.assign({}, existing, org);
        return this.set(username, merged);
    }
    /**
     * Delete the auth file for a given username.
     *
     * @param username
     */
    async remove(username) {
        await this.configs.get(username)?.unlink();
        this.configs.delete(username);
        this.contents.delete(username);
    }
    /**
     * Write the contents of the auth file for a given username.
     *
     * @param username
     */
    async write(username) {
        const config = this.configs.get(username);
        if (config) {
            return (await config.write());
        }
        else {
            const contents = this.contents.get(username) || {};
            await this.read(username, false, false);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const config = this.configs.get(username);
            config.setContentsFromObject(contents);
            return (await config.write());
        }
    }
    async init() {
        this.logger = await logger_1.Logger.child(this.constructor.name);
    }
    async getAllFiles() {
        const regex = this.getFileRegex();
        try {
            return (await fs.promises.readdir(global_1.Global.DIR)).filter((file) => regex.test(file));
        }
        catch {
            return [];
        }
    }
    parseUsername(filename) {
        return filename.replace(this.getFileExtension(), '');
    }
    parseFilename(username) {
        return path.join(global_1.Global.DIR, `${username}${this.getFileExtension()}`);
    }
}
exports.BaseOrgAccessor = BaseOrgAccessor;
class OrgAccessor extends BaseOrgAccessor {
    async initAuthFile(username, throwOnNotFound = false) {
        return authInfoConfig_1.AuthInfoConfig.create({
            ...authInfoConfig_1.AuthInfoConfig.getOptions(username),
            throwOnNotFound,
        });
    }
    getFileRegex() {
        // The regular expression that filters files stored in $HOME/.sfdx
        return /^[^.][^@]*@[^.]+(\.[^.\s]+)+\.json$/;
    }
    getFileExtension() {
        return '.json';
    }
}
exports.OrgAccessor = OrgAccessor;
//# sourceMappingURL=orgAccessor.js.map