/// <reference types="node" />
import * as fs from 'fs';
import { Nullable, Optional } from '@salesforce/ts-types';
import { AsyncOptionalCreatable } from '@salesforce/kit';
import { AuthInfoConfig } from '../../config/authInfoConfig';
import { GlobalInfo } from '../globalInfoConfig';
import { SfOrgs, SfOrg } from '../types';
import { AuthFields } from '../../org';
import { ConfigFile } from '../../config/configFile';
import { ConfigContents } from '../../config/configStore';
/**
 * @deprecated
 */
export declare class GlobalInfoOrgAccessor {
    private globalInfo;
    constructor(globalInfo: GlobalInfo);
    getAll(decrypt?: boolean): SfOrgs;
    get(username: string, decrypt?: boolean): Optional<SfOrg>;
    has(username: string): boolean;
    set(username: string, org: SfOrg): void;
    update(username: string, org: Partial<SfOrg>): void;
    unset(username: string): void;
}
export declare abstract class BaseOrgAccessor<T extends ConfigFile, P extends ConfigContents> extends AsyncOptionalCreatable {
    private configs;
    private contents;
    private logger;
    /**
     * Read the auth file for the given username. Once the file has been read, it can be re-accessed with the `get` method.
     *
     * @param username username to read
     * @param decrypt if true, decrypt encrypted values
     * @param throwOnNotFound throw if file is not found for username
     */
    read(username: string, decrypt?: boolean, throwOnNotFound?: boolean): Promise<Nullable<P>>;
    /**
     * Read all the auth files under the global state directory
     *
     * @param decrypt if true, decrypt encrypted values
     */
    readAll(decrypt?: boolean): Promise<P[]>;
    get(username: string, decrypt?: boolean, throwOnNotFound?: true): P;
    /**
     * Return the contents of all the auth files from cache. The `read` or `readAll` methods must be called first in order to populate the cache.
     *
     * @param decrypt if true, decrypt encrypted values
     * @returns
     */
    getAll(decrypt?: boolean): P[];
    /**
     * Returns true if the username has been cached.
     *
     * @param username
     */
    has(username: string): boolean;
    /**
     * Returns true if there is an auth file for the given username. The `read` or `readAll` methods must be called first in order to populate the cache.
     *
     * @param username
     */
    exists(username: string): Promise<boolean>;
    /**
     * Return the file stats for a given userame's auth file.
     *
     * @param username
     */
    stat(username: string): Promise<Nullable<fs.Stats>>;
    /**
     * Returns true if there is an auth file for the given username
     *
     * @param username
     */
    hasFile(username: string): Promise<boolean>;
    /**
     * Return all auth files under the global state directory.
     */
    list(): Promise<string[]>;
    /**
     * Set the contents for a given username.
     *
     * @param username
     * @param org
     */
    set(username: string, org: P): void;
    /**
     * Update the contents for a given username.
     *
     * @param username
     * @param org
     */
    update(username: string, org: Partial<P>): void;
    /**
     * Delete the auth file for a given username.
     *
     * @param username
     */
    remove(username: string): Promise<void>;
    /**
     * Write the contents of the auth file for a given username.
     *
     * @param username
     */
    write(username: string): Promise<Nullable<P>>;
    protected init(): Promise<void>;
    private getAllFiles;
    private parseUsername;
    private parseFilename;
    protected abstract initAuthFile(username: string, throwOnNotFound?: boolean): Promise<T>;
    protected abstract getFileRegex(): RegExp;
    protected abstract getFileExtension(): string;
}
export declare class OrgAccessor extends BaseOrgAccessor<AuthInfoConfig, AuthFields> {
    protected initAuthFile(username: string, throwOnNotFound?: boolean): Promise<AuthInfoConfig>;
    protected getFileRegex(): RegExp;
    protected getFileExtension(): string;
}
