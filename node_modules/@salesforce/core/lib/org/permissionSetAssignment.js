"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionSetAssignment = void 0;
const os_1 = require("os");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const logger_1 = require("../logger");
const messages_1 = require("../messages");
const sfError_1 = require("../sfError");
messages_1.Messages.importMessagesDirectory(__dirname);
const messages = messages_1.Messages.load('@salesforce/core', 'permissionSetAssignment', [
    'errorsEncounteredCreatingAssignment',
    'orgRequired',
    'userIdRequired',
    'permSetRequired',
    'assignCommandPermissionSetNotFoundForNSError',
    'assignCommandPermissionSetNotFoundError',
    'notSuccessfulButNoErrorsReported',
]);
/**
 * A class for assigning a Salesforce User to one or more permission sets.
 */
class PermissionSetAssignment {
    constructor(org, logger) {
        this.logger = logger;
        this.org = org;
    }
    /**
     * Creates a new instance of PermissionSetAssignment.
     *
     * @param org The target org for the assignment.
     */
    static async init(org) {
        if (!org) {
            throw messages.createError('orgRequired');
        }
        return new PermissionSetAssignment(org, await logger_1.Logger.child('PermissionSetAssignment'));
    }
    /**
     * Assigns a user to one or more permission sets.
     *
     * @param id A user id
     * @param permSetString An array of permission set names.
     */
    async create(id, permSetString) {
        if (!id) {
            throw messages.createError('userIdRequired');
        }
        if (!permSetString) {
            throw messages.createError('permSetRequired');
        }
        const { nsPrefix, permSetName } = this.parsePermissionSetString(permSetString);
        let query = `SELECT Id FROM PermissionSet WHERE Name='${permSetName}'`;
        if (nsPrefix) {
            query += ` AND NamespacePrefix='${nsPrefix}'`;
        }
        const result = await this.org.getConnection().query(query);
        const permissionSetId = result?.records[0]?.Id;
        if (!permissionSetId) {
            if (nsPrefix) {
                throw messages.createError('assignCommandPermissionSetNotFoundForNSError', [permSetName, nsPrefix]);
            }
            else {
                throw messages.createError('assignCommandPermissionSetNotFoundError', [permSetName]);
            }
        }
        const assignment = {
            assigneeId: id,
            permissionSetId,
        };
        const createResponse = await this.org
            .getConnection()
            .sobject('PermissionSetAssignment')
            .create((0, kit_1.mapKeys)(assignment, (value, key) => (0, kit_1.upperFirst)(key)));
        if ((0, ts_types_1.hasArray)(createResponse, 'errors') && createResponse.errors.length > 0) {
            let message = messages.getMessage('errorsEncounteredCreatingAssignment');
            const errors = createResponse.errors;
            if (errors && errors.length > 0) {
                message = `${message}:${os_1.EOL}`;
                errors.forEach((_message) => {
                    message = `${message}${_message}${os_1.EOL}`;
                });
                throw new sfError_1.SfError(message, 'errorsEncounteredCreatingAssignment');
            }
            else {
                throw messages.createError('notSuccessfulButNoErrorsReported');
            }
        }
        else {
            return assignment;
        }
    }
    /**
     * Parses a permission set name based on if it has a namespace or not.
     *
     * @param permSetString The permission set string.
     */
    parsePermissionSetString(permSetString) {
        const nsPrefixMatch = RegExp(/(\w+(?=__))(__)(.*)/).exec(permSetString);
        let nsPrefix;
        let permSetName;
        if (nsPrefixMatch) {
            try {
                nsPrefix = nsPrefixMatch[1];
                permSetName = nsPrefixMatch[3];
                this.logger.debug(`Using namespacePrefix ${nsPrefix} for permission set ${permSetName}`);
            }
            catch (e) {
                // Don't fail if we parse wrong.
                this.logger.debug(e);
            }
        }
        else {
            permSetName = permSetString;
        }
        return { nsPrefix, permSetName };
    }
}
exports.PermissionSetAssignment = PermissionSetAssignment;
//# sourceMappingURL=permissionSetAssignment.js.map