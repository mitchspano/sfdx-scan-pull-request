"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateRevisionCounterToZero = exports.resolveUrl = exports.deploySettings = exports.pollForScratchOrgInfo = exports.requestScratchOrgCreation = exports.authorizeScratchOrg = exports.queryScratchOrgInfo = void 0;
const kit_1 = require("@salesforce/kit");
const ts_retry_promise_1 = require("ts-retry-promise");
const logger_1 = require("../logger");
const messages_1 = require("../messages");
const sfError_1 = require("../sfError");
const sfdcUrl_1 = require("../util/sfdcUrl");
const pollingClient_1 = require("../status/pollingClient");
const myDomainResolver_1 = require("../status/myDomainResolver");
const lifecycleEvents_1 = require("../lifecycleEvents");
const mapKeys_1 = require("../util/mapKeys");
const authInfo_1 = require("./authInfo");
const org_1 = require("./org");
const scratchOrgErrorCodes_1 = require("./scratchOrgErrorCodes");
const scratchOrgLifecycleEvents_1 = require("./scratchOrgLifecycleEvents");
messages_1.Messages.importMessagesDirectory(__dirname);
const messages = messages_1.Messages.loadMessages('@salesforce/core', 'scratchOrgInfoApi');
const errorCodes = messages_1.Messages.load('@salesforce/core', 'scratchOrgErrorCodes', ['C-1007']);
/**
 * Returns the url to be used to authorize into the new scratch org
 *
 * @param scratchOrgInfoComplete The completed ScratchOrgInfo
 * @param hubOrgLoginUrl the hun org login url
 * @param signupTargetLoginUrlConfig the login url
 * @returns {string}
 */
const getOrgInstanceAuthority = function (scratchOrgInfoComplete, hubOrgLoginUrl, signupTargetLoginUrlConfig) {
    const createdOrgInstance = scratchOrgInfoComplete.SignupInstance;
    if (createdOrgInstance === 'utf8') {
        return hubOrgLoginUrl;
    }
    let altUrl;
    // For non-Falcon (ie - instance names not ending in -s) sandboxes, use the instance URL
    if (createdOrgInstance && !createdOrgInstance.toLowerCase().endsWith('s')) {
        altUrl = `https://${createdOrgInstance}.salesforce.com`;
    }
    else {
        // For Falcon sandboxes, try the LoginURL instead; createdOrgInstance will not yield a valid URL
        altUrl = scratchOrgInfoComplete.LoginUrl;
    }
    return signupTargetLoginUrlConfig ?? altUrl;
};
/**
 * Returns OAuth2Options object
 *
 * @returns {OAuth2Options, number, number, number} options, retries, timeout, delay
 * @param options
 */
const buildOAuth2Options = async (options) => {
    const logger = await logger_1.Logger.child('buildOAuth2Options');
    const isJwtFlow = !!options.hubOrg.getConnection().getAuthInfoFields().privateKey;
    const oauth2Options = {
        loginUrl: getOrgInstanceAuthority(options.scratchOrgInfoComplete, options.hubOrg.getField(org_1.Org.Fields.LOGIN_URL), options.signupTargetLoginUrlConfig),
    };
    logger.debug(`isJwtFlow: ${isJwtFlow}`);
    if (isJwtFlow && !process.env.SFDX_CLIENT_SECRET) {
        oauth2Options.privateKeyFile = options.hubOrg.getConnection().getAuthInfoFields().privateKey;
        const retries = options?.retry || kit_1.env.getNumber('SFDX_JWT_AUTH_RETRY_ATTEMPTS') || 0;
        const timeoutInSeconds = kit_1.env.getNumber('SFDX_JWT_AUTH_RETRY_TIMEOUT') || 300;
        const timeout = kit_1.Duration.seconds(timeoutInSeconds).milliseconds;
        const delay = retries ? timeout / retries : 1000;
        return {
            options: oauth2Options,
            retries,
            timeout,
            delay,
        };
    }
    else {
        // Web Server OAuth "auth code exchange" flow
        if (process.env.SFDX_CLIENT_SECRET) {
            oauth2Options.clientSecret = process.env.SFDX_CLIENT_SECRET;
        }
        else if (options.clientSecret) {
            oauth2Options.clientSecret = options.clientSecret;
        }
        oauth2Options.redirectUri = options.scratchOrgInfoComplete.ConnectedAppCallbackUrl;
        oauth2Options.authCode = options.scratchOrgInfoComplete.AuthCode;
        return {
            options: oauth2Options,
            retries: 0,
        };
    }
};
/**
 * Returns OAuth2Options object
 *
 * hubOrg the environment hub org
 * username The OAuth client secret. May be null for JWT OAuth flow.
 * oauth2Options The completed ScratchOrgInfo which should contain an access token.
 * retries auth retry a
 * timeout the login url
 * delay the login url
 *
 * @returns {OAuth2Options, number, number, number} options, retries, timeout, delay
 */
const getAuthInfo = async (options) => {
    const logger = await logger_1.Logger.child('getAuthInfo');
    const retryAuthorize = (0, ts_retry_promise_1.retryDecorator)(async (opts) => authInfo_1.AuthInfo.create(opts), {
        timeout: options.timeout,
        delay: options.delay,
        retries: options.retries,
    });
    if (options.retries) {
        try {
            return await retryAuthorize({
                username: options.username,
                parentUsername: options.hubOrg.getUsername(),
                oauth2Options: options.oauth2Options,
            });
        }
        catch (err) {
            const error = err;
            logger.error(error);
            throw error.lastError || error;
        }
    }
    else {
        return authInfo_1.AuthInfo.create({
            username: options.username,
            parentUsername: options.hubOrg.getUsername(),
            oauth2Options: options.oauth2Options,
        });
    }
};
/**
 *
 * @param hubOrg Org
 * @param id Record ID for the ScratchOrgInfoObject
 * @returns Promise<ScratchOrgInfo>
 */
const queryScratchOrgInfo = async (hubOrg, id) => {
    return (await hubOrg.getConnection().sobject('ScratchOrgInfo').retrieve(id));
};
exports.queryScratchOrgInfo = queryScratchOrgInfo;
/**
 * after we successfully signup an org we need to trade the auth token for access and refresh token.
 *
 * scratchOrgInfoComplete - The completed ScratchOrgInfo which should contain an access token.
 * hubOrg - the environment hub org
 * clientSecret - The OAuth client secret. May be null for JWT OAuth flow.
 * signupTargetLoginUrlConfig - Login url
 * retry - auth retry attempts
 *
 * @returns {Promise<AuthInfo>}
 */
const authorizeScratchOrg = async (options) => {
    const { scratchOrgInfoComplete, hubOrg, clientSecret, signupTargetLoginUrlConfig, retry } = options;
    await (0, scratchOrgLifecycleEvents_1.emit)({ stage: 'authenticate', scratchOrgInfo: scratchOrgInfoComplete });
    const logger = await logger_1.Logger.child('authorizeScratchOrg');
    logger.debug(`scratchOrgInfoComplete: ${JSON.stringify(scratchOrgInfoComplete, null, 4)}`);
    // if we didn't have it marked as a devhub but just successfully used it as one, this will update the authFile, fix cache, etc
    if (!hubOrg.isDevHubOrg()) {
        await hubOrg.determineIfDevHubOrg(true);
    }
    const oAuth2Options = await buildOAuth2Options({
        hubOrg,
        clientSecret,
        scratchOrgInfoComplete,
        retry,
        signupTargetLoginUrlConfig,
    });
    const authInfo = await getAuthInfo({
        hubOrg,
        username: scratchOrgInfoComplete.SignupUsername,
        oauth2Options: oAuth2Options.options,
        retries: oAuth2Options.retries,
        timeout: oAuth2Options.timeout,
        delay: oAuth2Options.delay,
    });
    await authInfo.save({
        devHubUsername: hubOrg.getUsername(),
        created: new Date(scratchOrgInfoComplete.CreatedDate ?? new Date()).valueOf().toString(),
        expirationDate: scratchOrgInfoComplete.ExpirationDate,
        clientId: scratchOrgInfoComplete.ConnectedAppConsumerKey,
        createdOrgInstance: scratchOrgInfoComplete.SignupInstance,
        isDevHub: false,
        snapshot: scratchOrgInfoComplete.Snapshot,
    });
    return authInfo;
};
exports.authorizeScratchOrg = authorizeScratchOrg;
const checkOrgDoesntExist = async (scratchOrgInfo) => {
    const usernameKey = Object.keys(scratchOrgInfo).find((key) => key.toUpperCase() === 'USERNAME');
    if (!usernameKey) {
        return;
    }
    const username = scratchOrgInfo[usernameKey];
    if (username && username.length > 0) {
        try {
            await authInfo_1.AuthInfo.create({ username: username.toLowerCase() });
        }
        catch (error) {
            const sfError = sfError_1.SfError.wrap(error);
            // if an AuthInfo couldn't be created that means no AuthFile exists.
            if (sfError.name === 'NamedOrgNotFoundError') {
                return;
            }
            // Something unexpected
            throw sfError;
        }
        // An org file already exists
        throw errorCodes.createError('C-1007');
    }
};
/**
 * This extracts orgPrefs/settings from the user input and performs a basic scratchOrgInfo request.
 *
 * @param hubOrg - the environment hub org
 * @param scratchOrgRequest - An object containing the fields of the ScratchOrgInfo
 * @param settings - An object containing org settings
 * @returns {Promise<SaveResult>}
 */
const requestScratchOrgCreation = async (hubOrg, scratchOrgRequest, settings) => {
    // If these were present, they were already used to initialize the scratchOrgSettingsGenerator.
    // They shouldn't be submitted as part of the scratchOrgInfo.
    delete scratchOrgRequest.settings;
    delete scratchOrgRequest.objectSettings;
    // We do not allow you to specify the old and the new way of doing post create settings
    if (scratchOrgRequest.orgPreferences && settings.hasSettings()) {
        // This is not allowed
        throw new sfError_1.SfError('SignupDuplicateSettingsSpecifiedError');
    }
    // deprecated old style orgPreferences
    if (scratchOrgRequest.orgPreferences) {
        throw new sfError_1.SfError(messages.getMessage('DeprecatedPrefFormat'));
    }
    const scratchOrgInfo = (0, mapKeys_1.default)(scratchOrgRequest, kit_1.upperFirst, true);
    await checkOrgDoesntExist(scratchOrgInfo); // throw if it does exist.
    try {
        await (0, scratchOrgLifecycleEvents_1.emit)({ stage: 'send request' });
        // return await will cause this catch block to run instead of the caller's catch block
        return await hubOrg.getConnection().sobject('ScratchOrgInfo').create(scratchOrgInfo);
    }
    catch (error) {
        // this is a jsforce error which contains the property "fields" which regular error don't
        const jsForceError = error;
        if (jsForceError.errorCode === 'REQUIRED_FIELD_MISSING') {
            throw new sfError_1.SfError(messages.getMessage('SignupFieldsMissingError', [jsForceError.fields.toString()]));
        }
        throw sfError_1.SfError.wrap(jsForceError);
    }
};
exports.requestScratchOrgCreation = requestScratchOrgCreation;
/**
 * This retrieves the ScratchOrgInfo, polling until the status is Active or Error
 *
 * @param hubOrg
 * @param scratchOrgInfoId - the id of the scratchOrgInfo that we are retrieving
 * @param timeout - A Duration object
 * @returns {Promise<ScratchOrgInfo>}
 */
const pollForScratchOrgInfo = async (hubOrg, scratchOrgInfoId, 
// org:create specifies a default timeout of 6.  This longer default is for other consumers
timeout = kit_1.Duration.minutes(15)) => {
    const logger = await logger_1.Logger.child('scratchOrgInfoApi-pollForScratchOrgInfo');
    logger.debug(`PollingTimeout in minutes: ${timeout.minutes}`);
    const pollingOptions = {
        async poll() {
            try {
                const resultInProgress = await (0, exports.queryScratchOrgInfo)(hubOrg, scratchOrgInfoId);
                logger.debug(`polling client result: ${JSON.stringify(resultInProgress, null, 4)}`);
                // Once it's "done" we can return it
                if (resultInProgress.Status === 'Active' || resultInProgress.Status === 'Error') {
                    return {
                        completed: true,
                        payload: resultInProgress,
                    };
                }
                await (0, scratchOrgLifecycleEvents_1.emit)({ stage: 'wait for org', scratchOrgInfo: resultInProgress });
                logger.debug(`Scratch org status is ${resultInProgress.Status}`);
                return {
                    completed: false,
                };
            }
            catch (error) {
                logger.debug(`An error occurred trying to retrieve scratchOrgInfo for ${scratchOrgInfoId}`);
                logger.debug(`Error: ${error.message}`);
                logger.debug('Re-trying deploy check again....');
                return {
                    completed: false,
                };
            }
        },
        timeout,
        frequency: kit_1.Duration.seconds(1),
        timeoutErrorName: 'ScratchOrgInfoTimeoutError',
    };
    const client = await pollingClient_1.PollingClient.create(pollingOptions);
    try {
        const resultInProgress = await client.subscribe();
        return (0, scratchOrgErrorCodes_1.checkScratchOrgInfoForErrors)(resultInProgress, hubOrg.getUsername());
    }
    catch (error) {
        if (error instanceof Error) {
            const sfError = sfError_1.SfError.wrap(error);
            sfError.setData({
                username: hubOrg.getUsername(),
                orgId: hubOrg.getOrgId(),
                scratchOrgInfoId,
            });
            throw sfError;
        }
        throw new sfError_1.SfError(`The scratch org did not complete within ${timeout.minutes} minutes`, 'orgCreationTimeout', [
            'Try your force:org:create command again with a longer --wait value',
        ]);
    }
};
exports.pollForScratchOrgInfo = pollForScratchOrgInfo;
/**
 * Deploy settings to the newly created scratch org
 *
 * @param scratchOrg an instance of the Org class
 * @param orgSettings an instance of the SettingsGenerator class
 * @param apiVersion the api version (used when created the package.xml)
 */
const deploySettings = async (scratchOrg, orgSettings, apiVersion) => {
    const logger = await logger_1.Logger.child('scratchOrgInfoApi-deploySettings');
    if (orgSettings.hasSettings()) {
        // deploy the settings to the newly created scratch org
        logger.debug(`deploying scratch org settings with apiVersion ${apiVersion}`);
        try {
            await orgSettings.createDeploy();
            await orgSettings.deploySettingsViaFolder(scratchOrg, apiVersion);
            // updating the revision num to zero during org:creation if source members are created during org:create.
            // This only happens for some specific scratch org definition file.
            await (0, exports.updateRevisionCounterToZero)(scratchOrg);
            logger.trace('Settings deployed to org');
        }
        catch (error) {
            throw sfError_1.SfError.wrap(error);
        }
    }
};
exports.deploySettings = deploySettings;
/**
 *
 * @param scratchOrgAuthInfo an AuthInfo class from the scratch org
 * @returns AuthInfo
 */
const resolveUrl = async (scratchOrgAuthInfo) => {
    const logger = await logger_1.Logger.child('scratchOrgInfoApi-resolveUrl');
    const { instanceUrl } = scratchOrgAuthInfo.getFields();
    if (!instanceUrl) {
        const sfError = new sfError_1.SfError('Org does not have instanceUrl');
        sfError.setData({
            orgId: scratchOrgAuthInfo.getFields().orgId,
            username: scratchOrgAuthInfo.getFields().username,
            instanceUrl,
        });
        throw sfError;
    }
    logger.debug(`processScratchOrgInfoResult - resultData.instanceUrl: ${instanceUrl}`);
    const options = {
        timeout: kit_1.Duration.minutes(3),
        frequency: kit_1.Duration.seconds(10),
        url: new sfdcUrl_1.SfdcUrl(instanceUrl),
    };
    try {
        const resolver = await myDomainResolver_1.MyDomainResolver.create(options);
        await resolver.resolve();
        return scratchOrgAuthInfo;
    }
    catch (error) {
        const sfError = sfError_1.SfError.wrap(error);
        logger.debug('processScratchOrgInfoResult - err: %s', error);
        if (sfError.name === 'MyDomainResolverTimeoutError') {
            sfError.setData({
                orgId: scratchOrgAuthInfo.getFields().orgId,
                username: scratchOrgAuthInfo.getFields().username,
                instanceUrl,
            });
            logger.debug('processScratchOrgInfoResult - err data: %s', sfError.data);
        }
        throw sfError;
    }
};
exports.resolveUrl = resolveUrl;
const updateRevisionCounterToZero = async (scratchOrg) => {
    const conn = scratchOrg.getConnection();
    const queryResult = await conn.tooling.sobject('SourceMember').find({ RevisionCounter: { $gt: 0 } }, ['Id']);
    if (queryResult.length === 0) {
        return;
    }
    try {
        // jsforce has a bug in its `update` code such that tooling#update doesn't work right
        // https://github.com/jsforce/jsforce/blob/265eba5c734439dd7b77610c05b63bde7d4b1e83/src/connection.ts#L1082
        // will result in `this._ensureVersion is not a function`
        // so until that is resolved, we hit the API with singular records
        // once that's fixed, you can use the following code for a single API call
        // await conn.tooling
        //   .sobject('SourceMember')
        //   .update(queryResult.map((record) => ({ Id: record.Id, RevisionCounter: 0 })));
        await Promise.all(queryResult.map((record) => conn.tooling.sobject('SourceMember').update({ Id: record.Id, RevisionCounter: 0 })));
    }
    catch (err) {
        await lifecycleEvents_1.Lifecycle.getInstance().emitWarning(messages.getMessage('SourceStatusResetFailureError', [
            scratchOrg.getOrgId(),
            scratchOrg.getUsername(),
            err instanceof Error ? err.message : '',
        ]));
    }
};
exports.updateRevisionCounterToZero = updateRevisionCounterToZero;
//# sourceMappingURL=scratchOrgInfoApi.js.map