"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthRemover = void 0;
const kit_1 = require("@salesforce/kit");
const configAggregator_1 = require("../config/configAggregator");
const logger_1 = require("../logger");
const messages_1 = require("../messages");
const stateAggregator_1 = require("../stateAggregator");
const orgConfigProperties_1 = require("./orgConfigProperties");
messages_1.Messages.importMessagesDirectory(__dirname);
const messages = messages_1.Messages.load('@salesforce/core', 'auth', ['targetOrgNotSet']);
/**
 * Handles  the removing of authorizations, which includes deleting the auth file
 * in the global .sfdx folder, deleting any configs that are associated with the username/alias,
 * and deleting any aliases associated with the username
 *
 * ```
 * const remover = await AuthRemover.create();
 * await remover.removeAuth('example@mycompany.com');
 * ```
 *
 * ```
 * const remover = await AuthRemover.create();
 * await remover.removeAllAuths();
 * ```
 *
 * ```
 * const remover = await AuthRemover.create();
 * const auth = await remover.findAuth(
 *  example@mycompany.com
 * );
 * await remover.removeAuth(auth.username);
 * ```
 */
class AuthRemover extends kit_1.AsyncOptionalCreatable {
    /**
     * Removes the authentication and any configs or aliases associated with it
     *
     * @param usernameOrAlias the username or alias that you want to remove
     */
    async removeAuth(usernameOrAlias) {
        const username = await this.resolveUsername(usernameOrAlias);
        this.logger.debug(`Removing authorization for user ${username}`);
        await this.unsetConfigValues(username);
        await this.unsetAliases(username);
        await this.unsetTokens(username);
        await this.stateAggregator.orgs.remove(username);
    }
    /**
     * Removes all authentication files and any configs or aliases associated with them
     */
    async removeAllAuths() {
        const auths = this.findAllAuths();
        const usernames = Object.keys(auths);
        for (const username of usernames) {
            await this.removeAuth(username);
        }
    }
    /**
     * Finds authorization files for username/alias in the global .sfdx folder
     * **Throws** *{@link SfError}{ name: 'TargetOrgNotSetError' }* if no target-org
     * **Throws** *{@link SfError}{ name: 'NamedOrgNotFoundError' }* if specified user is not found
     *
     * @param usernameOrAlias username or alias of the auth you want to find, defaults to the configured target-org
     * @returns {Promise<SfOrg>}
     */
    async findAuth(usernameOrAlias) {
        const username = await this.resolveUsername(usernameOrAlias ?? this.getTargetOrg());
        return this.stateAggregator.orgs.get(username, false, true);
    }
    /**
     * Finds all org authorizations in the global info file (.sf/sf.json)
     *
     * @returns {Record<string, AuthFields>}
     */
    findAllAuths() {
        const orgs = this.stateAggregator.orgs.getAll();
        return orgs.reduce((x, y) => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return { ...x, [y.username]: y };
        }, {});
    }
    async init() {
        this.logger = await logger_1.Logger.child(this.constructor.name);
        this.config = await configAggregator_1.ConfigAggregator.create();
        this.stateAggregator = await stateAggregator_1.StateAggregator.getInstance();
        await this.stateAggregator.orgs.readAll();
    }
    /**
     * Returns the username for a given alias if the alias exists.
     *
     * @param usernameOrAlias username or alias
     * @returns {Promise<string>}
     */
    async resolveUsername(usernameOrAlias) {
        return this.stateAggregator.aliases.resolveUsername(usernameOrAlias);
    }
    /**
     * @returns {string}
     */
    getTargetOrg() {
        const targetOrg = this.config.getInfo(orgConfigProperties_1.OrgConfigProperties.TARGET_ORG).value;
        if (!targetOrg) {
            throw messages.createError('targetOrgNotSet');
        }
        return targetOrg;
    }
    /**
     * Returns aliases for provided username
     *
     * @param username username that's been aliased
     * @returns {Promise<string[]>}
     */
    getAliases(username) {
        return this.stateAggregator.aliases.getAll(username);
    }
    /**
     * Unsets any configured values (both global and local) for provided username
     *
     * @param username username that you want to remove from config files
     */
    async unsetConfigValues(username) {
        const aliases = this.getAliases(username);
        this.logger.debug(`Clearing config keys for username ${username} and aliases: ${aliases}`);
        const configs = [this.config.getGlobalConfig(), this.config.getLocalConfig()];
        for (const config of configs) {
            if (config) {
                const keysWithUsername = config.getKeysByValue(username) || [];
                const keysWithAlias = aliases
                    .map((alias) => config.getKeysByValue(alias))
                    .filter((k) => !!k)
                    .reduce((x, y) => x.concat(y), []);
                const allKeys = keysWithUsername.concat(keysWithAlias);
                this.logger.debug(`Found these config keys to remove: ${allKeys}`);
                allKeys.forEach((key) => {
                    try {
                        config.unset(key);
                    }
                    catch {
                        this.logger.debug(`Failed to remove ${key}`);
                    }
                });
                await config.write();
            }
        }
    }
    /**
     * Unsets any aliases for provided username
     *
     * @param username username that you want to remove from aliases
     */
    async unsetAliases(username) {
        this.logger.debug(`Clearing aliases for username: ${username}`);
        const existingAliases = this.stateAggregator.aliases.getAll(username);
        if (existingAliases.length === 0)
            return;
        this.logger.debug(`Found these aliases to remove: ${existingAliases}`);
        existingAliases.forEach((alias) => this.stateAggregator.aliases.unset(alias));
        await this.stateAggregator.aliases.write();
    }
    async unsetTokens(username) {
        this.logger.debug(`Clearing tokens for username: ${username}`);
        const tokens = this.stateAggregator.tokens.getAll();
        for (const [key, token] of Object.entries(tokens)) {
            if (token.user === username) {
                this.stateAggregator.tokens.unset(key);
            }
        }
        await this.stateAggregator.tokens.write();
    }
}
exports.AuthRemover = AuthRemover;
//# sourceMappingURL=authRemover.js.map