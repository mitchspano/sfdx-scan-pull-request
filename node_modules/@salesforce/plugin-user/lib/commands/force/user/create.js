"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserCreateCommand = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os = require("os");
const fse = require("fs-extra");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const command_1 = require("@salesforce/command");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-user', 'create');
const permsetsStringToArray = (fieldsPermsets) => {
    if (!fieldsPermsets)
        return [];
    return (0, ts_types_1.isArray)(fieldsPermsets)
        ? fieldsPermsets
        : fieldsPermsets.split(',').map((item) => item.replace("'", '').trim());
};
class UserCreateCommand extends command_1.SfdxCommand {
    constructor() {
        super(...arguments);
        this.successes = [];
        this.failures = [];
    }
    /**
     * removes fields that cause errors in salesforce APIs within sfdx-core's createUser method
     *
     * @param fields a list of combined fields from varargs and the config file
     * @private
     */
    static stripInvalidAPIFields(fields) {
        return (0, kit_1.omit)(fields, ['permsets', 'generatepassword', 'generatePassword', 'profileName']);
    }
    async run() {
        this.logger = await core_1.Logger.child(this.constructor.name);
        const defaultUserFields = await core_1.DefaultUserFields.create({
            templateUser: this.org.getUsername(),
        });
        this.user = await core_1.User.create({ org: this.org });
        // merge defaults with provided values with cli > file > defaults
        const fields = await this.aggregateFields(defaultUserFields.getFields());
        try {
            this.authInfo = await this.user.createUser(UserCreateCommand.stripInvalidAPIFields(fields));
        }
        catch (e) {
            if (!(e instanceof Error)) {
                throw e;
            }
            await this.catchCreateUser(e, fields);
        }
        if (fields.profileName)
            await this.authInfo.save({ userProfileName: fields.profileName });
        // Assign permission sets to the created user
        if (fields.permsets) {
            try {
                // permsets can be passed from cli args or file we need to create an array of permset names either way it's passed
                // it will either be a comma separated string, or an array, force it into an array
                const permsetArray = permsetsStringToArray(fields.permsets);
                await this.user.assignPermissionSets(this.authInfo.getFields().userId, permsetArray);
                this.successes.push({
                    name: 'Permission Set Assignment',
                    value: permsetArray.join(','),
                });
            }
            catch (error) {
                const err = error;
                this.failures.push({
                    name: 'Permission Set Assignment',
                    message: err.message,
                });
            }
        }
        // Generate and set a password if specified
        if (fields.generatePassword) {
            try {
                const password = core_1.User.generatePasswordUtf8();
                await this.user.assignPassword(this.authInfo, password);
                password.value((pass) => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.authInfo.save({ password: pass.toString('utf-8') });
                    this.successes.push({
                        name: 'Password Assignment',
                        value: pass.toString(),
                    });
                });
            }
            catch (error) {
                const err = error;
                this.failures.push({
                    name: 'Password Assignment',
                    message: err.message,
                });
            }
        }
        // Set the alias if specified
        if (this.flags.setalias && typeof this.flags.setalias === 'string') {
            const stateAggregator = await core_1.StateAggregator.getInstance();
            stateAggregator.aliases.set(this.flags.setalias, fields.username);
            await stateAggregator.aliases.write();
        }
        fields.id = this.authInfo.getFields().userId;
        this.print(fields);
        this.setExitCode();
        const { permsets, ...fieldsWithoutPermsets } = fields;
        return {
            orgId: this.org.getOrgId(),
            permissionSetAssignments: permsetsStringToArray(permsets),
            fields: { ...(0, kit_1.mapKeys)(fieldsWithoutPermsets, (value, key) => key.toLowerCase()) },
        };
    }
    async catchCreateUser(respBody, fields) {
        // For Gacks, the error message is on response.body[0].message but for handled errors
        // the error message is on response.body.Errors[0].description.
        const errMessage = (0, ts_types_1.getString)(respBody, 'message') || 'Unknown Error';
        const conn = this.org.getConnection();
        // Provide a more user friendly error message for certain server errors.
        if (errMessage.includes('LICENSE_LIMIT_EXCEEDED')) {
            const profile = await conn.singleRecordQuery(`SELECT name FROM profile WHERE id='${fields.profileId}'`);
            throw new core_1.SfError(messages.getMessage('licenseLimitExceeded', [profile.Name]), 'licenseLimitExceeded');
        }
        else if (errMessage.includes('DUPLICATE_USERNAME')) {
            throw new core_1.SfError(messages.getMessage('duplicateUsername', [fields.username]), 'duplicateUsername');
        }
        else {
            throw core_1.SfError.wrap(errMessage);
        }
    }
    lowerFirstLetter(word) {
        return word[0].toLowerCase() + word.substr(1);
    }
    async aggregateFields(defaultFields) {
        var _a;
        // username can be overridden both in the file or varargs, save it to check if it was changed somewhere
        const defaultUsername = defaultFields.username;
        // start with the default fields, then add the fields from the file, then (possibly overwritting) add the fields from the cli varargs param
        if (this.flags.definitionfile && typeof this.flags.definitionfile === 'string') {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call
            const content = (await fse.readJson(this.flags.definitionfile));
            Object.keys(content).forEach((key) => {
                // cast entries to lowercase to standardize
                defaultFields[this.lowerFirstLetter(key)] = content[key];
            });
        }
        if (this.varargs) {
            Object.keys(this.varargs).forEach((key) => {
                if (key.toLowerCase() === 'generatepassword') {
                    // standardize generatePassword casing
                    defaultFields['generatePassword'] = (0, kit_1.toBoolean)(this.varargs[key]);
                }
                else if (key.toLowerCase() === 'profilename') {
                    // standardize profileName casing
                    defaultFields['profileName'] = this.varargs[key];
                }
                else {
                    // all other varargs are left "as is"
                    defaultFields[this.lowerFirstLetter(key)] = this.varargs[key];
                }
            });
        }
        // check if "username" was passed along with "setuniqueusername" flag, if so append org id
        if (this.flags.setuniqueusername && defaultFields.username !== defaultUsername) {
            defaultFields.username = `${defaultFields.username}.${this.org.getOrgId().toLowerCase()}`;
        }
        // check if "profileName" was passed, this needs to become a profileId before calling User.create
        if (defaultFields['profileName']) {
            const name = ((_a = defaultFields['profileName']) !== null && _a !== void 0 ? _a : 'Standard User');
            this.logger.debug(`Querying org for profile name [${name}]`);
            const profile = await this.org
                .getConnection()
                .singleRecordQuery(`SELECT id FROM profile WHERE name='${name}'`);
            defaultFields.profileId = profile.Id;
        }
        return defaultFields;
    }
    print(fields) {
        const userCreatedSuccessMsg = messages.getMessage('success', [
            fields.username,
            fields.id,
            this.org.getOrgId(),
            os.EOL,
            fields.username,
        ]);
        // we initialize to be an empty array to be able to push onto it
        // so we need to check that the size is greater than 0 to know we had a failure
        if (this.failures.length > 0) {
            this.ux.styledHeader('Partial Success');
            this.ux.log(userCreatedSuccessMsg);
            this.ux.log('');
            this.ux.styledHeader('Failures');
            this.ux.table(this.failures, { name: { header: 'Action' }, message: { header: 'Error Message' } });
        }
        else {
            this.ux.log(userCreatedSuccessMsg);
        }
    }
    setExitCode() {
        if (this.failures.length && this.successes.length) {
            process.exitCode = 68;
        }
        else if (this.failures.length) {
            process.exitCode = 1;
        }
        else if (this.successes.length) {
            process.exitCode = 0;
        }
    }
}
exports.UserCreateCommand = UserCreateCommand;
UserCreateCommand.description = messages.getMessage('description');
UserCreateCommand.examples = messages.getMessage('examples').split(os.EOL);
UserCreateCommand.requiresUsername = true;
UserCreateCommand.requiresDevhubUsername = true;
UserCreateCommand.varargs = true;
UserCreateCommand.flagsConfig = {
    setalias: command_1.flags.string({
        char: 'a',
        description: messages.getMessage('flags.alias'),
    }),
    definitionfile: command_1.flags.string({
        char: 'f',
        description: messages.getMessage('flags.definitionfile'),
    }),
    setuniqueusername: command_1.flags.boolean({
        char: 's',
        description: messages.getMessage('flags.setuniqueusername'),
    }),
};
exports.default = UserCreateCommand;
//# sourceMappingURL=create.js.map