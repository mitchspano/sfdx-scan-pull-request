"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserPermsetLicenseAssignCommand = void 0;
const os = require("os");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-user', 'permsetlicense.assign');
class UserPermsetLicenseAssignCommand extends command_1.SfdxCommand {
    constructor() {
        super(...arguments);
        this.successes = [];
        this.failures = [];
    }
    async run() {
        var _a;
        const usernamesOrAliases = (_a = this.flags.onbehalfof) !== null && _a !== void 0 ? _a : [this.org.getUsername()];
        this.logger.debug(`will assign permset to users: ${usernamesOrAliases.join(', ')}`);
        const pslName = this.flags.name;
        const conn = this.org.getConnection();
        try {
            this.pslId = (await conn.singleRecordQuery(`select Id from PermissionSetLicense where DeveloperName = '${pslName}' or MasterLabel = '${pslName}'`)).Id;
        }
        catch {
            throw new core_1.SfError('PermissionSetLicense not found');
        }
        (await Promise.all(usernamesOrAliases.map((usernameOrAlias) => this.usernameToPSLAssignment({ pslName, usernameOrAlias })))).map((result) => {
            if (isSuccess(result)) {
                this.successes.push(result);
            }
            else {
                this.failures.push(result);
            }
        });
        this.print();
        this.setExitCode();
        return {
            successes: this.successes,
            failures: this.failures,
        };
    }
    // handles one username/psl combo so these can run in parallel
    async usernameToPSLAssignment({ pslName, usernameOrAlias, }) {
        // Convert any aliases to usernames
        const resolvedUsername = (await core_1.StateAggregator.getInstance()).aliases.resolveUsername(usernameOrAlias);
        try {
            const AssigneeId = (await this.org
                .getConnection()
                .singleRecordQuery(`select Id from User where Username = '${resolvedUsername}'`)).Id;
            await this.org.getConnection().sobject('PermissionSetLicenseAssign').create({
                AssigneeId,
                PermissionSetLicenseId: this.pslId,
            });
            return {
                name: resolvedUsername,
                value: pslName,
            };
        }
        catch (e) {
            // idempotency.  If user(s) already have PSL, the API will throw an error about duplicate value.
            // but we're going to call that a success
            if (e instanceof Error && e.message.startsWith('duplicate value found')) {
                this.ux.warn(messages.getMessage('duplicateValue', [resolvedUsername, pslName]));
                return {
                    name: resolvedUsername,
                    value: pslName,
                };
            }
            else {
                return {
                    name: resolvedUsername,
                    message: e instanceof Error ? e.message : 'error contained no message',
                };
            }
        }
    }
    setExitCode() {
        if (this.failures.length && this.successes.length) {
            process.exitCode = 68;
        }
        else if (this.failures.length) {
            process.exitCode = 1;
        }
        else if (this.successes.length) {
            process.exitCode = 0;
        }
    }
    print() {
        if (this.failures.length > 0 && this.successes.length > 0) {
            this.ux.styledHeader('Partial Success');
        }
        if (this.successes.length > 0) {
            this.ux.styledHeader('Permset Licenses Assigned');
            this.ux.table(this.successes, {
                name: { header: 'Username' },
                value: { header: 'Permission Set License Assignment' },
            });
        }
        if (this.failures.length > 0) {
            if (this.successes.length > 0) {
                this.ux.log('');
            }
            this.ux.styledHeader('Failures');
            this.ux.table(this.failures, { name: { header: 'Username' } }, { message: { header: 'Error Message' } });
        }
    }
}
exports.UserPermsetLicenseAssignCommand = UserPermsetLicenseAssignCommand;
UserPermsetLicenseAssignCommand.description = messages.getMessage('description');
UserPermsetLicenseAssignCommand.examples = messages.getMessage('examples').split(os.EOL);
UserPermsetLicenseAssignCommand.requiresUsername = true;
UserPermsetLicenseAssignCommand.flagsConfig = {
    name: command_1.flags.string({
        char: 'n',
        description: messages.getMessage('flags.name'),
        required: true,
    }),
    onbehalfof: command_1.flags.array({
        char: 'o',
        description: messages.getMessage('flags.onBehalfOf'),
    }),
};
const isSuccess = (input) => {
    return input.value !== undefined;
};
//# sourceMappingURL=assign.js.map