"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Templates = void 0;
const core_1 = require("@salesforce/core");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/plugin-custom-metadata', 'template', ['errorNotAValidType']);
const createPicklistValues = (values) => values.map((value) => ({ fullName: value, label: value, default: false }));
class Templates {
    /**
     * Using the given data and visibility, creates the body of a type metadata file
     *
     * @param data
     * @param visibility
     */
    createObjectXML({ label, pluralLabel }, visibility) {
        let returnValue = '<?xml version="1.0" encoding="UTF-8"?>\n';
        returnValue += '<CustomObject xmlns="http://soap.sforce.com/2006/04/metadata">\n';
        returnValue += `\t<label>${label}</label>\n`;
        returnValue += `\t<pluralLabel>${pluralLabel}</pluralLabel>\n`;
        returnValue += `\t<visibility>${visibility}</visibility>\n`;
        returnValue += '</CustomObject>\n';
        return returnValue;
    }
    /**
     * Using the given data and defaultToString, creates the body for a field file.
     *
     * @param data Record details
     * @param defaultToString If the defaultToString set type to Text for unsupported field types
     */
    createFieldXML(data, defaultToString) {
        let returnValue = '<?xml version="1.0" encoding="UTF-8"?>\n';
        returnValue += '<CustomField xmlns="http://soap.sforce.com/2006/04/metadata">\n';
        returnValue += this.getFullName(data);
        returnValue += this.getDescription(data);
        returnValue += this.getExternalId(data);
        returnValue += this.getFieldManageability(data);
        returnValue += this.getInlineHelpText(data);
        returnValue += this.getLabel(data);
        returnValue += this.getType(data, defaultToString);
        returnValue += this.getDefaultValue(data);
        returnValue += this.getRequiredTag(data);
        returnValue += this.getLengthTag(data);
        returnValue += this.getVisibleLines(data);
        // preventing standard objects that have fields that are being convered from passing in data
        // that is no longer relevant
        // e.g. multiselectpicklist are being converted to long text area and long text area's do not support valuesets
        if (this.canConvert(data.type)) {
            returnValue += this.getValueSet(data);
            returnValue += this.getPrecisionTag(data);
            returnValue += this.getScaleTag(data);
        }
        returnValue += '</CustomField>\n';
        return returnValue;
    }
    createDefaultTypeStructure(fullName, type, label, picklistValues, decimalplaces = 0) {
        const precision = 18 - decimalplaces;
        const scale = decimalplaces;
        const baseObject = { fullName, type, label, summaryFilterItems: [] };
        switch (type) {
            case 'Checkbox':
                return { ...baseObject, defaultValue: 'false' };
            case 'Email':
                return { ...baseObject, unique: false };
            case 'Number':
                return { ...baseObject, precision, scale, unique: false };
            case 'Percent':
                return { ...baseObject, precision, scale };
            case 'Picklist':
                return {
                    ...baseObject,
                    valueSet: {
                        restricted: true,
                        valueSetDefinition: {
                            sorted: false,
                            value: createPicklistValues(picklistValues),
                        },
                        valueSettings: [],
                    },
                };
            case 'Text':
                return { ...baseObject, unique: false, length: 100 };
            case 'LongTextArea':
                return { ...baseObject, length: 32768, visibleLines: 3 };
            case 'Date':
            case 'DateTime':
            case 'Phone':
            case 'TextArea':
            case 'Url':
                return baseObject;
            default:
                return baseObject;
        }
    }
    canConvert(type) {
        const metadataFieldTypes = [
            'Checkbox',
            'Date',
            'DateTime',
            'Email',
            'Number',
            'Percent',
            'Phone',
            'Picklist',
            'Text',
            'TextArea',
            'LongTextArea',
            'Url',
        ];
        return metadataFieldTypes.includes(type);
    }
    getType(data, defaultToMetadataType) {
        if (this.canConvert(data.type)) {
            // To handle the text formula field scenario where field type will be Text with no length attribute
            if (data.type === 'Text' && data.length === undefined) {
                return '\t<type>LongTextArea</type>\n';
            }
            return `\t<type>${data.type}</type>\n`;
        }
        else if (defaultToMetadataType) {
            return `\t<type>${this.getConvertType(data)}</type>\n`;
        }
        else {
            throw new core_1.SfError(messages.getMessage('errorNotAValidType', [data.type]));
        }
    }
    getConvertType(data) {
        if (data.type === 'Html' ||
            data.type === 'MultiselectPicklist' ||
            (data.type === 'Text' && data.length === undefined)) {
            return 'LongTextArea';
        }
        else {
            return 'Text';
        }
    }
    getFullName(data) {
        const name = data.fullName.endsWith('__c') ? data.fullName : data.fullName + '__c';
        return `\t<fullName>${name}</fullName>\n`;
    }
    getDescription(data) {
        return data.description ? `\t<description>${data.description}</description>\n` : '';
    }
    getExternalId(data) {
        return data.externalId ? `\t<externalId>${data.externalId}</externalId>\n` : '';
    }
    getFieldManageability(data) {
        return `\t<fieldManageability>${data.fieldManageability || 'DeveloperControlled'}</fieldManageability>\n`;
    }
    getInlineHelpText(data) {
        return data.inlineHelpText ? `\t<inlineHelpText>${data.inlineHelpText}</inlineHelpText>\n` : '';
    }
    getLabel(data) {
        return `\t<label>${data.label}</label>\n`;
    }
    getRequiredTag(data) {
        return typeof data.unique === 'boolean' ? `\t<unique>${data.unique}</unique>\n` : '';
    }
    getPrecisionTag(data) {
        return data.precision ? `\t<precision>${data.precision}</precision>\n` : '';
    }
    getScaleTag(data) {
        return typeof data.scale !== 'undefined' ? `\t<scale>${data.scale}</scale>\n` : '';
    }
    getLengthTag(data) {
        // If field type is multiselect or
        // data type is text with no length attribute then it is formula field then set the length to 32768 as we are setting the type LongTextArea
        if (data.type === 'MultiselectPicklist' || (data.type === 'Text' && data.length === undefined)) {
            return '\t<length>32768</length>\n';
        }
        if (data.length) {
            return `\t<length>${data.length}</length>\n`;
        }
        // For fields that are being translated from Custom objects that do not have a matching type they are
        // being defaulted to a Text field. They need to have a minimum length to them
        // e.g. Field types that are getting converted: Currency, Location, MasterDetail, Lookup
        return !this.canConvert(data.type) && this.getConvertType(data) === 'Text' ? '\t<length>100</length>\n' : '';
    }
    getVisibleLines(data) {
        if (data.type === 'Text' && data.length === undefined) {
            return '\t<visibleLines>3</visibleLines>\n';
        }
        return data.visibleLines ? `\t<visibleLines>${data.visibleLines}</visibleLines>\n` : '';
    }
    getDefaultValue(data) {
        if (data.type === 'Currency') {
            return data.defaultValue ? `\t<defaultValue>'${data.defaultValue}'</defaultValue>\n` : '';
        }
        else if (data.type === 'Checkbox' && data.defaultValue === undefined) {
            return '\t<defaultValue>false</defaultValue>\n';
        }
        return data.defaultValue ? `\t<defaultValue>${data.defaultValue}</defaultValue>\n` : '';
    }
    getValueSet(data) {
        let fieldValue = '';
        if (data.valueSet) {
            fieldValue += '\t<valueSet>\n';
            fieldValue += `\t\t<restricted>${data.valueSet.restricted || false}</restricted>\n`;
            fieldValue += '\t\t<valueSetDefinition>\n';
            fieldValue += `\t\t\t<sorted>${data.valueSet.valueSetDefinition.sorted || false}</sorted>\n`;
            data.valueSet.valueSetDefinition.value.forEach((value) => {
                fieldValue += '\t\t\t<value>\n';
                fieldValue += `\t\t\t\t<fullName>${value.fullName}</fullName>\n`;
                fieldValue += `\t\t\t\t<default>${value.default || false}</default>\n`;
                fieldValue += `\t\t\t\t<label>${value.label}</label>\n`;
                fieldValue += '\t\t\t</value>\n';
            });
            fieldValue += '\t\t</valueSetDefinition>\n';
            fieldValue += '\t</valueSet>\n';
        }
        return fieldValue;
    }
}
exports.Templates = Templates;
//# sourceMappingURL=templates.js.map