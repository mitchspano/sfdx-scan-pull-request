import { Org } from '@salesforce/core';
import { UX } from '@salesforce/command';
import { DataPlanPart, SObjectTreeFileContents } from '../../../dataSoqlQueryTypes';
export interface ExportConfig {
    query: string;
    outputDir?: string;
    plan?: boolean;
    prefix?: string;
}
/**
 * Exports data from an org into sObject tree format.
 */
export declare class ExportApi {
    private readonly org;
    private readonly ux;
    private logger;
    private objectTypeRegistry;
    private refFromIdByType;
    private typeRefIndexes;
    private config;
    constructor(org: Org, ux: UX);
    /**
     * Invokes the provided SOQL query against a target Org.  Results
     * are converted into SObject Tree format.
     *
     * @param config
     */
    export(config: ExportConfig): Promise<SObjectTreeFileContents | DataPlanPart[]>;
    /**
     * Ensures a valid query is defined in the export configuration,
     * which can be either a soql query or a path to a file containing
     * a soql query.
     *
     * @param config - The export configuration.
     */
    private validate;
    private processQueryResults;
    /**
     * Register object types and type hierarchy for plan generation
     **/
    private recordObjectTypes;
    private queryResultsToTree;
    private processRecords;
    private incrementTypeRefIndex;
    private processRecordAttributes;
    private processRecordAttribute;
    private loadMetadata;
    private isQueryResult;
    private isSpecificTypeWithMetadata;
    private getRelationshipFieldName;
    private isRelationship;
    private isRelationshipWithMetadata;
    private getRelatedTo;
    private getRelatedToWithMetadata;
    /**
     * Register object type's id to reference mapping
     *
     * @param refId like '@AccountRef1'
     * */
    private saveRecordRef;
    /**
     * Walk the final data set and split out into files.  The main queried
     * object is the parent, and has a different saveRefs and resolveRefs
     * values.  All the references have been created at this point.
     */
    private generateDataPlan;
    private writeObjectTypeDataFile;
    /**
     * This method is used as a second pass to establish references that couldn't be determined
     * in the initial pass done by processRecordList. It looks for relationship fields that
     * contain an id.
     */
    private finalApplyRefs;
    private countRecords;
    private getPrefixedFileName;
    private writeDataFileSync;
}
