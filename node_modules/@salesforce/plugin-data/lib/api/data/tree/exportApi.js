"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExportApi = void 0;
const path = require("path");
const fs = require("fs");
const core_1 = require("@salesforce/core");
const fs_extra_1 = require("fs-extra");
const dataSoqlQueryTypes_1 = require("../../../dataSoqlQueryTypes");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-data', 'exportApi');
const DATA_PLAN_FILENAME_PART = '-plan.json';
const describe = {}; // holds metadata result for object type describe calls
/**
 * Exports data from an org into sObject tree format.
 */
class ExportApi {
    constructor(org, ux) {
        this.org = org;
        this.ux = ux;
        this.objectTypeRegistry = {}; // registry for object type data plan descriptor
        this.refFromIdByType = new Map(); // refFromIdByType.get('account').get(someAccountId) => AccountRef1
        this.typeRefIndexes = new Map(); // registry for object type-specific ref counters
        this.logger = core_1.Logger.childFromRoot(this.constructor.name);
    }
    /**
     * Invokes the provided SOQL query against a target Org.  Results
     * are converted into SObject Tree format.
     *
     * @param config
     */
    async export(config) {
        var _a;
        this.config = this.validate(config);
        const { outputDir, plan, query } = this.config;
        if (outputDir) {
            await (0, fs_extra_1.ensureDir)(outputDir);
        }
        let queryResults;
        try {
            queryResults = await this.org.getConnection().query(query);
        }
        catch (err) {
            if (err instanceof Error && err.name === 'MALFORMED_QUERY') {
                const errMsg = messages.getMessage('soqlMalformed');
                const errMsgAction = messages.getMessage('soqlMalformedAction');
                throw new core_1.SfError(errMsg, 'MalformedQuery', [errMsgAction]);
            }
            else {
                throw err;
            }
        }
        const sobjectTree = await this.processQueryResults(queryResults);
        if (!((_a = sobjectTree.records) === null || _a === void 0 ? void 0 : _a.length)) {
            return sobjectTree;
        }
        if (plan) {
            return this.generateDataPlan(sobjectTree);
        }
        return this.writeDataFileSync(`${Object.keys(this.objectTypeRegistry).join('-')}.json`, sobjectTree);
    }
    //   P R I V A T E   M E T H O D S
    /**
     * Ensures a valid query is defined in the export configuration,
     * which can be either a soql query or a path to a file containing
     * a soql query.
     *
     * @param config - The export configuration.
     */
    validate(config) {
        if (!config.query) {
            throw new core_1.SfError(messages.getMessage('queryNotProvided'), 'queryNotProvided');
        }
        const filepath = path.resolve(process.cwd(), config.query);
        if (fs.existsSync(filepath)) {
            config.query = fs.readFileSync(filepath, 'utf8');
            if (!config.query) {
                throw messages.createError('queryNotProvided');
            }
        }
        config.query = config.query.toLowerCase().trim();
        if (!config.query.startsWith('select')) {
            throw new core_1.SfError(messages.getMessage('soqlInvalid', [config.query]), 'soqlInvalid');
        }
        return config;
    }
    // Process query results generating SObject Tree format
    async processQueryResults(recordList) {
        var _a;
        await this.recordObjectTypes(recordList);
        const processedRecordList = await this.queryResultsToTree(recordList);
        // log record count; warn if > 200 and !options.plan
        const recordCount = (_a = processedRecordList.records.length) !== null && _a !== void 0 ? _a : 0;
        this.logger.debug(messages.getMessage('dataExportRecordCount', [recordCount, this.config.query]));
        if (recordCount > 200 && !this.config.plan) {
            this.ux.warn(messages.getMessage('dataExportRecordCountWarning', [recordCount, this.config.query]));
        }
        return this.finalApplyRefs(processedRecordList.records);
    }
    /**
     * Register object types and type hierarchy for plan generation
     **/
    async recordObjectTypes(recordList) {
        const records = recordList.records;
        if (!records.length) {
            // TODO: should be on the command
            this.ux.log('Query returned no results');
            return recordList;
        }
        // top level object type
        const topLevelType = records[0].attributes.type;
        this.objectTypeRegistry[topLevelType] = {
            order: 0,
            type: topLevelType,
            saveRefs: true,
            resolveRefs: false, // pre-save, don't resolve relationship references to parent ids (from previous save)
        };
        records.forEach((record) => {
            Object.entries(record).map(([key, value]) => {
                if ((0, dataSoqlQueryTypes_1.hasNestedRecords)(value)) {
                    const type = value.records[0].attributes.type;
                    // found a related object, add to map
                    if (type && !this.objectTypeRegistry[type]) {
                        this.objectTypeRegistry[type] = {
                            order: 1,
                            type,
                            saveRefs: false,
                            resolveRefs: true, // resolve relationship references to parent ids
                        };
                    }
                }
                return key;
            });
        });
        // pre-load object metadata
        const promises = Object.keys(this.objectTypeRegistry).map((key) => this.loadMetadata(key));
        return Promise.all(promises).then(() => recordList);
    }
    async queryResultsToTree(recordList, parentRef) {
        // holds transformed sobject tree
        const sobjectTree = { records: [] };
        for (const record of recordList.records) {
            await this.processRecords(record, sobjectTree, parentRef);
        }
        this.logger.debug(JSON.stringify(sobjectTree, null, 4));
        return sobjectTree;
    }
    async processRecords(record, sobjectTree, parentRef) {
        // incremented every time we visit another record
        const objRefId = this.incrementTypeRefIndex(record.attributes.type);
        // add the attributes for this record, setting the type and reference
        const treeRecord = {
            attributes: {
                type: record.attributes.type,
                referenceId: objRefId,
            },
        };
        // store the reference in a map with the record id
        this.saveRecordRef(record, objRefId);
        // handle each record attribute
        await this.processRecordAttributes(record, treeRecord, objRefId);
        if (parentRef && this.config.plan) {
            const parentFieldName = parentRef.fieldName;
            if (!treeRecord[parentFieldName]) {
                treeRecord[parentFieldName] = parentRef.id;
            }
        }
        // add record to tree
        sobjectTree.records.push(treeRecord);
        return sobjectTree;
    }
    // Generate object type reference (<ObjectType>Ref<Counter>)
    incrementTypeRefIndex(type) {
        var _a;
        this.typeRefIndexes.set(type, 1 + ((_a = this.typeRefIndexes.get(type)) !== null && _a !== void 0 ? _a : 0));
        return `${type}Ref${this.typeRefIndexes.get(type)}`;
    }
    async processRecordAttributes(record, treeRecord, objRefId) {
        const promises = Object.keys(record).map((key) => this.processRecordAttribute(record, key, treeRecord, objRefId));
        await Promise.all(promises);
        return treeRecord;
    }
    async processRecordAttribute(record, key, treeRecord, objRefId) {
        var _a;
        // skip attributes and id.  Data import does not accept records with IDs.
        if (key === 'attributes' || key === 'Id') {
            // If this is an attributes section then we need to add an object reference
            this.saveRecordRef(record, objRefId);
            return;
        }
        const metadata = await this.loadMetadata(record.attributes.type);
        if (this.isQueryResult(metadata, key)) {
            const field = record[key];
            // handle child records
            if (!field) {
                // The parent has no child records, so return an empty records array
                treeRecord[key] = { records: [] };
                return;
            }
            if ((0, dataSoqlQueryTypes_1.hasNestedRecords)(field)) {
                const childMetadata = await this.loadMetadata(field.records[0].attributes.type);
                treeRecord[key] = await this.queryResultsToTree(field, {
                    id: `@${objRefId}`,
                    fieldName: this.getRelationshipFieldName(childMetadata, record.attributes.type),
                });
                return;
            }
        }
        if (this.config.plan && this.isRelationshipWithMetadata(metadata, key)) {
            const relTo = this.getRelatedToWithMetadata(metadata, key);
            // find reference in record result
            if (this.objectTypeRegistry[relTo]) {
                // add ref to replace the value
                const id = record[key];
                const ref = (_a = this.refFromIdByType.get(relTo)) === null || _a === void 0 ? void 0 : _a.get(id);
                // If ref is not found, then leave intact because we may not have processed
                // this parent fully. We'll go back through the sObject tree
                // later and replace the id with a reference.
                treeRecord[key] = ref && ref !== id ? `@${ref}` : id;
                return;
            }
            // TODO: what to do if ref not found?
            const recordId = record['Id'];
            this.logger.error(`Reference ${relTo} not found for ${key}.  Skipping record ${recordId}.`);
            return;
        }
        // not a relationship field, simple key/value
        if (!this.isRelationshipWithMetadata(metadata, key)) {
            treeRecord[key] = record[key];
        }
    }
    // Get sObject description and cache for given object type
    async loadMetadata(objectName) {
        var _a;
        (_a = describe[objectName]) !== null && _a !== void 0 ? _a : (describe[objectName] = await this.org.getConnection().sobject(objectName).describe());
        return describe[objectName];
    }
    isQueryResult(metadata, fieldName) {
        return metadata.childRelationships.some((cr) => cr.relationshipName === fieldName);
    }
    isSpecificTypeWithMetadata(metadata, fieldName, fieldType) {
        return metadata.fields.some((f) => f.name.toLowerCase() === fieldName.toLowerCase() && f.type.toLowerCase() === fieldType.toLowerCase());
    }
    getRelationshipFieldName(metadata, parentName) {
        const result = metadata.fields.find((field) => { var _a; return field.type === 'reference' && ((_a = field.referenceTo) === null || _a === void 0 ? void 0 : _a.includes(parentName)); });
        if (!result) {
            throw new core_1.SfError(`Unable to find relationship field name for ${metadata.name}`);
        }
        return result.name;
    }
    isRelationship(objectName, fieldName) {
        if (!describe[objectName]) {
            throw new core_1.SfError(`Metadata not found for ${objectName}`);
        }
        return this.isRelationshipWithMetadata(describe[objectName], fieldName);
    }
    isRelationshipWithMetadata(metadata, fieldName) {
        return this.isSpecificTypeWithMetadata(metadata, fieldName, 'reference');
    }
    getRelatedTo(objectName, fieldName) {
        if (!describe[objectName]) {
            throw new core_1.SfError(`Metadata not found for ${objectName}`);
        }
        return this.getRelatedToWithMetadata(describe[objectName], fieldName);
    }
    getRelatedToWithMetadata(metadata, fieldName) {
        const result = metadata.fields.find((field) => { var _a; return field.name === fieldName && ((_a = field.referenceTo) === null || _a === void 0 ? void 0 : _a.length); });
        if (!result || !result.referenceTo) {
            throw new core_1.SfError(`Unable to find relation for ${metadata.name}`);
        }
        return result.referenceTo[0];
    }
    /**
     * Register object type's id to reference mapping
     *
     * @param refId like '@AccountRef1'
     * */
    saveRecordRef(obj, refId) {
        var _a, _b;
        if (!obj.attributes.url) {
            return;
        }
        const id = path.basename(obj.attributes.url);
        const type = obj.attributes.type;
        // ensure no existing reference for that Id
        const refEntry = (_a = this.refFromIdByType.get(type)) === null || _a === void 0 ? void 0 : _a.get(id);
        if (refEntry && refEntry !== refId) {
            throw new core_1.SfError(`Overriding ${type} reference for ${id}: existing ${refEntry}, incoming ${refId}`);
        }
        this.refFromIdByType.set(type, ((_b = this.refFromIdByType.get(type)) !== null && _b !== void 0 ? _b : new Map()).set(id, refId));
    }
    /**
     * Walk the final data set and split out into files.  The main queried
     * object is the parent, and has a different saveRefs and resolveRefs
     * values.  All the references have been created at this point.
     */
    generateDataPlan(sobjectTree) {
        const objects = new Map();
        const dataPlan = [];
        // loop thru object tree extracting type-specific records into separate tree structure
        sobjectTree.records.forEach((record) => {
            var _a;
            const topLevelObjectType = record.attributes.type;
            if (!objects.has(topLevelObjectType)) {
                objects.set(topLevelObjectType, []);
            }
            Object.entries(record).map(([key, value]) => {
                var _a;
                if ((0, dataSoqlQueryTypes_1.hasNestedRecords)(value)) {
                    const childRecords = value.records;
                    if (childRecords) {
                        // found child records, add to type-specific registry
                        if (childRecords.length) {
                            const childObjectType = childRecords[0].attributes.type;
                            objects.set(childObjectType, ((_a = objects.get(childObjectType)) !== null && _a !== void 0 ? _a : []).concat(childRecords));
                        }
                        // remove child from top-level object structure
                        delete record[key];
                    }
                }
            });
            objects.set(topLevelObjectType, ((_a = objects.get(topLevelObjectType)) !== null && _a !== void 0 ? _a : []).concat([record]));
        });
        // sort object types based on insertion dependence
        const objectsSorted = Object.keys(this.objectTypeRegistry).sort((a, b) => this.objectTypeRegistry[a].order - this.objectTypeRegistry[b].order);
        // write data files and update data plan
        dataPlan.push(...objectsSorted.map((key) => this.writeObjectTypeDataFile(key, this.objectTypeRegistry[key].saveRefs, this.objectTypeRegistry[key].resolveRefs, `${key}s.json`, { records: objects.get(key) })));
        // write data plan file
        const dataPlanFile = Object.keys(this.objectTypeRegistry).join('-') + DATA_PLAN_FILENAME_PART;
        return this.writeDataFileSync(dataPlanFile, dataPlan);
    }
    // generate data plan stanza referencing written object type file
    writeObjectTypeDataFile(type, saveRefs, resolveRefs, fileName, sObject) {
        const dataPlanPart = {
            sobject: type,
            saveRefs,
            resolveRefs,
            files: [this.getPrefixedFileName(fileName)],
        };
        this.writeDataFileSync(fileName, sObject);
        return dataPlanPart;
    }
    /**
     * This method is used as a second pass to establish references that couldn't be determined
     * in the initial pass done by processRecordList. It looks for relationship fields that
     * contain an id.
     */
    finalApplyRefs(sobjectTree) {
        sobjectTree.forEach((record) => {
            Object.entries(record).map(([field, value]) => {
                var _a;
                if ((0, dataSoqlQueryTypes_1.hasNestedRecords)(value)) {
                    // These are children
                    this.finalApplyRefs(value.records);
                }
                else {
                    const objType = record.attributes.type;
                    if (this.isRelationship(objType, field)) {
                        if (typeof value === 'string' && !value.startsWith('@')) {
                            // it's still just an ID, so we need to resolve it
                            const id = value;
                            const refTo = this.getRelatedTo(objType, field);
                            const ref = (_a = this.refFromIdByType.get(refTo)) === null || _a === void 0 ? void 0 : _a.get(id);
                            if (!ref) {
                                throw new core_1.SfError(`${objType} reference to ${refTo} (${id}) not found in query results.`);
                            }
                            record[field] = `@${ref}`;
                            // Setup dependency ordering for later output
                            if (this.objectTypeRegistry[objType].order <= this.objectTypeRegistry[refTo].order) {
                                this.objectTypeRegistry[objType].order = this.objectTypeRegistry[refTo].order + 1;
                                this.objectTypeRegistry[refTo].saveRefs = true;
                                this.objectTypeRegistry[objType].resolveRefs = true;
                            }
                        }
                    }
                }
            });
        });
        return { records: sobjectTree };
    }
    countRecords(records, count = 0) {
        count += records.length;
        records.forEach((record) => {
            Object.values(record).forEach((val) => {
                if ((0, dataSoqlQueryTypes_1.hasNestedRecords)(val)) {
                    this.countRecords(val.records, count);
                }
            });
        });
        return count;
    }
    getPrefixedFileName(fileName) {
        return this.config.prefix ? `${this.config.prefix}-${fileName}` : fileName;
    }
    writeDataFileSync(fileName, jsonObject) {
        let recordCount = 0;
        const finalFilename = this.config.outputDir
            ? path.join(this.config.outputDir, this.getPrefixedFileName(fileName))
            : this.getPrefixedFileName(fileName);
        if ((0, dataSoqlQueryTypes_1.hasNestedRecords)(jsonObject)) {
            recordCount = this.countRecords(jsonObject.records);
        }
        fs.writeFileSync(finalFilename, JSON.stringify(jsonObject, null, 4));
        // TODO: move this to the command
        this.ux.log(`Wrote ${recordCount} records to ${finalFilename}`);
        return jsonObject;
    }
}
exports.ExportApi = ExportApi;
//# sourceMappingURL=exportApi.js.map