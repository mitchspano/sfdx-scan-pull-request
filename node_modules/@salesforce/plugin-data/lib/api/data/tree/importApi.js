"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportApi = void 0;
const path = require("path");
const util = require("util");
const fs = require("fs");
const ts_types_1 = require("@salesforce/ts-types");
const core_1 = require("@salesforce/core");
const dataSoqlQueryTypes_1 = require("../../../dataSoqlQueryTypes");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-data', 'importApi');
const importPlanSchemaFile = path.join(__dirname, '..', '..', '..', '..', 'schema', 'dataImportPlanSchema.json');
const sobjectTreeApiPartPattern = '%s/services/data/v%s/composite/tree/%s';
const jsonContentType = 'application/json';
const xmlContentType = 'application/xml';
const jsonRefRegex = /[.]*["|'][A-Z0-9_]*["|'][ ]*:[ ]*["|']@([A-Z0-9_]*)["|'][.]*/gim;
const xmlRefRegex = /[.]*<[A-Z0-9_]*>@([A-Z0-9_]*)<\/[A-Z0-9_]*[ID]>[.]*/gim;
const INVALID_DATA_IMPORT_ERR_NAME = 'InvalidDataImport';
/**
 * Imports data into an org that was exported to files using the export API.
 */
class ImportApi {
    constructor(org) {
        this.org = org;
        this.responseRefs = [];
        this.sobjectUrlMap = new Map();
        this.sobjectTypes = {};
        this.importPlanConfig = [];
        this.logger = core_1.Logger.childFromRoot(this.constructor.name);
        this.schemaValidator = new core_1.SchemaValidator(this.logger, importPlanSchemaFile);
    }
    /**
     * Inserts given SObject Tree content into given target Org.
     *
     * @param config
     */
    async import(config) {
        const importResults = {};
        const instanceUrl = this.org.getField(core_1.Org.Fields.INSTANCE_URL);
        this.config = await this.validate(config);
        const refMap = new Map();
        const { contentType, plan, sobjectTreeFiles = [] } = this.config;
        try {
            // original version of this did files sequentially.  Not sure what happens if you did it in parallel
            // so this still awaits each file individually
            if (plan) {
                await this.getPlanPromises({ plan, contentType, refMap, instanceUrl });
            }
            else {
                for (const promise of sobjectTreeFiles.map((file) => this.importSObjectTreeFile({
                    instanceUrl,
                    refMap,
                    filepath: path.resolve(process.cwd(), file),
                    contentType,
                }))) {
                    await promise;
                }
            }
            importResults.responseRefs = this.responseRefs;
            importResults.sobjectTypes = this.sobjectTypes;
        }
        catch (err) {
            const error = err;
            if ((0, ts_types_1.getString)(error, 'errorCode') === 'ERROR_HTTP_400' && error.message != null) {
                let msg;
                try {
                    msg = JSON.parse(error.message);
                    if (msg.hasErrors && msg.results && msg.results.length > 0) {
                        importResults.errors = msg.results;
                    }
                }
                catch (e2) {
                    // throw original
                }
            }
            throw core_1.SfError.wrap(error);
        }
        return importResults;
    }
    getSchema() {
        return this.schemaValidator.loadSync();
    }
    async getPlanPromises({ plan, contentType, refMap, instanceUrl, }) {
        // REVIEWME: support both files and plan in same invocation?
        const importPlanRootPath = path.dirname(plan);
        for (const sobjectConfig of this.importPlanConfig) {
            const globalSaveRefs = sobjectConfig.saveRefs != null ? sobjectConfig.saveRefs : false;
            const globalResolveRefs = sobjectConfig.resolveRefs != null ? sobjectConfig.resolveRefs : false;
            for (const fileDef of sobjectConfig.files) {
                let filepath;
                let saveRefs = globalSaveRefs;
                let resolveRefs = globalResolveRefs;
                // file definition can be just a filepath or an object that
                // has a filepath and overriding global config
                if (typeof fileDef === 'string') {
                    filepath = fileDef;
                }
                else if (fileDef.file) {
                    filepath = fileDef.file;
                    // override save references, if set
                    saveRefs = fileDef.saveRefs == null ? globalSaveRefs : fileDef.saveRefs;
                    // override resolve references, if set
                    resolveRefs = fileDef.resolveRefs == null ? globalResolveRefs : fileDef.resolveRefs;
                }
                else {
                    throw new core_1.SfError('file definition format unknown.', 'InvalidDataImportPlan');
                }
                filepath = path.resolve(importPlanRootPath, filepath);
                const importConfig = {
                    instanceUrl,
                    saveRefs,
                    resolveRefs,
                    refMap,
                    filepath,
                    contentType,
                };
                await this.importSObjectTreeFile(importConfig);
            }
        }
    }
    /**
     * Validates the import configuration.  If a plan is passed, validates
     * the plan per the schema.
     *
     * @param config - The data import configuration.
     * @returns Promise.<ImportConfig>
     */
    async validate(config) {
        const { sobjectTreeFiles, plan } = config;
        // --sobjecttreefiles option is required when --plan option is unset
        if (!sobjectTreeFiles && !plan) {
            throw new core_1.SfError(messages.getMessage('dataFileNotProvided'), INVALID_DATA_IMPORT_ERR_NAME);
        }
        // Prevent both --sobjecttreefiles and --plan option from being set
        if (sobjectTreeFiles && plan) {
            throw new core_1.SfError(messages.getMessage('tooManyFiles'), INVALID_DATA_IMPORT_ERR_NAME);
        }
        if (plan) {
            const planPath = path.resolve(process.cwd(), plan);
            if (!fs.existsSync(planPath)) {
                throw new core_1.SfError(messages.getMessage('dataFileNotFound', [planPath]), INVALID_DATA_IMPORT_ERR_NAME);
            }
            this.importPlanConfig = JSON.parse(fs.readFileSync(planPath, 'utf8'));
            try {
                await this.schemaValidator.validate(this.importPlanConfig);
            }
            catch (err) {
                const error = err;
                if (error.name === 'ValidationSchemaFieldErrors') {
                    throw new core_1.SfError(messages.getMessage('dataPlanValidationError', [planPath, error.message]), INVALID_DATA_IMPORT_ERR_NAME);
                }
                throw core_1.SfError.wrap(error);
            }
        }
        return config;
    }
    /**
     * Create a hash of sobject { ReferenceId: Type } assigned to this.sobjectTypes.
     * Used to display the sobject type in the results.
     *
     * @param content  The content string defined by the file(s).
     * @param isJson
     */
    createSObjectTypeMap(content, isJson) {
        let contentJson;
        const getTypes = (records) => {
            records.forEach((record) => {
                Object.entries(record).forEach(([key, val]) => {
                    if (key === 'attributes' && (0, dataSoqlQueryTypes_1.isAttributesElement)(val)) {
                        this.sobjectTypes[val.referenceId] = val.type;
                    }
                    else if ((0, dataSoqlQueryTypes_1.hasNestedRecords)(val) && Array.isArray(val.records)) {
                        getTypes(val.records);
                    }
                });
            });
        };
        if (isJson) {
            contentJson = JSON.parse(content);
            if (Array.isArray(contentJson.records)) {
                getTypes(contentJson.records);
            }
        }
    }
    // Does some basic validation on the filepath and returns some file metadata such as
    // isJson, refRegex, and headers.
    getSObjectTreeFileMeta(filepath, contentType) {
        const meta = {
            isJson: false,
            headers: {},
            refRegex: new RegExp(/./),
        };
        let tmpContentType;
        // explicitly validate filepath so, if not found, we can return friendly error message
        try {
            fs.statSync(filepath);
        }
        catch (e) {
            throw new core_1.SfError(messages.getMessage('dataFileNotFound', [filepath]), INVALID_DATA_IMPORT_ERR_NAME);
        }
        // determine content type
        if (filepath.endsWith('.json')) {
            tmpContentType = jsonContentType;
            meta.isJson = true;
            meta.refRegex = jsonRefRegex;
        }
        else if (filepath.endsWith('.xml')) {
            tmpContentType = xmlContentType;
            meta.refRegex = xmlRefRegex;
        }
        // unable to determine content type from extension, was a global content type provided?
        if (!tmpContentType) {
            if (!contentType) {
                throw new core_1.SfError(messages.getMessage('unknownContentType', [filepath]), INVALID_DATA_IMPORT_ERR_NAME);
            }
            else if (contentType.toUpperCase() === 'JSON') {
                tmpContentType = jsonContentType;
                meta.isJson = true;
                meta.refRegex = jsonRefRegex;
            }
            else if (contentType.toUpperCase() === 'XML') {
                tmpContentType = xmlContentType;
                meta.refRegex = xmlRefRegex;
            }
            else {
                throw new core_1.SfError(messages.getMessage('dataFileUnsupported', [contentType]), INVALID_DATA_IMPORT_ERR_NAME);
            }
        }
        meta.headers['content-type'] = tmpContentType;
        return meta;
    }
    // Parse the SObject tree file, resolving any saved refs if specified.
    // Return a promise with the contents of the SObject tree file and the type.
    async parseSObjectTreeFile(filepath, isJson, refRegex, resolveRefs, refMap) {
        let contentStr;
        let contentJson;
        let match;
        let sobject = '';
        const foundRefs = new Set();
        // call identity() so the access token can be auto-updated
        const content = await fs.promises.readFile(filepath);
        if (!content) {
            throw messages.createError('dataFileEmpty', [filepath]);
        }
        contentStr = content.toString();
        if (isJson) {
            // is valid json?  (save round-trip to server)
            try {
                contentJson = JSON.parse(contentStr);
                // All top level records should be of the same sObject type so just grab the first one
                sobject = contentJson.records[0].attributes.type.toLowerCase();
            }
            catch (e) {
                throw messages.createError('dataFileInvalidJson', [filepath]);
            }
        }
        // if we're replacing references (@AcmeIncAccountId), find references in content and
        // replace with reference found in previously saved records
        if (resolveRefs && refMap) {
            // find and stash all '@' references
            while ((match = refRegex.exec(contentStr))) {
                foundRefs.add(match[1]);
            }
            if (foundRefs.size > 0 && refMap.size === 0) {
                throw messages.createError('dataFileNoRefId', [filepath]);
            }
            this.logger.debug(`Found references: ${Array.from(foundRefs).toString()}`);
            // loop thru found references and replace with id value
            foundRefs.forEach((ref) => {
                const value = refMap.get(ref.toLowerCase());
                if (value == null) {
                    // REVIEWME: fail?
                    this.logger.warn(`Reference '${ref}' not found in saved record references (${filepath})`);
                }
                else {
                    contentStr = contentStr.replace(new RegExp(`(["'>])@${ref}(["'<])`, 'igm'), `$1${value}$2`);
                }
            });
        }
        // Create map of SObject { referenceId: type } to display the type in output
        this.createSObjectTypeMap(contentStr, isJson);
        return { contentStr, sobject };
    }
    // generate REST API url: http://<sfdc-instance>/v<version>/composite/tree/<sobject>
    // and send the request.
    async sendSObjectTreeRequest(contentStr, sobject, instanceUrl, headers) {
        const apiVersion = this.org.getConnection().getApiVersion();
        let sobjectTreeApiUrl = this.sobjectUrlMap.get(sobject);
        if (!sobjectTreeApiUrl) {
            sobjectTreeApiUrl = util.format(sobjectTreeApiPartPattern, instanceUrl, apiVersion, sobject);
            this.sobjectUrlMap.set(sobject, sobjectTreeApiUrl);
        }
        this.logger.debug(`SObject Tree API URL: ${sobjectTreeApiUrl}`);
        // post request with to-be-insert sobject tree content
        return this.org.getConnection().request({
            method: 'POST',
            url: sobjectTreeApiUrl,
            body: contentStr,
            headers: headers,
        });
    }
    // Parse the response from the SObjectTree request and save refs if specified.
    parseSObjectTreeResponse(response, filepath, isJson, saveRefs, refMap) {
        if (isJson) {
            this.logger.debug(`SObject Tree API results:  ${JSON.stringify(response, null, 4)}`);
            if (response.hasErrors) {
                throw messages.createError('dataImportFailed', [filepath, JSON.stringify(response.results, null, 4)]);
            }
            if (Array.isArray(response.results)) {
                // REVIEWME: include filepath from which record was define?
                // store results to be output to stdout in aggregated tabular format
                this.responseRefs = this.responseRefs.concat(response.results);
                // if enabled, save references to map to be used to replace references
                // prior to subsequent saves
                if (saveRefs) {
                    for (let i = 0, len = response.results.length, ref; i < len; i++) {
                        ref = response.results[i];
                        if (refMap) {
                            refMap.set(ref.referenceId.toLowerCase(), ref.id);
                        }
                    }
                }
            }
        }
        else {
            throw new core_1.SfError('SObject Tree API XML response parsing not implemented', 'FailedDataImport');
        }
        return response;
    }
    // Imports the SObjectTree from the provided files/plan by making a POST request to the server.
    async importSObjectTreeFile(components) {
        // Get some file metadata
        const { isJson, refRegex, headers } = this.getSObjectTreeFileMeta(components.filepath, components.contentType);
        this.logger.debug(`Importing SObject Tree data from file ${components.filepath}`);
        try {
            const { contentStr, sobject } = await this.parseSObjectTreeFile(components.filepath, isJson, refRegex, components.resolveRefs, components.refMap);
            const response = await this.sendSObjectTreeRequest(contentStr, sobject, components.instanceUrl, headers);
            this.parseSObjectTreeResponse(response, components.filepath, isJson, components.saveRefs, components.refMap);
        }
        catch (error) {
            if (error instanceof Error && (0, ts_types_1.getString)(error, 'errorCode') === 'INVALID_FIELD') {
                const field = error.message.split("'")[1];
                const object = error.message.substr(error.message.lastIndexOf(' ') + 1, error.message.length);
                throw messages.createError('FlsError', [field, object]);
            }
            throw core_1.SfError.wrap(error);
        }
    }
}
exports.ImportApi = ImportApi;
//# sourceMappingURL=importApi.js.map