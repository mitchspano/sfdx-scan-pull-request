import _Object$defineProperty from "@babel/runtime-corejs3/core-js-stable/object/define-property";
import _Object$defineProperties from "@babel/runtime-corejs3/core-js-stable/object/define-properties";
import _Object$getOwnPropertyDescriptors from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _Object$getOwnPropertyDescriptor from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _Object$getOwnPropertySymbols from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import "core-js/modules/es.promise";
import _setTimeout from "@babel/runtime-corejs3/core-js-stable/set-timeout";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _Promise from "@babel/runtime-corejs3/core-js-stable/promise";
import _JSON$stringify from "@babel/runtime-corejs3/core-js-stable/json/stringify";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _defineProperty from "@babel/runtime-corejs3/helpers/defineProperty";
import _objectWithoutProperties from "@babel/runtime-corejs3/helpers/objectWithoutProperties";

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context2; _forEachInstanceProperty(_context2 = ownKeys(Object(source), true)).call(_context2, function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { var _context3; _forEachInstanceProperty(_context3 = ownKeys(Object(source))).call(_context3, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * @file Manages Salesforce Metadata API
 * @author Shinichi Tomita <shinichi.tomita@gmail.com>
 */
import { EventEmitter } from 'events';
import { Readable } from 'stream';
import FormData from 'form-data';
import { registerModule } from '../jsforce';
import SOAP from '../soap';
import { isObject } from '../util/function';
import { ApiSchemas } from './metadata/schema';
export * from './metadata/schema';
/**
 *
 */

/**
 *
 */
function deallocateTypeWithMetadata(metadata) {
  const _ref = metadata,
        {
    $
  } = _ref,
        md = _objectWithoutProperties(_ref, ["$"]);

  return md;
}

function assignTypeWithMetadata(metadata, type) {
  const convert = md => _objectSpread({
    ['@xsi:type']: type
  }, md);

  return _Array$isArray(metadata) ? _mapInstanceProperty(metadata).call(metadata, convert) : convert(metadata);
}
/**
 * Class for Salesforce Metadata API
 */


export class MetadataApi {
  /**
   * Polling interval in milliseconds
   */

  /**
   * Polling timeout in milliseconds
   */

  /**
   *
   */
  constructor(conn) {
    _defineProperty(this, "_conn", void 0);

    _defineProperty(this, "pollInterval", 1000);

    _defineProperty(this, "pollTimeout", 10000);

    this._conn = conn;
  }
  /**
   * Call Metadata API SOAP endpoint
   *
   * @private
   */


  async _invoke(method, message, schema) {
    const soapEndpoint = new SOAP(this._conn, {
      xmlns: 'http://soap.sforce.com/2006/04/metadata',
      endpointUrl: `${this._conn.instanceUrl}/services/Soap/m/${this._conn.version}`
    });
    const res = await soapEndpoint.invoke(method, message, schema ? {
      result: schema
    } : undefined, ApiSchemas);
    return res.result;
  }
  /**
   * Add one or more new metadata components to the organization.
   */


  create(type, metadata) {
    const isArray = _Array$isArray(metadata);

    metadata = assignTypeWithMetadata(metadata, type);
    const schema = isArray ? [ApiSchemas.SaveResult] : ApiSchemas.SaveResult;
    return this._invoke('createMetadata', {
      metadata
    }, schema);
  }
  /**
   * Read specified metadata components in the organization.
   */


  async read(type, fullNames) {
    var _context;

    const ReadResultSchema = type in ApiSchemas ? {
      type: ApiSchemas.ReadResult.type,
      props: {
        records: [type]
      }
    } : ApiSchemas.ReadResult;
    const res = await this._invoke('readMetadata', {
      type,
      fullNames
    }, ReadResultSchema);
    return _Array$isArray(fullNames) ? _mapInstanceProperty(_context = res.records).call(_context, deallocateTypeWithMetadata) : deallocateTypeWithMetadata(res.records[0]);
  }
  /**
   * Update one or more metadata components in the organization.
   */


  update(type, metadata) {
    const isArray = _Array$isArray(metadata);

    metadata = assignTypeWithMetadata(metadata, type);
    const schema = isArray ? [ApiSchemas.SaveResult] : ApiSchemas.SaveResult;
    return this._invoke('updateMetadata', {
      metadata
    }, schema);
  }
  /**
   * Upsert one or more components in your organization's data.
   */


  upsert(type, metadata) {
    const isArray = _Array$isArray(metadata);

    metadata = assignTypeWithMetadata(metadata, type);
    const schema = isArray ? [ApiSchemas.UpsertResult] : ApiSchemas.UpsertResult;
    return this._invoke('upsertMetadata', {
      metadata
    }, schema);
  }
  /**
   * Deletes specified metadata components in the organization.
   */


  delete(type, fullNames) {
    const schema = _Array$isArray(fullNames) ? [ApiSchemas.SaveResult] : ApiSchemas.SaveResult;
    return this._invoke('deleteMetadata', {
      type,
      fullNames
    }, schema);
  }
  /**
   * Rename fullname of a metadata component in the organization
   */


  rename(type, oldFullName, newFullName) {
    return this._invoke('renameMetadata', {
      type,
      oldFullName,
      newFullName
    }, ApiSchemas.SaveResult);
  }
  /**
   * Retrieves the metadata which describes your organization, including Apex classes and triggers,
   * custom objects, custom fields on standard objects, tab sets that define an app,
   * and many other components.
   */


  describe(asOfVersion) {
    if (!asOfVersion) {
      asOfVersion = this._conn.version;
    }

    return this._invoke('describeMetadata', {
      asOfVersion
    }, ApiSchemas.DescribeMetadataResult);
  }
  /**
   * Retrieves property information about metadata components in your organization
   */


  list(queries, asOfVersion) {
    if (!asOfVersion) {
      asOfVersion = this._conn.version;
    }

    return this._invoke('listMetadata', {
      queries,
      asOfVersion
    }, [ApiSchemas.FileProperties]);
  }
  /**
   * Checks the status of asynchronous metadata calls
   */


  checkStatus(asyncProcessId) {
    const res = this._invoke('checkStatus', {
      asyncProcessId
    }, ApiSchemas.AsyncResult);

    return new AsyncResultLocator(this, res);
  }
  /**
   * Retrieves XML file representations of components in an organization
   */


  retrieve(request) {
    const res = this._invoke('retrieve', {
      request
    }, ApiSchemas.RetrieveResult);

    return new RetrieveResultLocator(this, res);
  }
  /**
   * Checks the status of declarative metadata call retrieve() and returns the zip file contents
   */


  checkRetrieveStatus(asyncProcessId) {
    return this._invoke('checkRetrieveStatus', {
      asyncProcessId
    }, ApiSchemas.RetrieveResult);
  }
  /**
   * Deploy components into an organization using zipped file representations
   * using the REST Metadata API instead of SOAP
   */


  deployRest(zipInput, options = {}) {
    const form = new FormData();
    form.append('file', zipInput, {
      contentType: 'application/zip',
      filename: 'package.xml'
    }); // Add the deploy options

    form.append('entity_content', _JSON$stringify({
      deployOptions: options
    }), {
      contentType: 'application/json'
    });
    const request = {
      url: '/metadata/deployRequest',
      method: 'POST',
      headers: _objectSpread({}, form.getHeaders()),
      body: form.getBuffer()
    };

    const res = this._conn.request(request);

    return new DeployResultLocator(this, res);
  }
  /**
   * Deploy components into an organization using zipped file representations
   */


  deploy(zipInput, options = {}) {
    const res = (async () => {
      const zipContentB64 = await new _Promise((resolve, reject) => {
        if (isObject(zipInput) && 'pipe' in zipInput && typeof zipInput.pipe === 'function') {
          const bufs = [];
          zipInput.on('data', d => bufs.push(d));
          zipInput.on('error', reject);
          zipInput.on('end', () => {
            resolve(_concatInstanceProperty(Buffer).call(Buffer, bufs).toString('base64'));
          }); // zipInput.resume();
        } else if (zipInput instanceof Buffer) {
          resolve(zipInput.toString('base64'));
        } else if (zipInput instanceof String || typeof zipInput === 'string') {
          resolve(zipInput);
        } else {
          throw 'Unexpected zipInput type';
        }
      });
      return this._invoke('deploy', {
        ZipFile: zipContentB64,
        DeployOptions: options
      }, ApiSchemas.DeployResult);
    })();

    return new DeployResultLocator(this, res);
  }
  /**
   * Checks the status of declarative metadata call deploy()
   */


  checkDeployStatus(asyncProcessId, includeDetails = false) {
    return this._invoke('checkDeployStatus', {
      asyncProcessId,
      includeDetails
    }, ApiSchemas.DeployResult);
  }

}
/*--------------------------------------------*/

/**
 * The locator class for Metadata API asynchronous call result
 */

export class AsyncResultLocator extends EventEmitter {
  /**
   *
   */
  constructor(meta, promise) {
    super();

    _defineProperty(this, "_meta", void 0);

    _defineProperty(this, "_promise", void 0);

    _defineProperty(this, "_id", void 0);

    this._meta = meta;
    this._promise = promise;
  }
  /**
   * Promise/A+ interface
   * http://promises-aplus.github.io/promises-spec/
   *
   * @method Metadata~AsyncResultLocator#then
   */


  then(onResolve, onReject) {
    return this._promise.then(onResolve, onReject);
  }
  /**
   * Check the status of async request
   */


  async check() {
    const result = await this._promise;
    this._id = result.id;
    return await this._meta.checkStatus(result.id);
  }
  /**
   * Polling until async call status becomes complete or error
   */


  poll(interval, timeout) {
    const startTime = new Date().getTime();

    const poll = async () => {
      try {
        const now = new Date().getTime();

        if (startTime + timeout < now) {
          let errMsg = 'Polling time out.';

          if (this._id) {
            errMsg += ' Process Id = ' + this._id;
          }

          this.emit('error', new Error(errMsg));
          return;
        }

        const result = await this.check();

        if (result.done) {
          this.emit('complete', result);
        } else {
          this.emit('progress', result);

          _setTimeout(poll, interval);
        }
      } catch (err) {
        this.emit('error', err);
      }
    };

    _setTimeout(poll, interval);
  }
  /**
   * Check and wait until the async requests become in completed status
   */


  complete() {
    return new _Promise((resolve, reject) => {
      this.on('complete', resolve);
      this.on('error', reject);
      this.poll(this._meta.pollInterval, this._meta.pollTimeout);
    });
  }

}
/*--------------------------------------------*/

/**
 * The locator class to track retreive() Metadata API call result
 */

export class RetrieveResultLocator extends AsyncResultLocator {
  /**
   * Check and wait until the async request becomes in completed status,
   * and retrieve the result data.
   */
  async complete() {
    const result = await super.complete();
    return this._meta.checkRetrieveStatus(result.id);
  }
  /**
   * Change the retrieved result to Node.js readable stream
   */


  stream() {
    const resultStream = new Readable();
    let reading = false;

    resultStream._read = async () => {
      if (reading) {
        return;
      }

      reading = true;

      try {
        const result = await this.complete();
        resultStream.push(Buffer.from(result.zipFile, 'base64'));
        resultStream.push(null);
      } catch (e) {
        resultStream.emit('error', e);
      }
    };

    return resultStream;
  }

}
/*--------------------------------------------*/

/**
 * The locator class to track deploy() Metadata API call result
 *
 * @protected
 * @class Metadata~DeployResultLocator
 * @extends Metadata~AsyncResultLocator
 * @param {Metadata} meta - Metadata API object
 * @param {Promise.<Metadata~AsyncResult>} result - Promise object for async result of deploy() call
 */

export class DeployResultLocator extends AsyncResultLocator {
  /**
   * Check and wait until the async request becomes in completed status,
   * and retrieve the result data.
   */
  async complete(includeDetails) {
    const result = await super.complete();
    return this._meta.checkDeployStatus(result.id, includeDetails);
  }

}
/*--------------------------------------------*/

/*
 * Register hook in connection instantiation for dynamically adding this API module features
 */

registerModule('metadata', conn => new MetadataApi(conn));
export default MetadataApi;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvbWV0YWRhdGEudHMiXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwiUmVhZGFibGUiLCJGb3JtRGF0YSIsInJlZ2lzdGVyTW9kdWxlIiwiU09BUCIsImlzT2JqZWN0IiwiQXBpU2NoZW1hcyIsImRlYWxsb2NhdGVUeXBlV2l0aE1ldGFkYXRhIiwibWV0YWRhdGEiLCIkIiwibWQiLCJhc3NpZ25UeXBlV2l0aE1ldGFkYXRhIiwidHlwZSIsImNvbnZlcnQiLCJNZXRhZGF0YUFwaSIsImNvbnN0cnVjdG9yIiwiY29ubiIsIl9jb25uIiwiX2ludm9rZSIsIm1ldGhvZCIsIm1lc3NhZ2UiLCJzY2hlbWEiLCJzb2FwRW5kcG9pbnQiLCJ4bWxucyIsImVuZHBvaW50VXJsIiwiaW5zdGFuY2VVcmwiLCJ2ZXJzaW9uIiwicmVzIiwiaW52b2tlIiwicmVzdWx0IiwidW5kZWZpbmVkIiwiY3JlYXRlIiwiaXNBcnJheSIsIlNhdmVSZXN1bHQiLCJyZWFkIiwiZnVsbE5hbWVzIiwiUmVhZFJlc3VsdFNjaGVtYSIsIlJlYWRSZXN1bHQiLCJwcm9wcyIsInJlY29yZHMiLCJ1cGRhdGUiLCJ1cHNlcnQiLCJVcHNlcnRSZXN1bHQiLCJkZWxldGUiLCJyZW5hbWUiLCJvbGRGdWxsTmFtZSIsIm5ld0Z1bGxOYW1lIiwiZGVzY3JpYmUiLCJhc09mVmVyc2lvbiIsIkRlc2NyaWJlTWV0YWRhdGFSZXN1bHQiLCJsaXN0IiwicXVlcmllcyIsIkZpbGVQcm9wZXJ0aWVzIiwiY2hlY2tTdGF0dXMiLCJhc3luY1Byb2Nlc3NJZCIsIkFzeW5jUmVzdWx0IiwiQXN5bmNSZXN1bHRMb2NhdG9yIiwicmV0cmlldmUiLCJyZXF1ZXN0IiwiUmV0cmlldmVSZXN1bHQiLCJSZXRyaWV2ZVJlc3VsdExvY2F0b3IiLCJjaGVja1JldHJpZXZlU3RhdHVzIiwiZGVwbG95UmVzdCIsInppcElucHV0Iiwib3B0aW9ucyIsImZvcm0iLCJhcHBlbmQiLCJjb250ZW50VHlwZSIsImZpbGVuYW1lIiwiZGVwbG95T3B0aW9ucyIsInVybCIsImhlYWRlcnMiLCJnZXRIZWFkZXJzIiwiYm9keSIsImdldEJ1ZmZlciIsIkRlcGxveVJlc3VsdExvY2F0b3IiLCJkZXBsb3kiLCJ6aXBDb250ZW50QjY0IiwicmVzb2x2ZSIsInJlamVjdCIsInBpcGUiLCJidWZzIiwib24iLCJkIiwicHVzaCIsIkJ1ZmZlciIsInRvU3RyaW5nIiwiU3RyaW5nIiwiWmlwRmlsZSIsIkRlcGxveU9wdGlvbnMiLCJEZXBsb3lSZXN1bHQiLCJjaGVja0RlcGxveVN0YXR1cyIsImluY2x1ZGVEZXRhaWxzIiwibWV0YSIsInByb21pc2UiLCJfbWV0YSIsIl9wcm9taXNlIiwidGhlbiIsIm9uUmVzb2x2ZSIsIm9uUmVqZWN0IiwiY2hlY2siLCJfaWQiLCJpZCIsInBvbGwiLCJpbnRlcnZhbCIsInRpbWVvdXQiLCJzdGFydFRpbWUiLCJEYXRlIiwiZ2V0VGltZSIsIm5vdyIsImVyck1zZyIsImVtaXQiLCJFcnJvciIsImRvbmUiLCJlcnIiLCJjb21wbGV0ZSIsInBvbGxJbnRlcnZhbCIsInBvbGxUaW1lb3V0Iiwic3RyZWFtIiwicmVzdWx0U3RyZWFtIiwicmVhZGluZyIsIl9yZWFkIiwiZnJvbSIsInppcEZpbGUiLCJlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQSxZQUFULFFBQTZCLFFBQTdCO0FBQ0EsU0FBU0MsUUFBVCxRQUF5QixRQUF6QjtBQUNBLE9BQU9DLFFBQVAsTUFBcUIsV0FBckI7QUFDQSxTQUFTQyxjQUFULFFBQStCLFlBQS9CO0FBRUEsT0FBT0MsSUFBUCxNQUFpQixTQUFqQjtBQUNBLFNBQVNDLFFBQVQsUUFBeUIsa0JBQXpCO0FBRUEsU0FDRUMsVUFERixRQWVPLG1CQWZQO0FBZ0JBLGNBQWMsbUJBQWQ7QUFFQTtBQUNBO0FBQ0E7O0FBaUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNDLDBCQUFULENBQXdEQyxRQUF4RCxFQUF3RTtBQUN0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QSxZQUFZLENBQUNuQyxJQUFiLENBQWtCQyxNQUFNLENBQUNxQyxJQUFQLENBQVk3RixNQUFNLENBQUM4RixPQUFuQixFQUE0QixRQUE1QixDQUFsQjtBQUNBSixRQUFBQSxZQUFZLENBQUNuQyxJQUFiLENBQWtCLElBQWxCO0FBQ0QsT0FKRCxDQUlFLE9BQU93QyxDQUFQLEVBQVU7QUFDVkwsUUFBQUEsWUFBWSxDQUFDUixJQUFiLENBQWtCLE9BQWxCLEVBQTJCYSxDQUEzQjtBQUNEO0FBQ0YsS0FaRDs7QUFhQSxXQUFPTCxZQUFQO0FBQ0Q7O0FBOUJEO0FBaUNGOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxPQUFPLE1BQU01QyxtQkFBTixTQUFvRG5CLGtCQUFwRCxDQUdMO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRSxRQUFNMkQsUUFBTixDQUFldkIsY0FBZixFQUF5QztBQUN2QyxVQUFNL0QsTUFBTSxHQUFHLE1BQU0sTUFBTXNGLFFBQU4sRUFBckI7QUFDQSxXQUFPLEtBQUtwQixLQUFMLENBQVdKLGlCQUFYLENBQTZCOUQsTUFBTSxDQUFDeUUsRUFBcEMsRUFBd0NWLGNBQXhDLENBQVA7QUFDRDs7QUFSRDtBQVdGOztBQUNBO0FBQ0E7QUFDQTs7QUFDQXpGLGNBQWMsQ0FBQyxVQUFELEVBQWNhLElBQUQsSUFBVSxJQUFJRixXQUFKLENBQWdCRSxJQUFoQixDQUF2QixDQUFkO0FBRUEsZUFBZUYsV0FBZiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgTWFuYWdlcyBTYWxlc2ZvcmNlIE1ldGFkYXRhIEFQSVxuICogQGF1dGhvciBTaGluaWNoaSBUb21pdGEgPHNoaW5pY2hpLnRvbWl0YUBnbWFpbC5jb20+XG4gKi9cbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBSZWFkYWJsZSB9IGZyb20gJ3N0cmVhbSc7XG5pbXBvcnQgRm9ybURhdGEgZnJvbSAnZm9ybS1kYXRhJztcbmltcG9ydCB7IHJlZ2lzdGVyTW9kdWxlIH0gZnJvbSAnLi4vanNmb3JjZSc7XG5pbXBvcnQgQ29ubmVjdGlvbiBmcm9tICcuLi9jb25uZWN0aW9uJztcbmltcG9ydCBTT0FQIGZyb20gJy4uL3NvYXAnO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICcuLi91dGlsL2Z1bmN0aW9uJztcbmltcG9ydCB7IFNjaGVtYSwgU29hcFNjaGVtYURlZiwgU29hcFNjaGVtYSwgSHR0cFJlcXVlc3QgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge1xuICBBcGlTY2hlbWFzLFxuICBNZXRhZGF0YSxcbiAgUmVhZFJlc3VsdCxcbiAgU2F2ZVJlc3VsdCxcbiAgVXBzZXJ0UmVzdWx0LFxuICBMaXN0TWV0YWRhdGFRdWVyeSxcbiAgRmlsZVByb3BlcnRpZXMsXG4gIERlc2NyaWJlTWV0YWRhdGFSZXN1bHQsXG4gIFJldHJpZXZlUmVxdWVzdCxcbiAgRGVwbG95T3B0aW9ucyxcbiAgUmV0cmlldmVSZXN1bHQsXG4gIERlcGxveVJlc3VsdCxcbiAgQXN5bmNSZXN1bHQsXG4gIEFwaVNjaGVtYVR5cGVzLFxufSBmcm9tICcuL21ldGFkYXRhL3NjaGVtYSc7XG5leHBvcnQgKiBmcm9tICcuL21ldGFkYXRhL3NjaGVtYSc7XG5cbi8qKlxuICpcbiAqL1xudHlwZSBNZXRhZGF0YVR5cGVfPFxuICBLIGV4dGVuZHMga2V5b2YgQXBpU2NoZW1hVHlwZXMgPSBrZXlvZiBBcGlTY2hlbWFUeXBlc1xuPiA9IEsgZXh0ZW5kcyBrZXlvZiBBcGlTY2hlbWFUeXBlc1xuICA/IEFwaVNjaGVtYVR5cGVzW0tdIGV4dGVuZHMgTWV0YWRhdGFcbiAgICA/IEtcbiAgICA6IG5ldmVyXG4gIDogbmV2ZXI7XG5cbmV4cG9ydCB0eXBlIE1ldGFkYXRhVHlwZSA9IE1ldGFkYXRhVHlwZV87XG5cbmV4cG9ydCB0eXBlIE1ldGFkYXRhRGVmaW5pdGlvbjxcbiAgVCBleHRlbmRzIHN0cmluZyxcbiAgTSBleHRlbmRzIE1ldGFkYXRhID0gTWV0YWRhdGFcbj4gPSBNZXRhZGF0YSBleHRlbmRzIE1cbiAgPyBUIGV4dGVuZHMga2V5b2YgQXBpU2NoZW1hVHlwZXMgJiBNZXRhZGF0YVR5cGVcbiAgICA/IEFwaVNjaGVtYVR5cGVzW1RdIGV4dGVuZHMgTWV0YWRhdGFcbiAgICAgID8gQXBpU2NoZW1hVHlwZXNbVF1cbiAgICAgIDogTWV0YWRhdGFcbiAgICA6IE1ldGFkYXRhXG4gIDogTTtcblxudHlwZSBEZWVwUGFydGlhbDxUPiA9IFQgZXh0ZW5kcyBhbnlbXVxuICA/IERlZXBQYXJ0aWFsPFRbbnVtYmVyXT5bXVxuICA6IFQgZXh0ZW5kcyBvYmplY3RcbiAgPyB7IFtLIGluIGtleW9mIFRdPzogRGVlcFBhcnRpYWw8VFtLXT4gfVxuICA6IFQ7XG5cbmV4cG9ydCB0eXBlIElucHV0TWV0YWRhdGFEZWZpbml0aW9uPFxuICBUIGV4dGVuZHMgc3RyaW5nLFxuICBNIGV4dGVuZHMgTWV0YWRhdGEgPSBNZXRhZGF0YVxuPiA9IERlZXBQYXJ0aWFsPE1ldGFkYXRhRGVmaW5pdGlvbjxULCBNPj47XG5cbi8qKlxuICpcbiAqL1xuZnVuY3Rpb24gZGVhbGxvY2F0ZVR5cGVXaXRoTWV0YWRhdGE8TSBleHRlbmRzIE1ldGFkYXRhPihtZXRhZGF0YTogTSk6IE0ge1xuICBjb25zdCB7ICQsIC4uLm1kIH0gPSBtZXRhZGF0YSBhcyBhbnk7XG4gIHJldHVybiBtZDtcbn1cblxuZnVuY3Rpb24gYXNzaWduVHlwZVdpdGhNZXRhZGF0YShtZXRhZGF0YTogTWV0YWRhdGEgfCBNZXRhZGF0YVtdLCB0eXBlOiBzdHJpbmcpIHtcbiAgY29uc3QgY29udmVydCA9IChtZDogTWV0YWRhdGEpID0+ICh7IFsnQHhzaTp0eXBlJ106IHR5cGUsIC4uLm1kIH0pO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShtZXRhZGF0YSkgPyBtZXRhZGF0YS5tYXAoY29udmVydCkgOiBjb252ZXJ0KG1ldGFkYXRhKTtcbn1cblxuLyoqXG4gKiBDbGFzcyBmb3IgU2FsZXNmb3JjZSBNZXRhZGF0YSBBUElcbiAqL1xuZXhwb3J0IGNsYXNzIE1ldGFkYXRhQXBpPFMgZXh0ZW5kcyBTY2hlbWE+IHtcbiAgX2Nvbm46IENvbm5lY3Rpb248Uz47XG5cbiAgLyoqXG4gICAqIFBvbGxpbmcgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzXG4gICAqL1xuICBwb2xsSW50ZXJ2YWw6IG51bWJlciA9IDEwMDA7XG5cbiAgLyoqXG4gICAqIFBvbGxpbmcgdGltZW91dCBpbiBtaWxsaXNlY29uZHNcbiAgICovXG4gIHBvbGxUaW1lb3V0OiBudW1iZXIgPSAxMDAwMDtcblxuICAvKipcbiAgICpcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbm46IENvbm5lY3Rpb248Uz4pIHtcbiAgICB0aGlzLl9jb25uID0gY29ubjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIE1ldGFkYXRhIEFQSSBTT0FQIGVuZHBvaW50XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBfaW52b2tlKFxuICAgIG1ldGhvZDogc3RyaW5nLFxuICAgIG1lc3NhZ2U6IG9iamVjdCxcbiAgICBzY2hlbWE/OiBTb2FwU2NoZW1hIHwgU29hcFNjaGVtYURlZixcbiAgKSB7XG4gICAgY29uc3Qgc29hcEVuZHBvaW50ID0gbmV3IFNPQVAodGhpcy5fY29ubiwge1xuICAgICAgeG1sbnM6ICdodHRwOi8vc29hcC5zZm9yY2UuY29tLzIwMDYvMDQvbWV0YWRhdGEnLFxuICAgICAgZW5kcG9pbnRVcmw6IGAke3RoaXMuX2Nvbm4uaW5zdGFuY2VVcmx9L3NlcnZpY2VzL1NvYXAvbS8ke3RoaXMuX2Nvbm4udmVyc2lvbn1gLFxuICAgIH0pO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHNvYXBFbmRwb2ludC5pbnZva2UoXG4gICAgICBtZXRob2QsXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2NoZW1hID8gKHsgcmVzdWx0OiBzY2hlbWEgfSBhcyBTb2FwU2NoZW1hKSA6IHVuZGVmaW5lZCxcbiAgICAgIEFwaVNjaGVtYXMsXG4gICAgKTtcbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgb25lIG9yIG1vcmUgbmV3IG1ldGFkYXRhIGNvbXBvbmVudHMgdG8gdGhlIG9yZ2FuaXphdGlvbi5cbiAgICovXG4gIGNyZWF0ZTxcbiAgICBNIGV4dGVuZHMgTWV0YWRhdGEgPSBNZXRhZGF0YSxcbiAgICBUIGV4dGVuZHMgTWV0YWRhdGFUeXBlID0gTWV0YWRhdGFUeXBlLFxuICAgIE1EIGV4dGVuZHMgSW5wdXRNZXRhZGF0YURlZmluaXRpb248VCwgTT4gPSBJbnB1dE1ldGFkYXRhRGVmaW5pdGlvbjxULCBNPlxuICA+KHR5cGU6IFQsIG1ldGFkYXRhOiBNRFtdKTogUHJvbWlzZTxTYXZlUmVzdWx0W10+O1xuICBjcmVhdGU8XG4gICAgTSBleHRlbmRzIE1ldGFkYXRhID0gTWV0YWRhdGEsXG4gICAgVCBleHRlbmRzIE1ldGFkYXRhVHlwZSA9IE1ldGFkYXRhVHlwZSxcbiAgICBNRCBleHRlbmRzIElucHV0TWV0YWRhdGFEZWZpbml0aW9uPFQsIE0+ID0gSW5wdXRNZXRhZGF0YURlZmluaXRpb248VCwgTT5cbiAgPih0eXBlOiBULCBtZXRhZGF0YTogTUQpOiBQcm9taXNlPFNhdmVSZXN1bHQ+O1xuICBjcmVhdGU8XG4gICAgTSBleHRlbmRzIE1ldGFkYXRhID0gTWV0YWRhdGEsXG4gICAgVCBleHRlbmRzIE1ldGFkYXRhVHlwZSA9IE1ldGFkYXRhVHlwZSxcbiAgICBNRCBleHRlbmRzIElucHV0TWV0YWRhdGFEZWZpbml0aW9uPFQsIE0+ID0gSW5wdXRNZXRhZGF0YURlZmluaXRpb248VCwgTT5cbiAgPih0eXBlOiBULCBtZXRhZGF0YTogTUQgfCBNRFtdKTogUHJvbWlzZTxTYXZlUmVzdWx0IHwgU2F2ZVJlc3VsdFtdPjtcbiAgY3JlYXRlKHR5cGU6IHN0cmluZywgbWV0YWRhdGE6IE1ldGFkYXRhIHwgTWV0YWRhdGFbXSkge1xuICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KG1ldGFkYXRhKTtcbiAgICBtZXRhZGF0YSA9IGFzc2lnblR5cGVXaXRoTWV0YWRhdGEobWV0YWRhdGEsIHR5cGUpO1xuICAgIGNvbnN0IHNjaGVtYSA9IGlzQXJyYXkgPyBbQXBpU2NoZW1hcy5TYXZlUmVzdWx0XSA6IEFwaVNjaGVtYXMuU2F2ZVJlc3VsdDtcbiAgICByZXR1cm4gdGhpcy5faW52b2tlKCdjcmVhdGVNZXRhZGF0YScsIHsgbWV0YWRhdGEgfSwgc2NoZW1hKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIHNwZWNpZmllZCBtZXRhZGF0YSBjb21wb25lbnRzIGluIHRoZSBvcmdhbml6YXRpb24uXG4gICAqL1xuICByZWFkPFxuICAgIE0gZXh0ZW5kcyBNZXRhZGF0YSA9IE1ldGFkYXRhLFxuICAgIFQgZXh0ZW5kcyBNZXRhZGF0YVR5cGUgPSBNZXRhZGF0YVR5cGUsXG4gICAgTUQgZXh0ZW5kcyBNZXRhZGF0YURlZmluaXRpb248VCwgTT4gPSBNZXRhZGF0YURlZmluaXRpb248VCwgTT5cbiAgPih0eXBlOiBULCBmdWxsTmFtZXM6IHN0cmluZ1tdKTogUHJvbWlzZTxNRFtdPjtcbiAgcmVhZDxcbiAgICBNIGV4dGVuZHMgTWV0YWRhdGEgPSBNZXRhZGF0YSxcbiAgICBUIGV4dGVuZHMgTWV0YWRhdGFUeXBlID0gTWV0YWRhdGFUeXBlLFxuICAgIE1EIGV4dGVuZHMgTWV0YWRhdGFEZWZpbml0aW9uPFQsIE0+ID0gTWV0YWRhdGFEZWZpbml0aW9uPFQsIE0+XG4gID4odHlwZTogVCwgZnVsbE5hbWVzOiBzdHJpbmcpOiBQcm9taXNlPE1EPjtcbiAgcmVhZDxcbiAgICBNIGV4dGVuZHMgTWV0YWRhdGEgPSBNZXRhZGF0YSxcbiAgICBUIGV4dGVuZHMgTWV0YWRhdGFUeXBlID0gTWV0YWRhdGFUeXBlLFxuICAgIE1EIGV4dGVuZHMgTWV0YWRhdGFEZWZpbml0aW9uPFQsIE0+ID0gTWV0YWRhdGFEZWZpbml0aW9uPFQsIE0+XG4gID4odHlwZTogVCwgZnVsbE5hbWVzOiBzdHJpbmcgfCBzdHJpbmdbXSk6IFByb21pc2U8TUQgfCBNRFtdPjtcbiAgYXN5bmMgcmVhZCh0eXBlOiBzdHJpbmcsIGZ1bGxOYW1lczogc3RyaW5nIHwgc3RyaW5nW10pIHtcbiAgICBjb25zdCBSZWFkUmVzdWx0U2NoZW1hID1cbiAgICAgIHR5cGUgaW4gQXBpU2NoZW1hc1xuICAgICAgICA/ICh7XG4gICAgICAgICAgICB0eXBlOiBBcGlTY2hlbWFzLlJlYWRSZXN1bHQudHlwZSxcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgIHJlY29yZHM6IFt0eXBlXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSBhcyBjb25zdClcbiAgICAgICAgOiBBcGlTY2hlbWFzLlJlYWRSZXN1bHQ7XG4gICAgY29uc3QgcmVzOiBSZWFkUmVzdWx0ID0gYXdhaXQgdGhpcy5faW52b2tlKFxuICAgICAgJ3JlYWRNZXRhZGF0YScsXG4gICAgICB7IHR5cGUsIGZ1bGxOYW1lcyB9LFxuICAgICAgUmVhZFJlc3VsdFNjaGVtYSxcbiAgICApO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGZ1bGxOYW1lcylcbiAgICAgID8gcmVzLnJlY29yZHMubWFwKGRlYWxsb2NhdGVUeXBlV2l0aE1ldGFkYXRhKVxuICAgICAgOiBkZWFsbG9jYXRlVHlwZVdpdGhNZXRhZGF0YShyZXMucmVjb3Jkc1swXSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIG9uZSBvciBtb3JlIG1ldGFkYXRhIGNvbXBvbmVudHMgaW4gdGhlIG9yZ2FuaXphdGlvbi5cbiAgICovXG4gIHVwZGF0ZTxcbiAgICBNIGV4dGVuZHMgTWV0YWRhdGEgPSBNZXRhZGF0YSxcbiAgICBUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nLFxuICAgIE1EIGV4dGVuZHMgSW5wdXRNZXRhZGF0YURlZmluaXRpb248VCwgTT4gPSBJbnB1dE1ldGFkYXRhRGVmaW5pdGlvbjxULCBNPlxuICA+KHR5cGU6IFQsIG1ldGFkYXRhOiBQYXJ0aWFsPE1EPltdKTogUHJvbWlzZTxTYXZlUmVzdWx0W10+O1xuICB1cGRhdGU8XG4gICAgTSBleHRlbmRzIE1ldGFkYXRhID0gTWV0YWRhdGEsXG4gICAgVCBleHRlbmRzIHN0cmluZyA9IHN0cmluZyxcbiAgICBNRCBleHRlbmRzIElucHV0TWV0YWRhdGFEZWZpbml0aW9uPFQsIE0+ID0gSW5wdXRNZXRhZGF0YURlZmluaXRpb248VCwgTT5cbiAgPih0eXBlOiBULCBtZXRhZGF0YTogUGFydGlhbDxNRD4pOiBQcm9taXNlPFNhdmVSZXN1bHQ+O1xuICB1cGRhdGU8XG4gICAgTSBleHRlbmRzIE1ldGFkYXRhID0gTWV0YWRhdGEsXG4gICAgVCBleHRlbmRzIHN0cmluZyA9IHN0cmluZyxcbiAgICBNRCBleHRlbmRzIElucHV0TWV0YWRhdGFEZWZpbml0aW9uPFQsIE0+ID0gSW5wdXRNZXRhZGF0YURlZmluaXRpb248VCwgTT5cbiAgPihcbiAgICB0eXBlOiBULFxuICAgIG1ldGFkYXRhOiBQYXJ0aWFsPE1EPiB8IFBhcnRpYWw8TUQ+W10sXG4gICk6IFByb21pc2U8U2F2ZVJlc3VsdCB8IFNhdmVSZXN1bHRbXT47XG4gIHVwZGF0ZSh0eXBlOiBzdHJpbmcsIG1ldGFkYXRhOiBNZXRhZGF0YSB8IE1ldGFkYXRhW10pIHtcbiAgICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShtZXRhZGF0YSk7XG4gICAgbWV0YWRhdGEgPSBhc3NpZ25UeXBlV2l0aE1ldGFkYXRhKG1ldGFkYXRhLCB0eXBlKTtcbiAgICBjb25zdCBzY2hlbWEgPSBpc0FycmF5ID8gW0FwaVNjaGVtYXMuU2F2ZVJlc3VsdF0gOiBBcGlTY2hlbWFzLlNhdmVSZXN1bHQ7XG4gICAgcmV0dXJuIHRoaXMuX2ludm9rZSgndXBkYXRlTWV0YWRhdGEnLCB7IG1ldGFkYXRhIH0sIHNjaGVtYSk7XG4gIH1cblxuICAvKipcbiAgICogVXBzZXJ0IG9uZSBvciBtb3JlIGNvbXBvbmVudHMgaW4geW91ciBvcmdhbml6YXRpb24ncyBkYXRhLlxuICAgKi9cbiAgdXBzZXJ0PFxuICAgIE0gZXh0ZW5kcyBNZXRhZGF0YSA9IE1ldGFkYXRhLFxuICAgIFQgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsXG4gICAgTUQgZXh0ZW5kcyBJbnB1dE1ldGFkYXRhRGVmaW5pdGlvbjxULCBNPiA9IElucHV0TWV0YWRhdGFEZWZpbml0aW9uPFQsIE0+XG4gID4odHlwZTogVCwgbWV0YWRhdGE6IE1EW10pOiBQcm9taXNlPFVwc2VydFJlc3VsdFtdPjtcbiAgdXBzZXJ0PFxuICAgIE0gZXh0ZW5kcyBNZXRhZGF0YSA9IE1ldGFkYXRhLFxuICAgIFQgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsXG4gICAgTUQgZXh0ZW5kcyBJbnB1dE1ldGFkYXRhRGVmaW5pdGlvbjxULCBNPiA9IElucHV0TWV0YWRhdGFEZWZpbml0aW9uPFQsIE0+XG4gID4odHlwZTogVCwgbWV0YWRhdGE6IE1EKTogUHJvbWlzZTxVcHNlcnRSZXN1bHQ+O1xuICB1cHNlcnQ8XG4gICAgTSBleHRlbmRzIE1ldGFkYXRhID0gTWV0YWRhdGEsXG4gICAgVCBleHRlbmRzIHN0cmluZyA9IHN0cmluZyxcbiAgICBNRCBleHRlbmRzIElucHV0TWV0YWRhdGFEZWZpbml0aW9uPFQsIE0+ID0gSW5wdXRNZXRhZGF0YURlZmluaXRpb248VCwgTT5cbiAgPih0eXBlOiBULCBtZXRhZGF0YTogTUQgfCBNRFtdKTogUHJvbWlzZTxVcHNlcnRSZXN1bHQgfCBVcHNlcnRSZXN1bHRbXT47XG4gIHVwc2VydCh0eXBlOiBzdHJpbmcsIG1ldGFkYXRhOiBNZXRhZGF0YSB8IE1ldGFkYXRhW10pIHtcbiAgICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShtZXRhZGF0YSk7XG4gICAgbWV0YWRhdGEgPSBhc3NpZ25UeXBlV2l0aE1ldGFkYXRhKG1ldGFkYXRhLCB0eXBlKTtcbiAgICBjb25zdCBzY2hlbWEgPSBpc0FycmF5XG4gICAgICA/IFtBcGlTY2hlbWFzLlVwc2VydFJlc3VsdF1cbiAgICAgIDogQXBpU2NoZW1hcy5VcHNlcnRSZXN1bHQ7XG4gICAgcmV0dXJuIHRoaXMuX2ludm9rZSgndXBzZXJ0TWV0YWRhdGEnLCB7IG1ldGFkYXRhIH0sIHNjaGVtYSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBzcGVjaWZpZWQgbWV0YWRhdGEgY29tcG9uZW50cyBpbiB0aGUgb3JnYW5pemF0aW9uLlxuICAgKi9cbiAgZGVsZXRlKHR5cGU6IHN0cmluZywgZnVsbE5hbWVzOiBzdHJpbmdbXSk6IFByb21pc2U8U2F2ZVJlc3VsdFtdPjtcbiAgZGVsZXRlKHR5cGU6IHN0cmluZywgZnVsbE5hbWVzOiBzdHJpbmcpOiBQcm9taXNlPFNhdmVSZXN1bHQ+O1xuICBkZWxldGUoXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIGZ1bGxOYW1lczogc3RyaW5nIHwgc3RyaW5nW10sXG4gICk6IFByb21pc2U8U2F2ZVJlc3VsdCB8IFNhdmVSZXN1bHRbXT47XG4gIGRlbGV0ZSh0eXBlOiBzdHJpbmcsIGZ1bGxOYW1lczogc3RyaW5nIHwgc3RyaW5nW10pIHtcbiAgICBjb25zdCBzY2hlbWEgPSBBcnJheS5pc0FycmF5KGZ1bGxOYW1lcylcbiAgICAgID8gW0FwaVNjaGVtYXMuU2F2ZVJlc3VsdF1cbiAgICAgIDogQXBpU2NoZW1hcy5TYXZlUmVzdWx0O1xuICAgIHJldHVybiB0aGlzLl9pbnZva2UoJ2RlbGV0ZU1ldGFkYXRhJywgeyB0eXBlLCBmdWxsTmFtZXMgfSwgc2NoZW1hKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5hbWUgZnVsbG5hbWUgb2YgYSBtZXRhZGF0YSBjb21wb25lbnQgaW4gdGhlIG9yZ2FuaXphdGlvblxuICAgKi9cbiAgcmVuYW1lKFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBvbGRGdWxsTmFtZTogc3RyaW5nLFxuICAgIG5ld0Z1bGxOYW1lOiBzdHJpbmcsXG4gICk6IFByb21pc2U8U2F2ZVJlc3VsdD4ge1xuICAgIHJldHVybiB0aGlzLl9pbnZva2UoXG4gICAgICAncmVuYW1lTWV0YWRhdGEnLFxuICAgICAgeyB0eXBlLCBvbGRGdWxsTmFtZSwgbmV3RnVsbE5hbWUgfSxcbiAgICAgIEFwaVNjaGVtYXMuU2F2ZVJlc3VsdCxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgbWV0YWRhdGEgd2hpY2ggZGVzY3JpYmVzIHlvdXIgb3JnYW5pemF0aW9uLCBpbmNsdWRpbmcgQXBleCBjbGFzc2VzIGFuZCB0cmlnZ2VycyxcbiAgICogY3VzdG9tIG9iamVjdHMsIGN1c3RvbSBmaWVsZHMgb24gc3RhbmRhcmQgb2JqZWN0cywgdGFiIHNldHMgdGhhdCBkZWZpbmUgYW4gYXBwLFxuICAgKiBhbmQgbWFueSBvdGhlciBjb21wb25lbnRzLlxuICAgKi9cbiAgZGVzY3JpYmUoYXNPZlZlcnNpb24/OiBzdHJpbmcpOiBQcm9taXNlPERlc2NyaWJlTWV0YWRhdGFSZXN1bHQ+IHtcbiAgICBpZiAoIWFzT2ZWZXJzaW9uKSB7XG4gICAgICBhc09mVmVyc2lvbiA9IHRoaXMuX2Nvbm4udmVyc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ludm9rZShcbiAgICAgICdkZXNjcmliZU1ldGFkYXRhJyxcbiAgICAgIHsgYXNPZlZlcnNpb24gfSxcbiAgICAgIEFwaVNjaGVtYXMuRGVzY3JpYmVNZXRhZGF0YVJlc3VsdCxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBwcm9wZXJ0eSBpbmZvcm1hdGlvbiBhYm91dCBtZXRhZGF0YSBjb21wb25lbnRzIGluIHlvdXIgb3JnYW5pemF0aW9uXG4gICAqL1xuICBsaXN0KFxuICAgIHF1ZXJpZXM6IExpc3RNZXRhZGF0YVF1ZXJ5IHwgTGlzdE1ldGFkYXRhUXVlcnlbXSxcbiAgICBhc09mVmVyc2lvbj86IHN0cmluZyxcbiAgKTogUHJvbWlzZTxGaWxlUHJvcGVydGllc1tdPiB7XG4gICAgaWYgKCFhc09mVmVyc2lvbikge1xuICAgICAgYXNPZlZlcnNpb24gPSB0aGlzLl9jb25uLnZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pbnZva2UoJ2xpc3RNZXRhZGF0YScsIHsgcXVlcmllcywgYXNPZlZlcnNpb24gfSwgW1xuICAgICAgQXBpU2NoZW1hcy5GaWxlUHJvcGVydGllcyxcbiAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIHN0YXR1cyBvZiBhc3luY2hyb25vdXMgbWV0YWRhdGEgY2FsbHNcbiAgICovXG4gIGNoZWNrU3RhdHVzKGFzeW5jUHJvY2Vzc0lkOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXMgPSB0aGlzLl9pbnZva2UoXG4gICAgICAnY2hlY2tTdGF0dXMnLFxuICAgICAgeyBhc3luY1Byb2Nlc3NJZCB9LFxuICAgICAgQXBpU2NoZW1hcy5Bc3luY1Jlc3VsdCxcbiAgICApO1xuICAgIHJldHVybiBuZXcgQXN5bmNSZXN1bHRMb2NhdG9yKHRoaXMsIHJlcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIFhNTCBmaWxlIHJlcHJlc2VudGF0aW9ucyBvZiBjb21wb25lbnRzIGluIGFuIG9yZ2FuaXphdGlvblxuICAgKi9cbiAgcmV0cmlldmUocmVxdWVzdDogUGFydGlhbDxSZXRyaWV2ZVJlcXVlc3Q+KSB7XG4gICAgY29uc3QgcmVzID0gdGhpcy5faW52b2tlKFxuICAgICAgJ3JldHJpZXZlJyxcbiAgICAgIHsgcmVxdWVzdCB9LFxuICAgICAgQXBpU2NoZW1hcy5SZXRyaWV2ZVJlc3VsdCxcbiAgICApO1xuICAgIHJldHVybiBuZXcgUmV0cmlldmVSZXN1bHRMb2NhdG9yKHRoaXMsIHJlcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHRoZSBzdGF0dXMgb2YgZGVjbGFyYXRpdmUgbWV0YWRhdGEgY2FsbCByZXRyaWV2ZSgpIGFuZCByZXR1cm5zIHRoZSB6aXAgZmlsZSBjb250ZW50c1xuICAgKi9cbiAgY2hlY2tSZXRyaWV2ZVN0YXR1cyhhc3luY1Byb2Nlc3NJZDogc3RyaW5nKTogUHJvbWlzZTxSZXRyaWV2ZVJlc3VsdD4ge1xuICAgIHJldHVybiB0aGlzLl9pbnZva2UoXG4gICAgICAnY2hlY2tSZXRyaWV2ZVN0YXR1cycsXG4gICAgICB7IGFzeW5jUHJvY2Vzc0lkIH0sXG4gICAgICBBcGlTY2hlbWFzLlJldHJpZXZlUmVzdWx0LFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGVwbG95IGNvbXBvbmVudHMgaW50byBhbiBvcmdhbml6YXRpb24gdXNpbmcgemlwcGVkIGZpbGUgcmVwcmVzZW50YXRpb25zXG4gICAqIHVzaW5nIHRoZSBSRVNUIE1ldGFkYXRhIEFQSSBpbnN0ZWFkIG9mIFNPQVBcbiAgICovXG4gIGRlcGxveVJlc3QoXG4gICAgemlwSW5wdXQ6IEJ1ZmZlcixcbiAgICBvcHRpb25zOiBQYXJ0aWFsPERlcGxveU9wdGlvbnM+ID0ge30sXG4gICk6IERlcGxveVJlc3VsdExvY2F0b3I8Uz4ge1xuICAgIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBmb3JtLmFwcGVuZCgnZmlsZScsIHppcElucHV0LCB7XG4gICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL3ppcCcsXG4gICAgICBmaWxlbmFtZTogJ3BhY2thZ2UueG1sJyxcbiAgICB9KTtcblxuICAgIC8vIEFkZCB0aGUgZGVwbG95IG9wdGlvbnNcbiAgICBmb3JtLmFwcGVuZCgnZW50aXR5X2NvbnRlbnQnLCBKU09OLnN0cmluZ2lmeSh7IGRlcGxveU9wdGlvbnM6IG9wdGlvbnMgfSksIHtcbiAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgfSk7XG5cbiAgICBjb25zdCByZXF1ZXN0OiBIdHRwUmVxdWVzdCA9IHtcbiAgICAgIHVybDogJy9tZXRhZGF0YS9kZXBsb3lSZXF1ZXN0JyxcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczogeyAuLi5mb3JtLmdldEhlYWRlcnMoKSB9LFxuICAgICAgYm9keTogZm9ybS5nZXRCdWZmZXIoKSxcbiAgICB9O1xuICAgIGNvbnN0IHJlcyA9IHRoaXMuX2Nvbm4ucmVxdWVzdDxBc3luY1Jlc3VsdD4ocmVxdWVzdCk7XG5cbiAgICByZXR1cm4gbmV3IERlcGxveVJlc3VsdExvY2F0b3IodGhpcywgcmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXBsb3kgY29tcG9uZW50cyBpbnRvIGFuIG9yZ2FuaXphdGlvbiB1c2luZyB6aXBwZWQgZmlsZSByZXByZXNlbnRhdGlvbnNcbiAgICovXG4gIGRlcGxveShcbiAgICB6aXBJbnB1dDogUmVhZGFibGUgfCBCdWZmZXIgfCBzdHJpbmcsXG4gICAgb3B0aW9uczogUGFydGlhbDxEZXBsb3lPcHRpb25zPiA9IHt9LFxuICApOiBEZXBsb3lSZXN1bHRMb2NhdG9yPFM+IHtcbiAgICBjb25zdCByZXMgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgemlwQ29udGVudEI2NCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGlzT2JqZWN0KHppcElucHV0KSAmJlxuICAgICAgICAgICdwaXBlJyBpbiB6aXBJbnB1dCAmJlxuICAgICAgICAgIHR5cGVvZiB6aXBJbnB1dC5waXBlID09PSAnZnVuY3Rpb24nXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGJ1ZnM6IEJ1ZmZlcltdID0gW107XG4gICAgICAgICAgemlwSW5wdXQub24oJ2RhdGEnLCAoZCkgPT4gYnVmcy5wdXNoKGQpKTtcbiAgICAgICAgICB6aXBJbnB1dC5vbignZXJyb3InLCByZWplY3QpO1xuICAgICAgICAgIHppcElucHV0Lm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKEJ1ZmZlci5jb25jYXQoYnVmcykudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyB6aXBJbnB1dC5yZXN1bWUoKTtcbiAgICAgICAgfSBlbHNlIGlmICh6aXBJbnB1dCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgIHJlc29sdmUoemlwSW5wdXQudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbiAgICAgICAgfSBlbHNlIGlmICh6aXBJbnB1dCBpbnN0YW5jZW9mIFN0cmluZyB8fCB0eXBlb2YgemlwSW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmVzb2x2ZSh6aXBJbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgJ1VuZXhwZWN0ZWQgemlwSW5wdXQgdHlwZSc7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcy5faW52b2tlKFxuICAgICAgICAnZGVwbG95JyxcbiAgICAgICAge1xuICAgICAgICAgIFppcEZpbGU6IHppcENvbnRlbnRCNjQsXG4gICAgICAgICAgRGVwbG95T3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgfSxcbiAgICAgICAgQXBpU2NoZW1hcy5EZXBsb3lSZXN1bHQsXG4gICAgICApO1xuICAgIH0pKCk7XG5cbiAgICByZXR1cm4gbmV3IERlcGxveVJlc3VsdExvY2F0b3IodGhpcywgcmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIHN0YXR1cyBvZiBkZWNsYXJhdGl2ZSBtZXRhZGF0YSBjYWxsIGRlcGxveSgpXG4gICAqL1xuICBjaGVja0RlcGxveVN0YXR1cyhcbiAgICBhc3luY1Byb2Nlc3NJZDogc3RyaW5nLFxuICAgIGluY2x1ZGVEZXRhaWxzOiBib29sZWFuID0gZmFsc2UsXG4gICk6IFByb21pc2U8RGVwbG95UmVzdWx0PiB7XG4gICAgcmV0dXJuIHRoaXMuX2ludm9rZShcbiAgICAgICdjaGVja0RlcGxveVN0YXR1cycsXG4gICAgICB7XG4gICAgICAgIGFzeW5jUHJvY2Vzc0lkLFxuICAgICAgICBpbmNsdWRlRGV0YWlscyxcbiAgICAgIH0sXG4gICAgICBBcGlTY2hlbWFzLkRlcGxveVJlc3VsdCxcbiAgICApO1xuICB9XG59XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vKipcbiAqIFRoZSBsb2NhdG9yIGNsYXNzIGZvciBNZXRhZGF0YSBBUEkgYXN5bmNocm9ub3VzIGNhbGwgcmVzdWx0XG4gKi9cbmV4cG9ydCBjbGFzcyBBc3luY1Jlc3VsdExvY2F0b3I8XG4gIFMgZXh0ZW5kcyBTY2hlbWEsXG4gIFIgZXh0ZW5kcyB7fSA9IEFzeW5jUmVzdWx0XG4+IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgX21ldGE6IE1ldGFkYXRhQXBpPFM+O1xuICBfcHJvbWlzZTogUHJvbWlzZTxBc3luY1Jlc3VsdD47XG4gIF9pZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKlxuICAgKi9cbiAgY29uc3RydWN0b3IobWV0YTogTWV0YWRhdGFBcGk8Uz4sIHByb21pc2U6IFByb21pc2U8QXN5bmNSZXN1bHQ+KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9tZXRhID0gbWV0YTtcbiAgICB0aGlzLl9wcm9taXNlID0gcHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9taXNlL0ErIGludGVyZmFjZVxuICAgKiBodHRwOi8vcHJvbWlzZXMtYXBsdXMuZ2l0aHViLmlvL3Byb21pc2VzLXNwZWMvXG4gICAqXG4gICAqIEBtZXRob2QgTWV0YWRhdGF+QXN5bmNSZXN1bHRMb2NhdG9yI3RoZW5cbiAgICovXG4gIHRoZW48VSwgVj4oXG4gICAgb25SZXNvbHZlPzogKChyZXN1bHQ6IEFzeW5jUmVzdWx0KSA9PiBVIHwgUHJvbWlzZTxVPikgfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgIG9uUmVqZWN0PzogKChlcnI6IEVycm9yKSA9PiBWIHwgUHJvbWlzZTxWPikgfCBudWxsIHwgdW5kZWZpbmVkLFxuICApOiBQcm9taXNlPFUgfCBWPiB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2UudGhlbihvblJlc29sdmUsIG9uUmVqZWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0aGUgc3RhdHVzIG9mIGFzeW5jIHJlcXVlc3RcbiAgICovXG4gIGFzeW5jIGNoZWNrKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX3Byb21pc2U7XG4gICAgdGhpcy5faWQgPSByZXN1bHQuaWQ7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX21ldGEuY2hlY2tTdGF0dXMocmVzdWx0LmlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb2xsaW5nIHVudGlsIGFzeW5jIGNhbGwgc3RhdHVzIGJlY29tZXMgY29tcGxldGUgb3IgZXJyb3JcbiAgICovXG4gIHBvbGwoaW50ZXJ2YWw6IG51bWJlciwgdGltZW91dDogbnVtYmVyKSB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgY29uc3QgcG9sbCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICBpZiAoc3RhcnRUaW1lICsgdGltZW91dCA8IG5vdykge1xuICAgICAgICAgIGxldCBlcnJNc2cgPSAnUG9sbGluZyB0aW1lIG91dC4nO1xuICAgICAgICAgIGlmICh0aGlzLl9pZCkge1xuICAgICAgICAgICAgZXJyTXNnICs9ICcgUHJvY2VzcyBJZCA9ICcgKyB0aGlzLl9pZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihlcnJNc2cpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jaGVjaygpO1xuICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2NvbXBsZXRlJywgcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgcmVzdWx0KTtcbiAgICAgICAgICBzZXRUaW1lb3V0KHBvbGwsIGludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgfVxuICAgIH07XG4gICAgc2V0VGltZW91dChwb2xsLCBpbnRlcnZhbCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgYW5kIHdhaXQgdW50aWwgdGhlIGFzeW5jIHJlcXVlc3RzIGJlY29tZSBpbiBjb21wbGV0ZWQgc3RhdHVzXG4gICAqL1xuICBjb21wbGV0ZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8Uj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5vbignY29tcGxldGUnLCByZXNvbHZlKTtcbiAgICAgIHRoaXMub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgIHRoaXMucG9sbCh0aGlzLl9tZXRhLnBvbGxJbnRlcnZhbCwgdGhpcy5fbWV0YS5wb2xsVGltZW91dCk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKipcbiAqIFRoZSBsb2NhdG9yIGNsYXNzIHRvIHRyYWNrIHJldHJlaXZlKCkgTWV0YWRhdGEgQVBJIGNhbGwgcmVzdWx0XG4gKi9cbmV4cG9ydCBjbGFzcyBSZXRyaWV2ZVJlc3VsdExvY2F0b3I8UyBleHRlbmRzIFNjaGVtYT4gZXh0ZW5kcyBBc3luY1Jlc3VsdExvY2F0b3I8XG4gIFMsXG4gIFJldHJpZXZlUmVzdWx0XG4+IHtcbiAgLyoqXG4gICAqIENoZWNrIGFuZCB3YWl0IHVudGlsIHRoZSBhc3luYyByZXF1ZXN0IGJlY29tZXMgaW4gY29tcGxldGVkIHN0YXR1cyxcbiAgICogYW5kIHJldHJpZXZlIHRoZSByZXN1bHQgZGF0YS5cbiAgICovXG4gIGFzeW5jIGNvbXBsZXRlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN1cGVyLmNvbXBsZXRlKCk7XG4gICAgcmV0dXJuIHRoaXMuX21ldGEuY2hlY2tSZXRyaWV2ZVN0YXR1cyhyZXN1bHQuaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgcmV0cmlldmVkIHJlc3VsdCB0byBOb2RlLmpzIHJlYWRhYmxlIHN0cmVhbVxuICAgKi9cbiAgc3RyZWFtKCkge1xuICAgIGNvbnN0IHJlc3VsdFN0cmVhbSA9IG5ldyBSZWFkYWJsZSgpO1xuICAgIGxldCByZWFkaW5nID0gZmFsc2U7XG4gICAgcmVzdWx0U3RyZWFtLl9yZWFkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHJlYWRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVhZGluZyA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNvbXBsZXRlKCk7XG4gICAgICAgIHJlc3VsdFN0cmVhbS5wdXNoKEJ1ZmZlci5mcm9tKHJlc3VsdC56aXBGaWxlLCAnYmFzZTY0JykpO1xuICAgICAgICByZXN1bHRTdHJlYW0ucHVzaChudWxsKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVzdWx0U3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0U3RyZWFtO1xuICB9XG59XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLyoqXG4gKiBUaGUgbG9jYXRvciBjbGFzcyB0byB0cmFjayBkZXBsb3koKSBNZXRhZGF0YSBBUEkgY2FsbCByZXN1bHRcbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAY2xhc3MgTWV0YWRhdGF+RGVwbG95UmVzdWx0TG9jYXRvclxuICogQGV4dGVuZHMgTWV0YWRhdGF+QXN5bmNSZXN1bHRMb2NhdG9yXG4gKiBAcGFyYW0ge01ldGFkYXRhfSBtZXRhIC0gTWV0YWRhdGEgQVBJIG9iamVjdFxuICogQHBhcmFtIHtQcm9taXNlLjxNZXRhZGF0YX5Bc3luY1Jlc3VsdD59IHJlc3VsdCAtIFByb21pc2Ugb2JqZWN0IGZvciBhc3luYyByZXN1bHQgb2YgZGVwbG95KCkgY2FsbFxuICovXG5leHBvcnQgY2xhc3MgRGVwbG95UmVzdWx0TG9jYXRvcjxTIGV4dGVuZHMgU2NoZW1hPiBleHRlbmRzIEFzeW5jUmVzdWx0TG9jYXRvcjxcbiAgUyxcbiAgRGVwbG95UmVzdWx0XG4+IHtcbiAgLyoqXG4gICAqIENoZWNrIGFuZCB3YWl0IHVudGlsIHRoZSBhc3luYyByZXF1ZXN0IGJlY29tZXMgaW4gY29tcGxldGVkIHN0YXR1cyxcbiAgICogYW5kIHJldHJpZXZlIHRoZSByZXN1bHQgZGF0YS5cbiAgICovXG4gIGFzeW5jIGNvbXBsZXRlKGluY2x1ZGVEZXRhaWxzPzogYm9vbGVhbikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN1cGVyLmNvbXBsZXRlKCk7XG4gICAgcmV0dXJuIHRoaXMuX21ldGEuY2hlY2tEZXBsb3lTdGF0dXMocmVzdWx0LmlkLCBpbmNsdWRlRGV0YWlscyk7XG4gIH1cbn1cblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKlxuICogUmVnaXN0ZXIgaG9vayBpbiBjb25uZWN0aW9uIGluc3RhbnRpYXRpb24gZm9yIGR5bmFtaWNhbGx5IGFkZGluZyB0aGlzIEFQSSBtb2R1bGUgZmVhdHVyZXNcbiAqL1xucmVnaXN0ZXJNb2R1bGUoJ21ldGFkYXRhJywgKGNvbm4pID0+IG5ldyBNZXRhZGF0YUFwaShjb25uKSk7XG5cbmV4cG9ydCBkZWZhdWx0IE1ldGFkYXRhQXBpO1xuIl19