"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrgCreateCommand = void 0;
// This is the legacy converted command file. Ignoring code-coverage since this is generated.
// THIS SHOULD BE REMOVED WHEN CONVERTED TO EXTEND SfdxCommand
/* istanbul ignore file */
const fs = require("fs");
const command_1 = require("@salesforce/command");
const kit_1 = require("@salesforce/kit");
const _ = require("lodash");
const core_1 = require("@salesforce/core");
const envTypes = require("../../../lib/org/envTypes");
const consts = require("../../../lib/core/constants");
const sandboxOrg_1 = require("../../../lib/org/sandbox/sandboxOrg");
const sandboxOrgApi_1 = require("../../../lib/org/sandbox/sandboxOrgApi");
const sandboxProgressReporter_1 = require("../../../lib/org/sandbox/sandboxProgressReporter");
const SFDXCommonMessages = require("../../../lib/messages");
const orgTypes_1 = require("../../../lib/orgTypes");
const sandboxConstants_1 = require("../../../lib/org/sandbox/sandboxConstants");
const scratchOrgCreateCommand_1 = require("../../../lib/org/scratchOrgCreateCommand");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('salesforce-alm', 'org_create');
const sfdxCommonMessages = SFDXCommonMessages();
class OrgCreateCommand extends command_1.SfdxCommand {
    constructor() {
        super(...arguments);
        this.lifecycleEventNames = ['postorgcreate'];
    }
    async readJsonDefFile() {
        // the -f option
        if (this.flags.definitionfile) {
            this.logger.debug('Reading JSON DefFile %s ', this.flags.definitionfile);
            return JSON.parse(await fs.promises.readFile(this.flags.definitionfile, 'utf8'));
        }
        return;
    }
    async run() {
        const alias = (await core_1.StateAggregator.getInstance()).aliases;
        this.logger.debug('Create started with args %s ', this.flags);
        if (this.flags.type === orgTypes_1.OrgTypes.Sandbox) {
            if (this.flags.retry !== 0) {
                throw messages.createError('RetryIsNotValidForSandboxes');
            }
            // the -f definitionFile option, both sandbox and scratch org use the flag but scratch org
            // will process it separately in the legacy command invocation
            const sandboxDefFileContents = await this.readJsonDefFile();
            //
            // =====================specific to Sandbox org creation ===========
            //
            if (_.isNil(this.org)) {
                throw messages.createError('RequiresUsernameError');
            }
            const sandboxOrg = sandboxOrg_1.SandboxOrg.getInstance(this.org, this.flags.wait, this.logger, this.flags.clientid);
            if (this.flags.clientid) {
                this.ux.warn(messages.getMessage('commandClientIdNotSupported', [this.flags.clientid]));
            }
            // Keep all console output in the command
            sandboxOrg.on(sandboxConstants_1.SandboxEventNames.EVENT_ASYNCRESULT, (results) => {
                this.ux.log(messages.getMessage('commandSandboxSuccess', [
                    results.sandboxProcessObj.Id,
                    results.sandboxProcessObj.SandboxName,
                ]));
            });
            sandboxOrg.on(sandboxConstants_1.SandboxEventNames.EVENT_STATUS, (results) => {
                sandboxProgressReporter_1.SandboxProgressReporter.logSandboxProgress(this.ux, results.sandboxProcessObj, results.interval, results.retries, results.waitingOnAuth);
            });
            sandboxOrg.on(sandboxConstants_1.SandboxEventNames.EVENT_RESULT, (results) => {
                sandboxProgressReporter_1.SandboxProgressReporter.logSandboxProcessResult(this.ux, results.sandboxProcessObj, results.sandboxRes);
                if (results.sandboxRes && results.sandboxRes.authUserName) {
                    if (this.flags.setalias) {
                        const result = alias.set(this.flags.setalias, results.sandboxRes.authUserName);
                        this.logger.debug('Set Alias: %s result: %s', this.flags.setalias, result);
                    }
                    if (this.flags.setdefaultusername) {
                        const globalConfig = this.configAggregator.getGlobalConfig();
                        globalConfig.set(core_1.SfdxPropertyKeys.DEFAULT_USERNAME, results.sandboxRes.authUserName);
                        globalConfig
                            .write()
                            .then((result) => this.logger.debug('Set defaultUsername: %s result: %s', this.flags.setdefaultusername, result));
                    }
                }
            });
            this.logger.debug('Create Varargs: %s ', this.varargs);
            const sandboxReq = new sandboxOrgApi_1.SandboxRequest();
            // definitionjson and varargs override file input
            Object.assign(sandboxReq, sandboxDefFileContents, this.varargs);
            this.logger.debug('Calling create with SandboxRequest: %s ', sandboxReq);
            return await sandboxOrg.createSandbox(sandboxReq);
        }
        else {
            //
            // =====================specific to Scratch org creation ===========
            //
            this.logger.debug('OK, will do scratch org creation');
            if (!this.hubOrg) {
                throw messages.createError('RequiresDevhubUsernameError');
            }
            // this.logger.trace(this.flags);
            // this.logger.trace(this.varargs);
            // Ensure we have an org config input source.
            if (!this.flags.definitionjson && !this.flags.definitionfile && Object.keys(this.varargs).length === 0) {
                this.logger.error(' a definition or varargs is required');
                throw new core_1.SfError(messages.getMessage('cliForceCreateNoConfig'));
            }
            this.logger.debug('validation complete');
            let secret;
            if (this.flags.clientid) {
                // If the user supplied a specific client ID, we have no way of knowing if it's
                // a certificate-based Connected App or not. Therefore, we have to assume that
                // we'll need the client secret, so prompt the user for it.
                secret = await this.ux.prompt(sfdxCommonMessages.getMessage('stdin', [], 'auth_weblogin'), {
                    type: 'mask',
                });
            }
            // sign up and do output
            const createCommand = new scratchOrgCreateCommand_1.default(this.hubOrg, this.flags, this.varargs, this.configAggregator);
            const result = await createCommand.execute(secret);
            this.ux.log(messages.getMessage('commandSuccess', [result.orgId, result.username]));
            return result;
        }
    }
}
exports.OrgCreateCommand = OrgCreateCommand;
OrgCreateCommand.help = messages.getMessage('commandHelp');
/*
 * TODO: When SfdxCommand change the messages for description to include both the description and the help messages
 *       we have to remove the help from description.
 */
OrgCreateCommand.description = messages.getMessage('commandDescription') + '\n\n' + OrgCreateCommand.help;
OrgCreateCommand.showProgress = true;
OrgCreateCommand.supportsDevhubUsername = true;
OrgCreateCommand.supportsUsername = true;
OrgCreateCommand.varargs = true;
OrgCreateCommand.orgType = consts.DEFAULT_DEV_HUB_USERNAME;
OrgCreateCommand.flagsConfig = {
    type: command_1.flags.enum({
        char: 't',
        description: messages.getMessage('typeFlagDescription'),
        options: orgTypes_1.creatableOrgTypes(),
        default: orgTypes_1.OrgTypes.Scratch,
    }),
    definitionfile: command_1.flags.filepath({
        char: 'f',
        description: messages.getMessage('definitionfileFlagDescription'),
    }),
    definitionjson: command_1.flags.string({
        char: 'j',
        description: messages.getMessage('definitionjsonFlagDescription'),
        hidden: true,
    }),
    nonamespace: command_1.flags.boolean({
        char: 'n',
        description: messages.getMessage('nonamespaceFlagDescription'),
    }),
    noancestors: command_1.flags.boolean({
        char: 'c',
        description: messages.getMessage('noancestorsFlagDescription'),
    }),
    clientid: command_1.flags.string({
        char: 'i',
        description: messages.getMessage('clientidFlagDescription'),
    }),
    setdefaultusername: command_1.flags.boolean({
        char: 's',
        description: messages.getMessage('setdefaultusernameFlagDescription'),
    }),
    setalias: command_1.flags.string({
        char: 'a',
        description: messages.getMessage('setaliasFlagDescription'),
    }),
    env: command_1.flags.enum({
        char: 'e',
        description: messages.getMessage('envFlagDescription', [envTypes.creatableTypes().toString()]),
        hidden: true,
        options: envTypes.creatableTypes(),
        default: envTypes.sandbox,
    }),
    wait: command_1.flags.minutes({
        char: 'w',
        description: sfdxCommonMessages.getMessage('streamingWait', []),
        min: consts.MIN_STREAM_TIMEOUT_MINUTES,
        default: kit_1.Duration.minutes(consts.DEFAULT_STREAM_TIMEOUT_MINUTES),
    }),
    durationdays: command_1.flags.integer({
        char: 'd',
        description: messages.getMessage('durationdaysFlagDescription', []),
        min: 1,
        max: 30,
    }),
    retry: command_1.flags.number({
        hidden: true,
        default: 0,
        max: 10,
        description: messages.getMessage('retryFlagDescription', []),
    }),
};

//# sourceMappingURL=create.js.map
