"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceTrackingResetCommand = void 0;
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const source_tracking_1 = require("@salesforce/source-tracking");
const chalk_1 = require("chalk");
const remoteSourceTrackingService_1 = require("../../../../../lib/source/remoteSourceTrackingService");
const sourcePathStatusManager_1 = require("../../../../../lib/source/sourcePathStatusManager");
const workspaceFileState_1 = require("../../../../../lib/source/workspaceFileState");
const Org = require('../../../../../lib/core/scratchOrgApi');
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('salesforce-alm', 'source_tracking');
class SourceTrackingResetCommand extends command_1.SfdxCommand {
    async run() {
        source_tracking_1.throwIfInvalid({
            // org: await CoreOrg.create({ aliasOrUsername: this.org.getUsername() }),
            // @ts-ignore TODO: come back once STL is using SDR6
            org: this.org,
            projectPath: this.project.getPath(),
            toValidate: 'toolbelt',
            command: 'force:source:legacy:tracking:reset',
        });
        if (!this.flags.noprompt) {
            const answer = await this.ux.prompt(chalk_1.default.dim(messages.getMessage('promptMessage')));
            if (answer.toLowerCase() !== 'y') {
                // Nothing synced because it was canceled.
                return {
                    sourceMembersSynced: 0,
                    localPathsSynced: 0,
                };
            }
        }
        // TODO Remove legacy org from source path status manager and workspace.
        const legacyOrg = new Org();
        const username = this.org.getUsername();
        legacyOrg.setName(username);
        // Retrieve and update server members locally
        const revision = await remoteSourceTrackingService_1.RemoteSourceTrackingService.getInstance({ username });
        const desiredRevision = this.flags.revision;
        await revision.reset(desiredRevision);
        // Reset sourcePathInfos locally
        const manager = await sourcePathStatusManager_1.SourcePathStatusManager.create({ org: legacyOrg });
        const workspace = manager.workspace;
        await workspace.walkDirectories(workspace.trackedPackages);
        const workspaceElements = workspace.entries();
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        workspaceElements.forEach(([_, pathInfo]) => (pathInfo.state = workspaceFileState_1.WorkspaceFileState.UNCHANGED));
        await workspace.write();
        this.ux.log(`Reset local tracking files${desiredRevision ? ` to revision ${desiredRevision}` : ''}.`);
        return {
            sourceMembersSynced: revision.getTrackedElements().length,
            localPathsSynced: workspaceElements.length,
        };
    }
}
exports.SourceTrackingResetCommand = SourceTrackingResetCommand;
SourceTrackingResetCommand.deprecated = {
    version: 55.0,
    to: 'force:source:tracking:reset',
};
SourceTrackingResetCommand.description = messages.getMessage('resetDescription');
SourceTrackingResetCommand.requiresProject = true;
SourceTrackingResetCommand.requiresUsername = true;
SourceTrackingResetCommand.flagsConfig = {
    revision: command_1.flags.integer({
        char: 'r',
        description: messages.getMessage('revisionDescription'),
        required: false,
        min: 0,
    }),
    noprompt: command_1.flags.boolean({
        char: 'p',
        description: messages.getMessage('nopromptDescription'),
        required: false,
    }),
};

//# sourceMappingURL=reset.js.map
