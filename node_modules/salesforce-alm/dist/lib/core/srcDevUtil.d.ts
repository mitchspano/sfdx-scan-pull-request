import { AnyJson } from '@salesforce/ts-types';
import * as _ from 'lodash';
/**
 *
 * @param data JSON data as a string to parse
 * @param jsonPath path to the json file used for error reporting
 * @param throwOnEmpty throw a JsonParseError when the content is empty
 */
declare function parseJSON(data: any, jsonPath: any, throwOnEmpty?: boolean): AnyJson;
declare const self: {
    /**
     * Read a file and convert it to JSON
     *
     * @param {string} jsonPath The path of the file
     * @return promise The contents of the file as a JSON object
     */
    readJSON(jsonPath: any, throwOnEmpty?: boolean): Promise<AnyJson>;
    parseJSON: typeof parseJSON;
    /**
     * Helper for handling errors resulting from reading and then parsing a JSON file
     *
     * @param e - the error
     * @param filePath - the filePath to the JSON file being read
     */
    processReadAndParseJsonFileError(e: any, filePath: any): any;
    /**
     * simple helper for creating an error with a name.
     *
     * @param message - the message for the error
     * @param name - the name of the error. preferably containing no spaces, starting with a capital letter, and camel-case.
     * @returns {Error}
     */
    getError(message: any, name: any): Error;
    /**
     * function that normalizes cli args between yargs and heroku toolbelt
     *
     * @param context - the cli context
     * @returns {object}
     */
    fixCliContext(context: any): any;
    /**
     * Simple helper method to determine that the path is a file (all SFDX files have an extension)
     *
     * @param localPath
     * @returns {boolean}
     */
    containsFileExt(localPath: any): boolean;
    /**
     * Simple helper method to determine if a fs path exists.
     *
     * @param localPath The path to check. Either a file or directory.
     * @returns {boolean} true if the path exists false otherwise.
     */
    pathExistsSync(localPath: any): any;
    /**
     * Ensure that a directory exists, creating as necessary
     *
     * @param localPath The path to the directory
     */
    ensureDirectoryExistsSync(localPath: any): void;
    /**
     * If a file exists, delete it
     *
     * @param localPath - Path of the file to delete.
     */
    deleteIfExistsSync(localPath: any): void;
    /**
     * If a directory exists, force remove it and anything inside
     *
     * @param localPath - Path of the directory to delete.
     */
    deleteDirIfExistsSync(localPath: any): void;
    /**
     * If a directory exists, return all the items inside of it
     *
     * @param localPath - Path of the directory
     * @param deep{boolean} - Whether to include files in all subdirectories recursively
     * @param excludeDirs{boolean} - Whether to exclude directories in the returned list
     * @returns {Array} - files in directory
     */
    getDirectoryItems(localPath: string, deep?: boolean, excludeDirs?: boolean): any[];
    /**
     * Helper method for getting config file data from $HOME/.sfdx.
     *
     * @param {string} jsonConfigFileName The name of the config file stored in .sfdx.
     * @param {object} defaultIfNotExist A value returned if the files doesn't exist. It not set, an error would be thrown.
     * @returns {BBPromise<object>} The resolved content as a json object.
     */
    getGlobalConfig(jsonConfigFileName: any, defaultIfNotExist?: any): any;
    /**
     * Synchronous version of getAppConfig.
     *
     * @deprecated
     */
    getGlobalConfigSync(jsonConfigFileName: any): any;
    /**
     * Helper method for saving config files to .sfdx.
     *
     * @param config The config.json configuration object.
     * @param jsonConfigFileName The name for the config file to store in .sfdx.
     * @param jsonConfigObject The json object to store in .sfdx/[jsonConfigFileName]
     * @returns BBPromise
     */
    saveGlobalConfig(jsonConfigFileName: any, jsonConfigObject: any): any;
    /**
     * Get the name of the directory containing workspace state
     *
     * @returns {string}
     */
    getWorkspaceStateFolderName(): string;
    getConfigFileName(): string;
    /**
     * Get the full path to the file storing the workspace org config information
     *
     * @param wsPath - The root path of the workspace
     * @returns {*}
     */
    getWorkspaceOrgConfigPath(wsPath: any): string;
    /**
     * Helper function that returns true if a value is an integer.
     *
     * @param value the value to compare
     * @returns {boolean} true if value is an integer. this is not a mathematical definition. that is -0 returns true.
     * this is in intended to be followed up with parseInt.
     */
    isInt(value: any): boolean;
    /**
     * Execute each function in the array sequentially.
     *
     * @param promiseFactories  An array of functions to be executed that return BBPromises.
     * @returns {BBPromise.<T>}
     */
    sequentialExecute(promiseFactories: any): any;
    /**
     * Given a request object or string url a request object is returned with the additional http headers needed by force.com
     *
     * @param {(string|object)} request - A string url or javascript object.
     * @param options - {object} that may contain headers to add to request
     * @returns {object} a request object containing {method, url, headers}
     */
    setSfdxRequestHeaders(request: any, options?: any): any;
    getSfdxRequestHeaders(): {
        'content-type': string;
        'user-agent': string;
    };
    getSfdxCLIClientId(): string;
    isVerbose(): boolean;
    /**
     * Zips directory to given zipfile.
     *
     * https://github.com/archiverjs/node-archiver
     *
     * @param dir to zip
     * @param zipfile
     * @param options
     */
    zipDir(dir: any, zipfile: any, options?: {}): any;
    setZipDirPath(path: string): void;
    getZipDirPath(): string;
    getElapsedTime(timer: any): string;
    /**
     *  Uses Lodash _.mapKeys to convert object keys to another format using the specified conversion function.
     *
     *  E.g., to deep convert all object keys to camelCase:  mapKeys(myObj, _.camelCase, true)
     *        to shallow convert object keys to lower case:  mapKeys(myObj, _.toLower)
     *
     *  NOTE: This mutates the object passed in for conversion.
     *
     *  @param obj - {Object} The object to convert the keys
     *  @param converterFn - {Function} The function that converts the object key
     *  @param deep - {boolean} Whether to do a deep object key conversion
     *  @return {Object} - the object with the converted keys
     */
    mapKeys(obj: any, converterFn: any, deep?: any): _.Dictionary<any>;
    toLowerCaseKeys(obj: any, deep?: any): any;
    /**
     * Helper to make a nodejs base64 encoded string compatible with rfc4648 alternative encoding for urls.
     *
     * @param {string} base64Encoded - a nodejs base64 encoded string
     * @returns {string} returns the string escaped.
     */
    base64UrlEscape(base64Encoded?: any): string;
    /**
     * Helper that will un-escape a base64 url encoded string.
     *
     * @param {string} base64EncodedAndEscaped - the based 64 escaped and encoded string.
     * @returns {string} returns the string un-escaped.
     */
    base64UrlUnEscape(base64EncodedAndEscaped: any): string;
    getContentHash(contents: any): string;
    /**
     * Logs the collection of unsupported mime types to the server
     *
     * @param unsupportedMimeTypes
     * @param _logger
     * @param force
     */
    logUnsupportedMimeTypeError(unsupportedMimeTypes: any, _logger: any, force: any): Promise<any>;
};
export = self;
