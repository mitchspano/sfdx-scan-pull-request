"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScratchOrgFeatureDeprecation = void 0;
/**
 * Certain Org Features require a translation or should be deprecated.
 * Encapsulates feature mappings and deprecated features.
 */
// P R I V A T E
// Third Party
const _ = require("lodash");
// Local
const Messages = require("../messages");
const messages = Messages();
const ts_types_1 = require("@salesforce/ts-types");
const FEATURE_TYPES = {
    // simpleFeatureMapping holds a set of direct replacement values for features.
    simpleFeatureMapping: {
        SALESWAVE: ['DEVELOPMENTWAVE'],
        SERVICEWAVE: ['DEVELOPMENTWAVE'],
    },
    quantifiedFeatureMapping: {},
    deprecatedFeatures: [
        'EXPANDEDSOURCETRACKING',
        'LISTCUSTOMSETTINGCREATION',
        'AppNavCapabilities',
        'EditInSubtab',
        'OldNewRecordFlowConsole',
        'OldNewRecordFlowStd',
        'DesktopLayoutStandardOff',
        'SplitViewOnStandardOff',
        'PopOutUtilities',
    ],
};
class ScratchOrgFeatureDeprecation {
    // Allow override for testing.
    constructor(options = FEATURE_TYPES) {
        this.featureTypes = options;
        this.featureTypes.deprecatedFeatures = this.featureTypes.deprecatedFeatures.map((v) => _.toUpper(v));
        // Make all of the keys in simpleFeatureMapping upper case.
        const sfm = {};
        Object.keys(this.featureTypes.simpleFeatureMapping).forEach((key) => {
            sfm[_.toUpper(key)] = this.featureTypes.simpleFeatureMapping[key];
        });
        this.featureTypes.simpleFeatureMapping = sfm;
    }
    /**
     * Gets list of feature warnings that should be logged
     *
     * @param features The requested features.
     * @returns List of string feature warnings.
     */
    getFeatureWarnings(features) {
        /* Get warning messages for deprecated features and feature mappings.*/
        const featureWarningMessages = [];
        if (features) {
            const requestedFeatures = _.toUpper(ts_types_1.isString(features) ? features : features.join(';'));
            /* If a public quantified feature is defined without a quantity, throw a warning.*/
            Object.keys(this.featureTypes.quantifiedFeatureMapping).forEach((key) => {
                if (new RegExp(`${key};|${key},|${key}$`, 'i').test(requestedFeatures)) {
                    featureWarningMessages.push(messages.getMessage('quantifiedFeatureWithoutQuantityWarning', [key, this.featureTypes.quantifiedFeatureMapping[key]], 'signup'));
                }
            });
            /* If a simply mapped feature is defined, log a warning.*/
            Object.keys(this.featureTypes.simpleFeatureMapping).forEach((key) => {
                if (new RegExp(`${key};|${key},|${key}$`, 'i').test(requestedFeatures)) {
                    featureWarningMessages.push(messages.getMessage('mappedFeatureWarning', [key, '[' + this.featureTypes.simpleFeatureMapping[key].map((v) => "'" + v + "'").join(',') + ']'], 'signup'));
                }
            });
            /* If a deprecated feature is identified as deprecated, throw a warning.*/
            this.featureTypes.deprecatedFeatures.forEach((deprecatedFeature) => {
                if (requestedFeatures.includes(deprecatedFeature)) {
                    featureWarningMessages.push(messages.getMessage('deprecatedFeatureWarning', deprecatedFeature, 'signup'));
                }
            });
        }
        return featureWarningMessages;
    }
    /**
     * Removes all deprecated features for the organization.
     *
     * @param features List of features to filter
     * @returns feature array with proper mapping.
     */
    filterDeprecatedFeatures(features) {
        const _features = [];
        features.forEach((feature) => {
            const _feature = _.toUpper(feature);
            /* If deprecated feature is specified, remove feature from the request. */
            if (this.featureTypes.deprecatedFeatures.includes(_feature)) {
                return;
            }
            else if (this.featureTypes.simpleFeatureMapping[_feature]) {
                /* If a simply mapped feature is specified, then perform the mapping.  */
                this.featureTypes.simpleFeatureMapping[_feature].forEach((f) => {
                    _features.push(f);
                });
            }
            else {
                /** Nothing special about this feature */
                _features.push(feature);
            }
        });
        return _features;
    }
}
exports.ScratchOrgFeatureDeprecation = ScratchOrgFeatureDeprecation;

//# sourceMappingURL=scratchOrgFeatureDeprecation.js.map
