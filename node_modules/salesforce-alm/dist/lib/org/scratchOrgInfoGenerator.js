"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateScratchOrgInfo = exports.getAncestorIds = void 0;
// Local
const core_1 = require("@salesforce/core");
const scratchOrgFeatureDeprecation_1 = require("./scratchOrgFeatureDeprecation");
const defaultConnectedAppInfo = require('../core/defaultConnectedApp');
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('salesforce-alm', 'org_create');
/**
 * Generates the package2AncestorIds scratch org property
 * Rewrite of similar code in pkgUtils, but without dependency on old toolbelt core
 *
 * @param scratchOrgInfo - the scratchOrgInfo passed in by the user
 * @param projectJson - SfProjectJson
 * @param hubOrg - the hub org, in case we need to do queries
 */
exports.getAncestorIds = async (scratchOrgInfo, projectJson, hubOrg) => {
    if (Object.prototype.hasOwnProperty.call(scratchOrgInfo, 'package2AncestorIds')) {
        throw new Error(messages.getMessage('errorpackage2AncestorIdsKeyNotSupported'));
    }
    const packagesWithAncestors = (await projectJson.getPackageDirectories())
        // check that the package has any ancestor types (id or version)
        .filter((packageDir) => packageDir.ancestorId || packageDir.ancestorVersion);
    if (packagesWithAncestors.length === 0) {
        return '';
    }
    const ancestorIds = await Promise.all(packagesWithAncestors.map(async (packageDir) => {
        var _a, _b, _c, _d;
        // ancestorID can be 05i, or 04t, alias; OR "ancestorVersion": "4.6.0.1" according to toolbelt code
        // according to docs, 05i is not ok: https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev2gp_config_file.htm
        const packageId = (_b = (_a = projectJson.get('packageAliases')) === null || _a === void 0 ? void 0 : _a[packageDir.package]) !== null && _b !== void 0 ? _b : packageDir.package;
        // Need to handle HIGHEST and NONE in ancestor(Version|Id). Precedence chain: NONE -> HIGHEST -> ancestorVersion & ancestoryId
        if (packageDir.ancestorVersion === 'NONE' || packageDir.ancestorId === 'NONE') {
            return '';
        }
        else if (packageDir.ancestorVersion === 'HIGHEST' || packageDir.ancestorId === 'HIGHEST') {
            const query = 'SELECT Id FROM Package2Version ' +
                `WHERE Package2Id = '${packageId}' AND IsReleased = True AND IsDeprecated = False AND PatchVersion = 0 ` +
                'ORDER BY MajorVersion Desc, MinorVersion Desc, PatchVersion Desc, BuildNumber Desc LIMIT 1';
            try {
                return (await hubOrg.getConnection().singleRecordQuery(query, { tooling: true })).Id;
            }
            catch (err) {
                if (packageDir.ancestorVersion === 'HIGHEST') {
                    throw new core_1.SfError(messages.getMessage('errorNoMatchingAncestor', [packageDir.ancestorVersion, packageDir.package]), 'errorNoMatchingAncestor', [messages.getMessage('errorAncestorNotReleased', [packageDir.ancestorVersion])]);
                }
                else {
                    throw new core_1.SfError(messages.getMessage('errorNoMatchingAncestorId', [packageDir.ancestorId, packageDir.package]), 'errorNoMatchingAncestorId', [messages.getMessage('errorAncestorNotReleased', [packageDir.ancestorId])]);
                }
            }
        }
        if (packageDir.ancestorVersion) {
            if (!/^[0-9]+.[0-9]+.[0-9]+.[0-9]+$/.test(packageDir.ancestorVersion) &&
                !/^[0-9]+.[0-9]+.[0-9]+$/.test(packageDir.ancestorVersion)) {
                throw new Error(messages.getMessage('errorInvalidAncestorVersionFormat', [packageDir.ancestorVersion]));
            }
            // package can be an ID in original toolbelt code, but not according to docs
            const splits = packageDir.ancestorVersion.split('.');
            let releasedAncestor;
            try {
                releasedAncestor = await hubOrg
                    .getConnection()
                    .singleRecordQuery(`SELECT Id, IsReleased FROM Package2Version WHERE Package2Id = '${packageId}' AND MajorVersion = ${splits[0]} AND MinorVersion = ${splits[1]} AND PatchVersion = ${splits[2]} and IsReleased = true`, { tooling: true });
            }
            catch (err) {
                throw new core_1.SfError(messages.getMessage('errorNoMatchingAncestor', [packageDir.ancestorVersion, packageDir.package]), 'errorNoMatchingAncestor', [messages.getMessage('errorAncestorNotReleased', [packageDir.ancestorVersion])]);
            }
            if (packageDir.ancestorId && packageDir.ancestorId !== releasedAncestor.Id) {
                throw new Error(messages.getMessage('errorAncestorIdVersionMismatch', [packageDir.ancestorVersion, packageDir.ancestorId]));
            }
            return releasedAncestor.Id;
        }
        if (packageDir.ancestorId) {
            if (packageDir.ancestorId.startsWith('05i')) {
                return packageDir.ancestorId;
            }
            if (packageDir.ancestorId.startsWith('04t')) {
                return (await hubOrg
                    .getConnection()
                    .singleRecordQuery(`SELECT Id FROM Package2Version WHERE SubscriberPackageVersionId = '${packageDir.ancestorId}'`, { tooling: true })).Id;
            }
            if ((_c = projectJson.get('packageAliases')) === null || _c === void 0 ? void 0 : _c[packageDir.ancestorId]) {
                return (_d = projectJson.get('packageAliases')) === null || _d === void 0 ? void 0 : _d[packageDir.ancestorId];
            }
            throw new Error(`Invalid ancestorId ${packageDir.ancestorId}`);
        }
    }));
    // strip out '' due to NONE
    return Array.from(new Set(ancestorIds.filter((id) => id !== ''))).join(';');
};
/**
 * Takes in a scratchOrgInfo and fills in the missing fields
 *
 * @param hubOrg
 * @param scratchOrgInfoPayload - the scratchOrgInfo passed in by the user
 * @param nonamespace - true if the org should have no namespace
 * @param ignoreAncestorIds - true if the sfdx-project.json ancestorId keys should be ignored
 */
exports.generateScratchOrgInfo = async ({ hubOrg, scratchOrgInfoPayload, nonamespace, ignoreAncestorIds, }) => {
    var _a, _b;
    let SfProject;
    try {
        SfProject = await core_1.SfProjectJson.create({});
    }
    catch (e) {
        // project is not required
    }
    scratchOrgInfoPayload.orgName = (_a = scratchOrgInfoPayload.orgName) !== null && _a !== void 0 ? _a : 'Company';
    scratchOrgInfoPayload.package2AncestorIds =
        !ignoreAncestorIds && (SfProject === null || SfProject === void 0 ? void 0 : SfProject.hasPackages())
            ? await exports.getAncestorIds(scratchOrgInfoPayload, SfProject, hubOrg)
            : '';
    // convert various supported array and string formats to a semi-colon-delimited string
    if (scratchOrgInfoPayload.features) {
        if (typeof scratchOrgInfoPayload.features === 'string') {
            const delimiter = scratchOrgInfoPayload.features.includes(';') ? ';' : ',';
            scratchOrgInfoPayload.features = scratchOrgInfoPayload.features.split(delimiter);
        }
        scratchOrgInfoPayload.features = scratchOrgInfoPayload.features.map((feature) => feature.trim());
        const scratchOrgFeatureDeprecation = new scratchOrgFeatureDeprecation_1.ScratchOrgFeatureDeprecation();
        scratchOrgInfoPayload.features = scratchOrgFeatureDeprecation.filterDeprecatedFeatures(scratchOrgInfoPayload.features);
        scratchOrgInfoPayload.features = scratchOrgInfoPayload.features.join(';');
    }
    // Use the Hub org's client ID value, if one wasn't provided to us, or the default
    if (!scratchOrgInfoPayload.connectedAppConsumerKey) {
        scratchOrgInfoPayload.connectedAppConsumerKey = (_b = hubOrg.getConnection().getAuthInfoFields().clientId) !== null && _b !== void 0 ? _b : defaultConnectedAppInfo.clientId;
    }
    if (!nonamespace && (SfProject === null || SfProject === void 0 ? void 0 : SfProject.get('namespace'))) {
        scratchOrgInfoPayload.namespace = SfProject.get('namespace');
    }
    // we already have the info, and want to get rid of configApi, so this doesn't use that
    scratchOrgInfoPayload.connectedAppCallbackUrl = `http://localhost:${await core_1.WebOAuthServer.determineOauthPort()}/OauthRedirect`;
    return scratchOrgInfoPayload;
};

//# sourceMappingURL=scratchOrgInfoGenerator.js.map
