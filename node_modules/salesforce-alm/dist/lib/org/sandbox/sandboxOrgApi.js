"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SandboxOrgApi = exports.SandboxUserAuthRequest = exports.SandboxRequest = void 0;
const core_1 = require("@salesforce/core");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('salesforce-alm', 'org');
class SandboxRequest {
}
exports.SandboxRequest = SandboxRequest;
class SandboxUserAuthRequest {
}
exports.SandboxUserAuthRequest = SandboxUserAuthRequest;
class SandboxOrgApi {
    constructor(org, logger) {
        this.logger = logger;
        this.tooling = org.getConnection().tooling;
    }
    static getInstance(org, logger) {
        return new SandboxOrgApi(org, logger);
    }
    async createSandbox(sandboxReq) {
        this.logger.debug('CreateSandbox called with SandboxRequest: %s ', sandboxReq);
        const createResult = await this.tooling.create(SandboxOrgApi.SOBJECT_SANDBOXINFO, sandboxReq);
        this.logger.debug('Return from calling tooling.create: %s ', createResult);
        if (!Array.isArray(createResult) && createResult.success) {
            const sandboxInfoId = createResult.id;
            const info = await this.queryLatestSandboxProcessBySandboxInfo(sandboxInfoId);
            this.logger.debug('Return from calling queryLatestSandboxProcessBySandboxInfo: %s ', info);
            return info;
        }
        else {
            throw messages.createError('SandboxInfoCreateFailed', [createResult.toString()]);
        }
    }
    /**
     *
     * @param processId
     * @returns sandboxProcess record in json
     */
    async querySandboxProcessById(processId) {
        this.logger.debug('QuerySandboxProcessById called with SandboxProcessId: %s ', processId);
        const queryStr = `SELECT ${SandboxOrgApi.QUERY_SANDBOXPROCESS_FIELDS} FROM ${SandboxOrgApi.SOBJECT_SANDBOXPROCESS} WHERE Id='${processId}' AND Status != 'D' ORDER BY CreatedDate DESC LIMIT 1`;
        const record = await this.queryToolingApi(queryStr, 'SandboxProcessNotFoundById', 'MultiSandboxProcessFoundById', [processId], [processId]);
        this.logger.debug('Return from calling queryToolingApi: %s ', record);
        return record;
    }
    async querySandboxProcessBySandboxOrgId(sandboxOrgId) {
        this.logger.debug('QuerySandboxProcessById called with SandboxOrgId: %s ', sandboxOrgId);
        const queryStr = `SELECT ${SandboxOrgApi.QUERY_SANDBOXPROCESS_FIELDS} FROM ${SandboxOrgApi.SOBJECT_SANDBOXPROCESS} WHERE SandboxOrganization ='${sandboxOrgId}' AND Status NOT IN ('D', 'E') ORDER BY CreatedDate DESC LIMIT 1`;
        const record = await this.queryToolingApi(queryStr, 'sandboxProcessNotFoundByOrgId', 'multiSandboxProcessFoundByOrgId', [sandboxOrgId], [sandboxOrgId]);
        this.logger.debug('Return from calling queryToolingApi: %s ', record);
        return record;
    }
    async queryUserId(userNameIn) {
        this.logger.debug('QueryUserId called with UserName: %s ', userNameIn);
        const queryStr = `SELECT Id FROM User WHERE Username='${userNameIn}'`;
        const userRecord = await this.queryToolingApi(queryStr, 'UserNotFound', 'MultiUserFound', [userNameIn], [userNameIn]);
        this.logger.debug('Return from calling queryToolingApi: %s ', userRecord);
        return userRecord.Id;
    }
    /**
     *
     * @param sandboxNameIn
     * @returns sandboxInfoId
     */
    async querySandboxInfoIdBySandboxName(sandboxNameIn) {
        this.logger.debug('QuerySandboxInfoIdBySandboxName called with SandboxName: %s ', sandboxNameIn);
        const queryStr = `SELECT ${SandboxOrgApi.QUERY_SANDBOXINFO_FIELDS} FROM ${SandboxOrgApi.SOBJECT_SANDBOXINFO} WHERE SandboxName='${sandboxNameIn}'`;
        const record = await this.queryToolingApi(queryStr, 'SandboxInfoNotFound', 'MultiSandboxInfoFound', [sandboxNameIn], [sandboxNameIn]);
        this.logger.debug('Return from calling queryToolingApi: %s ', record);
        return record.Id;
    }
    async queryLatestSandboxProcessBySandboxName(sandboxNameIn) {
        this.logger.debug('QueryLatestSandboxProcessBySandboxName called with SandboxName: %s ', sandboxNameIn);
        const queryStr = `SELECT ${SandboxOrgApi.QUERY_SANDBOXPROCESS_FIELDS} FROM ${SandboxOrgApi.SOBJECT_SANDBOXPROCESS} WHERE SandboxName='${sandboxNameIn}' AND Status != 'D' ORDER BY CreatedDate DESC LIMIT 1`;
        const record = await this.queryToolingApi(queryStr, 'SandboxProcessNotFoundBySandboxName', 'MultiSandboxProcessNotFoundBySandboxName', [sandboxNameIn], [sandboxNameIn]);
        this.logger.debug('Return from calling queryToolingApi: %s ', record);
        return record;
    }
    async queryLatestSandboxProcessBySandboxInfo(sandboxInfoIdIn) {
        this.logger.debug('QueryLatestSandboxProcessBySandboxInfo called with SandboxInfoId: %s ', sandboxInfoIdIn);
        const queryStr = `SELECT ${SandboxOrgApi.QUERY_SANDBOXPROCESS_FIELDS} FROM ${SandboxOrgApi.SOBJECT_SANDBOXPROCESS} WHERE SandboxInfoId='${sandboxInfoIdIn}' AND Status != 'D' ORDER BY CreatedDate DESC LIMIT 1`;
        const record = await this.queryToolingApi(queryStr, 'SandboxProcessNotFoundByInfoId', 'MultiSandboxProcessFoundByInfoId', [sandboxInfoIdIn], [sandboxInfoIdIn]);
        this.logger.debug('Return from calling queryToolingApi: %s ', record);
        return record;
    }
    async queryToolingApi(queryStrIn, key0, key1, tokens0, tokens1) {
        this.logger.debug('QueryToolingApi called with queryStrIn: %s, key0: %s, key1: %s, tokens0: %s, tokens1: %s ', queryStrIn, key0, key1, tokens0, tokens1);
        const queryResult = await this.tooling.query(queryStrIn);
        this.logger.debug('Return from calling tooling.query: %s ', queryResult);
        if (queryResult.records && queryResult.records.length === 1) {
            return queryResult.records[0];
        }
        else if (queryResult.records && queryResult.records.length > 1) {
            throw messages.createError(key1, tokens1);
        }
        else {
            throw messages.createError(key0, tokens0);
        }
    }
    async sandboxAuth(request) {
        this.logger.debug('SandboxAuth called with SandboxUserAuthRequest: %s', request);
        const url = [this.tooling._baseUrl(), 'sandboxAuth'].join('/');
        const params = {
            method: 'POST',
            url,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(request),
        };
        return await this.tooling.request(params);
    }
    async deleteSandbox(sandboxInfoId) {
        this.logger.debug('DeleteSandbox called with SandboxInfoId: %s ', sandboxInfoId);
        const deleteResult = await this.tooling.delete(SandboxOrgApi.SOBJECT_SANDBOXINFO, sandboxInfoId);
        this.logger.debug('Return from calling tooling.delete: %s ', deleteResult);
        if (!Array.isArray(deleteResult) && deleteResult.success) {
            return;
        }
        else {
            throw messages.createError('sandboxDeleteFailed', [deleteResult.toString()]);
        }
    }
}
exports.SandboxOrgApi = SandboxOrgApi;
SandboxOrgApi.SOBJECT_SANDBOXPROCESS = 'SandboxProcess';
SandboxOrgApi.SOBJECT_SANDBOXINFO = 'SandboxInfo';
SandboxOrgApi.QUERY_SANDBOXPROCESS_FIELDS = 'Id, Status, SandboxName, SandboxInfoId, LicenseType, CreatedDate, CopyProgress, SandboxOrganization, SourceId, Description, EndDate ';
SandboxOrgApi.QUERY_SANDBOXINFO_FIELDS = 'Id, SandboxName ';

//# sourceMappingURL=sandboxOrgApi.js.map
