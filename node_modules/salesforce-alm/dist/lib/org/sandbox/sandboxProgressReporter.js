"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SandboxProgressReporter = void 0;
const kit_1 = require("@salesforce/kit");
class SandboxProgressReporter {
    static logSandboxProcessResult(ux, processRecord, sandboxRes) {
        if (processRecord) {
            const resultMsg = `Sandbox ${processRecord.SandboxName}(${processRecord.Id}) is ready for use.`;
            ux.log(resultMsg);
            const data = [
                { key: 'Id', value: processRecord.Id },
                { key: 'SandboxName', value: processRecord.SandboxName },
                { key: 'Status', value: processRecord.Status },
                { key: 'CopyProgress', value: processRecord.CopyProgress },
                { key: 'Description', value: processRecord.Description },
                { key: 'LicenseType', value: processRecord.LicenseType },
                { key: 'SandboxInfoId', value: processRecord.SandboxInfoId },
                { key: 'SourceId', value: processRecord.SourceId },
                { key: 'SandboxOrg', value: processRecord.SandboxOrganization },
                { key: 'Created Date', value: processRecord.CreatedDate },
                { key: 'ApexClassId', value: processRecord.ApexClassId },
                { key: 'Authorized Sandbox Username', value: sandboxRes.authUserName },
            ];
            ux.styledHeader('Sandbox Org Creation Status');
            ux.table(data, { key: { header: 'Name' }, value: { header: 'Value' } });
        }
    }
    static logSandboxProgress(ux, processRecord, pollIntervalInSecond, retriesLeft, waitingOnAuth) {
        let progressMsg;
        const waitTimeInSec = retriesLeft * pollIntervalInSecond;
        const waitTime = SandboxProgressReporter.getSecondsToHms(waitTimeInSec);
        const waitTimeMsg = `Sleeping ${pollIntervalInSecond} seconds. Will wait ${waitTime} more before timing out.`;
        const sandboxIdentifierMsg = `${processRecord.SandboxName}(${processRecord.Id})`;
        const waitingOnAuthMessage = waitingOnAuth ? ', waiting on JWT auth' : '';
        const completionMessage = `(${processRecord.CopyProgress}% completed${waitingOnAuthMessage})`;
        progressMsg = `Sandbox request ${sandboxIdentifierMsg} is ${processRecord.Status} ${completionMessage}. ${waitTimeMsg}`;
        ux.log(progressMsg);
    }
    static getSecondsToHms(waitTimeInSec) {
        const h = kit_1.Duration.hours(Math.floor(waitTimeInSec / 3600));
        const m = kit_1.Duration.minutes(Math.floor((waitTimeInSec % 3600) / 60));
        const s = kit_1.Duration.seconds(Math.floor(waitTimeInSec % 60));
        const hDisplay = h.hours > 0 ? h.toString() + ' ' : '';
        const mDisplay = m.minutes > 0 ? m.toString() + ' ' : '';
        const sDisplay = s.seconds > 0 ? s.toString() : '';
        return (hDisplay + mDisplay + sDisplay).trim();
    }
}
exports.SandboxProgressReporter = SandboxProgressReporter;

//# sourceMappingURL=sandboxProgressReporter.js.map
