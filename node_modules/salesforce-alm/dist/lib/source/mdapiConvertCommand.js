"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
// Thirdparty
const os = require("os");
const optional = require("optional-js");
// Local
const core_1 = require("@oclif/core");
const core_2 = require("@salesforce/core");
const Force = require("../core/force");
const ScratchOrg = require("../core/scratchOrgApi");
const messages = require("../messages");
const srcDevUtil = require("../core/srcDevUtil");
const logger = require("../core/logApi");
const syncCommandHelper = require("./syncCommandHelper");
const MdapiConvertApi = require("./mdapiConvertApi");
const { Messages } = require('@salesforce/core');
Messages.importMessagesDirectory(__dirname);
const COMMAND_TEMP_ORG = 'mdapiConvertTemp@org.org';
class MdapiConvertCommand {
    constructor(force) {
        this.force = optional.ofNullable(force).orElse(new Force());
        this.messages = messages(this.force.config.getLocale());
        this.org = new ScratchOrg();
        this.org.setName(COMMAND_TEMP_ORG);
        this.logger = logger.child('mdapi:convert');
        // Set a null active package so SourceWorkspaceAdapter does
        // not get confused during decomposition.
        core_2.SfProject.getInstance().setActivePackage(null);
    }
    validate(context) {
        const fixedContext = srcDevUtil.fixCliContext(context);
        this.api = new MdapiConvertApi(this.force);
        this.api.root = fixedContext.rootdir;
        if (fixedContext.outputdir) {
            this.api.outputDirectory = fixedContext.outputdir;
        }
        return Promise.resolve(fixedContext);
    }
    execute(context) {
        const sourceConvertOptions = Object.assign({}, context);
        this.api.unsupportedMimeTypes = []; // for logging unsupported static resource mime types
        return this.api
            .convertSource(this.org, sourceConvertOptions)
            .then((outputElements) => srcDevUtil
            .logUnsupportedMimeTypeError(this.api.unsupportedMimeTypes, this.logger, this.force)
            .then(() => outputElements))
            .finally(() => this.org.cleanData());
    }
    /**
     * We are a using a two table output now, one table for the files that were converted and another one for duplicate files.
     * Note that if there was already a file with same name/type but the contents are identical then no .dup file will be
     * created and nothing will be shown in the output for that file.
     */
    getHumanSuccessMessage(data) {
        const commonMsgs = Messages.loadMessages('salesforce-alm', 'source');
        const header = this.messages.getMessage('tableName', [], 'mdapiConvertCommand');
        const columns = syncCommandHelper.getColumnMetaInfo(commonMsgs);
        const converted = [];
        const duplicates = [];
        data.forEach((e) => {
            if (e.state === 'Duplicate') {
                duplicates.push(e);
            }
            else {
                converted.push(e);
            }
        });
        let needNewLine = false;
        if (converted.length > 0) {
            this.logger.styledHeader(this.logger.color.blue(header));
            core_1.CliUx.ux.table(converted, columns);
            needNewLine = true;
        }
        if (duplicates.length > 0) {
            if (needNewLine) {
                this.logger.log(os.EOL);
            }
            this.logger.styledHeader(this.logger.color.blue(this.messages.getMessage('tableNameDups', [], 'mdapiConvertCommand')));
            this.logger.log(this.messages.getMessage('dupsExplanation', [], 'mdapiConvertCommand'));
            this.logger.log(os.EOL);
            core_1.CliUx.ux.table(duplicates, columns);
        }
    }
}
module.exports = MdapiConvertCommand;

//# sourceMappingURL=mdapiConvertCommand.js.map
