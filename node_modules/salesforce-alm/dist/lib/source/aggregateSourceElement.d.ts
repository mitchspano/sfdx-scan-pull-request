import MetadataRegistry = require('./metadataRegistry');
import { DecompositionStrategy } from './decompositionStrategy/decompositionStrategy';
import { DecompositionWorkspaceStrategy } from './decompositionStrategy/decompositionWorkspaceStrategy';
import { DecompositionCommitStrategy } from './decompositionStrategy/decompositionCommitStrategy';
import { WorkspaceElement } from './workspaceElement';
import { ContentDecompositionStrategy } from './decompositionStrategy/contentDecompositionStrategy';
import { MetadataType } from './metadataType';
import { FilePathsIndex } from './sourceLocations';
import { ForceIgnore } from '@salesforce/source-deploy-retrieve';
/**
 * Class used to manage top-level metadata
 * Examples of top-level metadata types include: ApexClass, CustomObject, StaticResource, etc.
 *
 * For compound metadata requiring de/recomposition, this facade is the point of entry for
 * decomposition/re-composition from other code. No client code should reference any other
 * internal implementation classes. If this class proves inadequate for future needs then it should
 * be extended and the internal implementation classes modified to support the new requirements.
 *
 * This class is agnostic wrt how the decomposition of the source metadata file is
 * performed, including the nature of the aggregated and decomposed files,  and also
 * how the decomposed files are represented in the workspace. These decisions are
 * delegated to the strategies configured in the metadata registry for the type.
 */
export declare class AggregateSourceElement {
    metadataType: MetadataType;
    workspaceVersion: any;
    decompStrategy: DecompositionStrategy;
    workspaceStrategy: DecompositionWorkspaceStrategy;
    commitStrategy: DecompositionCommitStrategy;
    contentStrategy: ContentDecompositionStrategy;
    metadataFilePath: string;
    deleted: boolean;
    metadataRegistry: MetadataRegistry;
    retrievedMetadataPath: string;
    retrievedContentPaths: string[];
    aggregateFullName: string;
    isDuplicate: boolean;
    packageName: string;
    workspaceElements: WorkspaceElement[];
    pendingDeletedWorkspaceElements: WorkspaceElement[];
    filePathsIndex: FilePathsIndex;
    /**
     * @param aggregateMetadataType - this is the type for the top-level parent metadata - e.g. ApexClass, CustomObject, etc.
     * @param aggregateFullName - this is the name of the top-level parent metadata
     * @param aggregateMetadataFilePath - this is the full file path to the top-level parent metadata
     * @param metadataRegistry
     */
    constructor(aggregateMetadataType: MetadataType, aggregateFullName: string, aggregateMetadataFilePath: string, metadataRegistry: MetadataRegistry);
    getMetadataType(): MetadataType;
    static getKeyFromMetadataNameAndFullName(aggregateMetadataName: string, aggregateFullName: string): string;
    getKey(): string;
    /**
     * Gets the metadata workspace path that would be in use if this type were not transformed.
     * The locations of associated decomposed/non-decomposed content and metadata  files can be inferred from this name.
     *
     * @returns {string}
     */
    getMetadataFilePath(): string;
    getAggregateFullName(): string;
    getMetadataName(): string;
    getPackageName(): string;
    /**
     * Returns all paths to workspace source files matching the given metadata type and fullName
     *
     * @param metadataTypeName
     * @param fullNameForPath
     * @returns {string[]}
     */
    getWorkspacePathsForTypeAndFullName(metadataTypeName: any, fullNameForPath: any): string[];
    getContentWorkspacePathsForTypeAndFullName(metadataTypeName: string, fullNameForPath: string): string[];
    getMetadataWorkspacePathsForTypeAndFullName(metadataTypeName: string, fullNameForPath: string): string[];
    addWorkspaceElement(workspaceElement: WorkspaceElement): void;
    /**
     * Returns the collection of workspace elements associated with this aggregate source element
     *
     * @returns {WorkspaceElement[]}
     */
    getWorkspaceElements(): WorkspaceElement[];
    /**
     * returns the collection of deleted workspace elements associated with this aggregate source element
     *
     * @returns {WorkspaceElement[]}
     */
    getPendingDeletedWorkspaceElements(): WorkspaceElement[];
    /**
     * Adds the given workspace element to a collection to be processed during commit
     *
     * @param deletedWorkspaceElement
     */
    addPendingDeletedWorkspaceElement(deletedWorkspaceElement: any): void;
    isDeleted(): boolean;
    /**
     * If the workspace is in an inconsistent state, where a metadata file was deleted but not the content files,
     * or the aura bundle metadata file was deleted but not the whole bundle, then throw an error
     *
     * @param workspaceElement
     */
    validateIfDeletedWorkspaceElement(workspaceElement: any): void;
    private getContainerPath;
    private isAggregateSourceElementDeleted;
    /**
     * Flags this aggregate source element as deleted and marks all of its associated workspace elements as deleted
     */
    markForDelete(): void;
    /**
     * Gets the list of existing decomposed and non-decomposed metadata files for the given source metadata entity.
     *
     * @param metadataFilePath the workspace path that would be in use if this type were not transformed.
     * The locations of the actual decomposed files can be inferred from this name. This is a proxy for all
     * of decomposed files.
     * @returns {string[]} the list of existing decomposed files for the given source metadata entity
     */
    getMetadataPaths(metadataFilePath: string): string[];
    /**
     * Gets all of the workspace paths to composed and nondecomposed content files associated with this aggregateSourceElement
     *
     * @param metadataFilePath
     * @returns {any}
     */
    getContentPaths(metadataFilePath: string): string[];
    /**
     * Commits changes to the workspace
     *
     * @param manifest
     * @param unsupportedMimeTypes - the list of non-allow-listed static resource mime types
     * @param forceoverwrite
     * @returns {Array[]}
     */
    commit(manifest: any, unsupportedMimeTypes: string[], forceoverwrite?: boolean): Promise<[string[], string[], string[]]>;
    /**
     * Delete workspace elements from the workspace
     *
     * @param deletedPaths
     */
    commitDeletes(deletedPaths: any): void;
    private commitMetadata;
    private commitContent;
    private addEmptyFolder;
    private addCorrespondingWorkspaceElements;
    checkForDuplicates(): void;
    /**
     * Gets the translation objects for copying source from the workspace to the metadata API formatted directory
     *
     * @param mdDir
     * @param tmpDir
     * @param unsupportedMimeTypes - the list of non-whitelisted static resource mime types
     * @param forceIgnore
     * @returns {Array}
     */
    getFilePathTranslations(mdDir: any, tmpDir: any, unsupportedMimeTypes?: string[], forceIgnore?: ForceIgnore): Promise<any[]>;
    private getContentPathTranslations;
    private getMetadataPathTranslation;
    /**
     *
     * @param sourcePath Source workspace filepath
     * @param mdapiPath Temporary mdapiDir filepath
     * @returns {{sourcePath: *, mdapiPath: *}}
     * @private
     */
    private createTranslation;
    /**
     * Composes a single metadata file from one or more files each representing a part of the whole.
     * It is important to understand that this does <b>not</b> have to be an mdapi xml file, even though
     * it usually will be. That determination will be driven by a type-specific configuration.
     *
     * @param metadataFilePath the workspace path that would be in use if this type were not transformed.
     * The locations of the actual decomposed files can be inferred from this name. This is a proxy for all
     * of decomposed files.
     * @param tmpDir temporary directory to hold the composed metadata file outside of the workspace.
     * @returns {string} the path of composed metadata file.
     */
    composeMetadata(metadataFilePath: string, tmpDir: string): Promise<string>;
    private includeDecomposition;
    /**
     *
     * @param sourceFilePath an aggregated file, typically an mdapi xml file
     * @param metadataFilePath the workspace path that would be in use if this type were not transformed.
     * The locations of the actual decomposed files can be inferred from this name. This is a proxy for all
     * of decomposed files.
     * @param manifest
     * @returns {[string[], string[], string[]]} a triplet containing a list of new, updated, and deleted workspace paths for the decomposed files.
     */
    private decomposeMetadata;
    private getComposedFilePath;
    private getPaths;
    /**
     * Returns the source dir into which metadata will be decomposed.
     * It first tries to find an existing directory based on the annotation
     * If that directory does not exist, if will find the directory based on
     * the metadata file path
     *
     * @param annotation
     * @param metadataFilePath
     * @param decomposedSubtypeConfig
     */
    private getSourceDir;
    /**
     * Returns true if the provided path does not belong to the active package (that is, the package we're in the process of pulling)
     * For example, when pulling a CustomObject in PackageA, we don't want to update any CustomFields on that object that belong
     * to PackageB.
     * For a mdapi:convert, the pkgName should be null. The active package is set by the mdapiConvertCommand to be null as well
     * so this function returns false (meaning the path is not ignored, which is what we want).  There are no package directories
     * for mdapi:convert and source:convert.
     */
    private shouldIgnorePath;
}
