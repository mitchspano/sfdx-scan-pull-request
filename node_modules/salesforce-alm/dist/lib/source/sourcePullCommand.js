"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const BBPromise = require("bluebird");
const core_1 = require("@salesforce/core");
const Messages = require("../messages");
const almError = require("../core/almError");
const srcDevUtil = require("../core/srcDevUtil");
const logger = require("../core/logApi");
const sourceUtil_1 = require("./sourceUtil");
const syncCommandHelper = require("./syncCommandHelper");
const sourcePullApi_1 = require("./sourcePullApi");
const messages = Messages();
core_1.Messages.importMessagesDirectory(__dirname);
class MdapiPullCommand {
    constructor() {
        this.logger = logger.child('source:legacy:pull');
        this.commonMsgs = core_1.Messages.loadMessages('salesforce-alm', 'source');
    }
    validate(context) {
        // Validate the wait param if set and convert to an integer.
        sourceUtil_1.parseWaitParam(context.flags);
        return BBPromise.resolve(context);
    }
    getPreExecuteMessage({ orgId, username }) {
        return messages.getMessage('pullCommandCliPreExecute', [orgId, username]);
    }
    execute(context) {
        const scratchOrg = context.org;
        const force = scratchOrg.force;
        const options = context.flags || {};
        const rows = [];
        const projectPath = force.config.getProjectPath();
        return sourcePullApi_1.MdapiPullApi.create({ org: scratchOrg })
            .then((mdapiPull) => {
            options.unsupportedMimeTypes = []; // for logging unsupported static resource mime types
            return mdapiPull.doPull(options);
        })
            .catch((e) => {
            if (e.name === 'SourceConflict') {
                const error = almError('sourceConflictDetected');
                e.sourceConflictElements.forEach((sourceElement) => syncCommandHelper.createConflictRows(rows, sourceElement, projectPath));
                error['columns'] = syncCommandHelper.getColumnMetaInfo(this.commonMsgs);
                error['result'] = rows;
                this.logger.error(messages.getMessage('pullCommandConflictMsg'));
                throw error;
            }
            else {
                throw e;
            }
        })
            .then((results) => {
            results.forEach((result) => {
                if (result) {
                    result.inboundFiles.forEach((sourceItem) => syncCommandHelper.createDisplayRows(rows, sourceItem, projectPath));
                }
            });
        })
            .then(() => this.logger.styledHeader(this.logger.color.blue(messages.getMessage('pullCommandHumanSuccess'))))
            .then(() => srcDevUtil.logUnsupportedMimeTypeError(options.unsupportedMimeTypes, this.logger, force))
            .then(() => (options.json ? { pulledSource: rows } : rows));
    }
    /**
     * this indicated to index.js this command should produce tabular output.
     *
     * @returns {*[]}
     */
    getColumnData() {
        return syncCommandHelper.getColumnMetaInfo(this.commonMsgs);
    }
}
module.exports = MdapiPullCommand;

//# sourceMappingURL=sourcePullCommand.js.map
