import { ConfigFile, ConfigValue, Logger } from '@salesforce/core';
import { AnyJson, Nullable } from '@salesforce/ts-types';
import { SourcePathInfo } from './sourcePathStatusManager';
import { ChangeElement } from './remoteSourceTrackingService';
import MetadataRegistry = require('./metadataRegistry');
export declare type NonDecomposedElement = ConfigValue & {
    fullName: string;
    type: string;
    metadataFilePath: string;
};
export declare namespace NonDecomposedElementsIndex {
    interface Options extends ConfigFile.Options {
        username: string;
        metadataRegistry: MetadataRegistry;
    }
}
/**
 * NonDecomposedElementsIndex maintains an index of non-decomposed elements (e.g. CustomLabel) at
 * <project_dir>/.sfdx/orgs/<username>/nonDecomposedElementsIndex.json.
 *
 * The purpose of this is to be able to figure out which elements belong to which file. So for example,
 * if we have CustomLabels files in two separate packages, we can use this index to determine which
 * labels to put into the package.xml when executing a retrieve or a pull.
 *
 * We use the NON_DECOMPOSED_CONFIGS to determine which metadata types need to be read and stored into the index.
 *   - The keys (e.g. CustomLabels) are the aggregate metadata types. This tells us which meta files we need to read.
 *   - childType refers to the metadata type of the elements inside the meta file
 *   - xmlTag tells us where to find the elements inside the xml
 *   - namePath tells us where to find the name of the element
 */
export declare class NonDecomposedElementsIndex extends ConfigFile<NonDecomposedElementsIndex.Options> {
    logger: Logger;
    private static _instances;
    private includedFiles;
    private metadataRegistry;
    private hasChanges;
    private remoteSourceTrackingService;
    static getInstance(options: NonDecomposedElementsIndex.Options): Promise<NonDecomposedElementsIndex>;
    static getFileName(): string;
    protected init(): Promise<void>;
    populateIncludedFiles(): void;
    addElement(metadataName: string, fullName: string, sourcePath: string): Promise<void>;
    getMetadataFilePath(key: string): Nullable<string>;
    /**
     * Returns true if the metadata type contains non-decomposed elements
     * that we want to put into the index.
     */
    isNonDecomposedElement(metadataName: string): boolean;
    static isSupported(metadataName: string): boolean;
    /**
     * Returns true if the provided sourcePath is in this.includedFiles.
     * If a file is in this.includedFiles, that means that the index has
     * already read that file
     */
    isIncludedFile(sourcePath: string): boolean;
    /**
     * Returns true if the file has NOT changed or is NOT new
     */
    private shouldSkip;
    /**
     * Adds the non-decomposed elements within a sourcePath to the index
     *
     * If the given sourcePath is supported, then we:
     *  - read the xml
     *  - parse the xml for the non-decomposed elements
     *  - add all those elements to the index
     *
     * We skip this process if:
     *  - the sourcePath belongs to a metadata type that doesn't have non-decomposed elements
     *  - OR the sourcePath hasn't changed since the last time we read it
     *
     * Set the refresh flag to true if you want to force update the index
     */
    handleDecomposedElements(sourcePathInfo: SourcePathInfo, refresh?: boolean): Promise<void>;
    /**
     * Unsets elements with a metadataFilePath that matches the provided sourcePath
     */
    clearElements(sourcePath: string): void;
    /**
     * Returns JSON representation of an xml file
     */
    private readXmlAsJson;
    /**
     * Synchronously read a source file and look for a specific metadata key contained within it,
     * returning `true` if found.  If the metadata key is a type unknown to this index, or if there
     * is a problem reading/parsing the source file, an error will be logged.
     *
     * @param sourcePath The path to the source file.
     * @param mdKey The metadata key to search within the source file.  E.g., CustomLabels__MyLabelName
     */
    static belongsTo(sourcePath: string, mdKey: string): boolean;
    /**
     * Given an array of ChangeElements, find all changeElements that live in the same file location.
     * For example, given a custom label this will return all custom labels that live in the same CustomLabels
     * meta file.
     */
    getRelatedNonDecomposedElements(changeElements: ChangeElement[]): ChangeElement[];
    /**
     * Returns all elements in the index that have a given metadataFilePath
     */
    getElementsByMetadataFilePath(metadataFilePath: string): NonDecomposedElement[];
    /**
     * Refreshes the index IF the inboundFiles contain any paths that have
     * been previously added to the index.
     */
    maybeRefreshIndex(inboundFiles: any[]): Promise<void>;
    /**
     * Refreshes the index using the provided sourcePaths. If no sourcePaths
     * are provided then it will default to refreshing files that have already
     * been indexed (this.includedFiles)
     */
    refreshIndex(sourcePaths?: string[]): Promise<void>;
    /**
     * Returns true if the given nonDecomposedElements belongs to the default package
     */
    private elementBelongsToDefaultPackage;
    deleteEntryBySourcePath(path: string): void;
    write(): Promise<import("@salesforce/core").ConfigContents<AnyJson>>;
    get(key: string): NonDecomposedElement;
    set(key: string, value: NonDecomposedElement): import("@salesforce/core").ConfigContents<AnyJson>;
    values(): NonDecomposedElement[];
}
