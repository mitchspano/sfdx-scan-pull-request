import { AggregateSourceElement } from './aggregateSourceElement';
import { WorkspaceElement } from './workspaceElement';
export declare type PackageName = string;
export declare type SourceElementKey = string;
export declare type AggregateSourceElementMap = Map<SourceElementKey, AggregateSourceElement>;
declare type AggregateSourceElementEntries = Array<[PackageName, AggregateSourceElementMap]> | null;
declare type FilterOptions = {
    fuzzy?: boolean;
};
export declare class AggregateSourceElements extends Map<PackageName, AggregateSourceElementMap> {
    constructor(entries?: AggregateSourceElementEntries);
    /**
     * DO NOT USE. Use getSourceElement instead.
     * Returns the FIRST matching AggregateSourceElement. We should not use this method
     * because you're not guaranteed to get the source element from the correct package.
     */
    findSourceElementByKey(key: SourceElementKey): AggregateSourceElement;
    /**
     * Returns `AggregateSourceElements` from all package directories matching the
     * given source element key.
     *
     * @param key a metadata type name pair.  E.g., ApexClass__MyClass
     * @param options the filter options to apply when matching AggregateSourceElements
     */
    filterSourceElementsByKey(key: SourceElementKey, options?: FilterOptions): AggregateSourceElements;
    /**
     * Attempts to find the parent AggregateSourceElement across package directories
     * that contains the matching child metadata type and name as a WorkspaceElement.
     * It then returns the parent ASE with all WorkspaceElements removed except for
     * the matching child WorkspaceElement.  This allows fine-grained deploys/retrieves.
     *
     * E.g., Given the custom field "FieldA" that belongs to custom object "CO1";
     *         - CO1 has meta-xml file and "FieldB" in package directory X
     *         - CO1 also has "FieldA" and "FieldC" in package directory Y
     *       This method will return the "CO1" ASE from package dir Y containing
     *       only the "FieldA" WorkspaceElement.
     */
    findParentElement(parentKey: SourceElementKey, childType: string, childName: string): AggregateSourceElement;
    getSourceElement(packageName: PackageName, key: SourceElementKey): AggregateSourceElement;
    deleteSourceElement(packageName: PackageName, key: SourceElementKey): this;
    setIn(packageName: PackageName, sourceElementKey: SourceElementKey, sourceElement: AggregateSourceElement): this;
    /**
     * Returns a flat array of all source elements across all packages
     */
    getAllSourceElements(): AggregateSourceElement[];
    getAllWorkspaceElements(): WorkspaceElement[];
    getAllSourceKeys(): SourceElementKey[];
    isEmpty(): boolean;
    /**
     * Merges `AggregateSourceElements` and their corresponding `WorkspaceElements` with their
     * corresponding package directory names.
     * Note that 2 `AggregateSourceElements` with identical `AggregateSourceElement` key entries
     * (i.e., same CustomObject) but with different `WorkspaceElements` will simply add all
     * missing `WorkspaceElements` from the merging ASE to the existing ASE.
     *
     * @param aggregateSourceElements The other `AggregateSourceElements` to merge with this one.
     */
    merge(aggregateSourceElements: AggregateSourceElements): this;
}
export {};
