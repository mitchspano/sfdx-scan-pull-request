"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
// Local
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const core_1 = require("@salesforce/core");
const almError = require("../core/almError");
const logger = require("../core/logApi");
const Messages = require("../../lib/messages");
const MdapiPackage = require("./mdapiPackage");
const metadataTypeFactory_1 = require("./metadataTypeFactory");
const remoteSourceTrackingService_1 = require("./remoteSourceTrackingService");
const nonDecomposedElementsIndex_1 = require("./nonDecomposedElementsIndex");
const messages = Messages();
/**
 * Helper that checks if the md item was set to obsolete in the org and returns true if so
 *
 * @param mdApiItem
 * @param obsoleteNames
 * @param metadataRegistry
 * @param forceIgnore
 * @returns {boolean} true - if the item is obsolete and should not be part of the md package
 * @private
 */
const _shouldExcludeFromMetadataPackage = function (mdApiItem, obsoleteNames, metadataRegistry, forceIgnore) {
    const mdFullName = mdApiItem.fullName;
    if (mdApiItem.isNameObsolete) {
        obsoleteNames.push({ fullName: mdFullName, type: mdApiItem.type });
        return true;
    }
    // check if the entity is a supported type
    if (!metadataRegistry.isSupported(mdApiItem.type) && !nonDecomposedElementsIndex_1.NonDecomposedElementsIndex.isSupported(mdApiItem.type)) {
        return true;
    }
    // if user wants to ignore a permissionset with fullname abc then we check if forceignore accepts abc.permissionset
    const metadataType = metadataTypeFactory_1.MetadataTypeFactory.getMetadataTypeFromMetadataName(mdApiItem.type, metadataRegistry);
    if (metadataType) {
        const filename = `${mdFullName}.${metadataType.getExt()}`;
        if (forceIgnore.denies(filename)) {
            return true;
        }
    }
    return false;
};
/**
 * Class used to derive changed org metadata.
 */
class SourceMetadataMemberRetrieveHelper {
    constructor(sourceWorkspaceAdapter) {
        this.swa = sourceWorkspaceAdapter;
        this.metadataRegistry = sourceWorkspaceAdapter.metadataRegistry;
        this.forceIgnore = source_deploy_retrieve_1.ForceIgnore.findAndCreate(core_1.SfProject.resolveProjectPathSync());
        this.logger = logger.child('SourceMetadataMemberRetrieveHelper');
        this.username = this.swa.options.org.name;
    }
    shouldAddMember(mdApiItem, obsoleteNames) {
        return (mdApiItem !== null &&
            !_shouldExcludeFromMetadataPackage.call(this, mdApiItem, obsoleteNames, this.metadataRegistry, this.forceIgnore));
    }
    /**
     * gets all source metadata revisions from the server from <fromRevision>.
     *
     * @returns
     * "Package": {
     *   "$": {
     *     "xmlns": "http://soap.sforce.com/2006/04/metadata"
     *   },
     *   "types": [
     *     {
     *       "name": "ApexClass",
     *       "members": [...]
     *     },
     *     ...
     *   ],
     *   "version": 38
     *}
     */
    async getRevisionsAsPackage(obsoleteNames) {
        const remoteSourceTrackingService = await remoteSourceTrackingService_1.RemoteSourceTrackingService.getInstance({
            username: this.username,
        });
        const changedElements = await remoteSourceTrackingService.retrieveUpdates();
        const nonDecomposedElementsIndex = await nonDecomposedElementsIndex_1.NonDecomposedElementsIndex.getInstance({
            username: this.username,
            metadataRegistry: this.metadataRegistry,
        });
        const relatedElements = nonDecomposedElementsIndex.getRelatedNonDecomposedElements(changedElements);
        const allElements = changedElements.concat(relatedElements);
        const parsePromises = allElements.map((sourceMember) => {
            const memberType = sourceMember.type;
            const memberName = sourceMember.name;
            if (!memberType || !memberName) {
                throw almError('fullNameIsRequired');
            }
            const metadataType = metadataTypeFactory_1.MetadataTypeFactory.getMetadataTypeFromMetadataName(memberType, this.metadataRegistry);
            if (metadataType) {
                return metadataType.parseSourceMemberForMetadataRetrieve(sourceMember.name, sourceMember.type, sourceMember.deleted);
            }
            else {
                this.logger.log(messages.getMessage('metadataTypeNotSupported', [memberType, memberName]));
                return null;
            }
        });
        const promisedResults = await Promise.all(parsePromises);
        const packages = {};
        core_1.SfProject.getInstance()
            .getUniquePackageNames()
            .forEach((pkg) => {
            packages[pkg] = new MdapiPackage();
        });
        promisedResults.forEach((mdApiItem) => {
            if (!this.shouldAddMember(mdApiItem, obsoleteNames)) {
                return;
            }
            const pkg = this.determinePackage(mdApiItem);
            packages[pkg].addMember(mdApiItem.fullName, mdApiItem.type);
        });
        return packages;
    }
    determinePackage(mdApiItem) {
        const sourceMemberMetadataType = metadataTypeFactory_1.MetadataTypeFactory.getMetadataTypeFromMetadataName(mdApiItem.type, this.metadataRegistry);
        let fileLocation = this.swa.sourceLocations.getFilePath(sourceMemberMetadataType.getAggregateMetadataName(), mdApiItem.fullName);
        if (!fileLocation && sourceMemberMetadataType.hasParent()) {
            // Try to get a fileLocation using the parent fullName. We do this to match a new remote
            // field with its parent custom object location rather than assuming the default package.
            fileLocation = this.swa.sourceLocations.getFilePath(sourceMemberMetadataType.getAggregateMetadataName(), sourceMemberMetadataType.getAggregateFullNameFromSourceMemberName(mdApiItem.fullName));
        }
        const defaultPackage = core_1.SfProject.getInstance().getDefaultPackage().name;
        if (fileLocation) {
            return core_1.SfProject.getInstance().getPackageNameFromPath(fileLocation) || defaultPackage;
        }
        else {
            return defaultPackage;
        }
    }
}
module.exports = SourceMetadataMemberRetrieveHelper;

//# sourceMappingURL=sourceMetadataMemberRetrieveHelper.js.map
