"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.XmlMetadataDocument = void 0;
const util = require("util");
const xmldom_sfdx_encoding_1 = require("xmldom-sfdx-encoding");
const core_1 = require("@salesforce/core");
const sourceUtil_1 = require("./sourceUtil");
/**
 * Class used to hold an XML metadata document.
 * This uses a unitary XML representation and DOM content.
 */
class XmlMetadataDocument {
    constructor(metadataName, xmlAttributes) {
        if (!util.isNullOrUndefined(metadataName)) {
            this.setRepresentation(this.getOuterXml(metadataName, xmlAttributes));
        }
    }
    getRepresentation() {
        const pretty = true;
        return XmlMetadataDocument.serializeData(this.data, pretty);
    }
    getUnmodifiedRepresentation() {
        const pretty = false;
        return XmlMetadataDocument.serializeData(this.data, pretty);
    }
    setRepresentation(representation) {
        const errHandlerResults = [];
        const errHandler = (key, message) => {
            errHandlerResults.push({ key, message });
        };
        this.data = XmlMetadataDocument.parseRepresentation(representation, errHandler);
        if (errHandlerResults.length > 0) {
            const error = new core_1.SfError('XML parse errors reported', 'xmlParseErrorsReported');
            error.setData(errHandlerResults);
            throw error;
        }
    }
    getAnnotation() {
        return this.annotation;
    }
    setAnnotation(annotation) {
        this.annotation = annotation;
    }
    isEquivalent(doc) {
        return this.getRepresentation() === doc.getRepresentation();
    }
    isEquivalentTo(representation) {
        const rhs = new XmlMetadataDocument(null);
        try {
            rhs.setRepresentation(representation);
        }
        catch (e) {
            throw sourceUtil_1.checkForXmlParseError(representation, e);
        }
        return this.isEquivalent(rhs);
    }
    static getWhitespace(indent) {
        const tabSpaces = '    ';
        let whitespace = '\n';
        for (let i = 0; i < indent; ++i) {
            whitespace = whitespace + tabSpaces;
        }
        return whitespace;
    }
    static isEmptyElement(node) {
        return node.childNodes.length === 0;
    }
    static isSimpleElement(node) {
        const nodeTypeText = 3;
        const nodeTypeComment = 8;
        return (node.childNodes.length === 1 &&
            (node.firstChild.nodeType === nodeTypeText || node.firstChild.nodeType === nodeTypeComment));
    }
    static insertAfter(node, refNode) {
        if (refNode.nextSibling !== null) {
            refNode.parentNode.insertBefore(node, refNode.nextSibling);
        }
        else {
            refNode.parentNode.appendChild(node);
        }
    }
    static addWhitespaceNodes(document, node, indent) {
        if (node !== null) {
            const nodeTypeElement = 1;
            if (node.nodeType === nodeTypeElement) {
                if (!XmlMetadataDocument.isEmptyElement(node) && !XmlMetadataDocument.isSimpleElement(node)) {
                    node.insertBefore(document.createTextNode(XmlMetadataDocument.getWhitespace(indent + 1)), node.firstChild);
                }
                XmlMetadataDocument.insertAfter(document.createTextNode(XmlMetadataDocument.getWhitespace(node.nextSibling !== null ? indent : indent - 1)), node);
            }
            let child = node.firstChild;
            while (child !== null) {
                XmlMetadataDocument.addWhitespaceNodes(document, child, indent + 1);
                child = child.nextSibling;
            }
        }
    }
    static addWhitespace(document) {
        document.insertBefore(document.createTextNode(XmlMetadataDocument.getWhitespace(0)), document.documentElement);
        XmlMetadataDocument.addWhitespaceNodes(document, document.documentElement, 0);
    }
    static beautifyDocument(document) {
        this.stripWhitespace(document);
        XmlMetadataDocument.addWhitespace(document);
    }
    static stripWhitespace(document) {
        if (document !== null) {
            const nodeTypeText = 3;
            if (document.nodeType === nodeTypeText) {
                // the nodes that this function is meant to filter start with '\n'
                if (!/[^\s]/.test(document.nodeValue) && document.nodeValue.startsWith('\n')) {
                    document.parentNode.removeChild(document);
                }
            }
            else {
                let child = document.firstChild;
                while (child !== null) {
                    const current = child;
                    child = child.nextSibling;
                    this.stripWhitespace(current);
                }
            }
        }
    }
    static serializeData(document, pretty) {
        if (pretty) {
            XmlMetadataDocument.beautifyDocument(document);
        }
        return new xmldom_sfdx_encoding_1.XMLSerializer().serializeToString(document);
    }
    static parseRepresentation(xml, errorHandler) {
        return new xmldom_sfdx_encoding_1.DOMParser({ errorHandler }).parseFromString(xml, 'application/xml');
    }
    getOuterXml(metadataName, xmlAttributes) {
        const xmlDecl = '<?xml version="1.0" encoding="UTF-8"?>';
        const attributes = XmlMetadataDocument.getXmlAttributesString(xmlAttributes);
        const rootElement = `<${metadataName}${attributes}/>`;
        return `${xmlDecl}${rootElement}`;
    }
    static getXmlAttributesString(xmlAttributes) {
        if (xmlAttributes) {
            return xmlAttributes
                .filter((attribute) => attribute.nodeName && attribute.nodeValue)
                .reduce((accumulatedString, attribute) => `${accumulatedString} ${attribute.nodeName}="${attribute.nodeValue}"`, '');
        }
        return '';
    }
}
exports.XmlMetadataDocument = XmlMetadataDocument;

//# sourceMappingURL=xmlMetadataDocument.js.map
