"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataTypeCache = exports.MetadataTypeFactory = void 0;
const path = require("path");
const core_1 = require("@salesforce/core");
const Messages = require("../../lib/messages");
const sharingRulesMetadataType_1 = require("./metadataTypeImpl/sharingRulesMetadataType");
const auraDefinitionBundleMetadataType_1 = require("./metadataTypeImpl/auraDefinitionBundleMetadataType");
const customObjectSubtypeMetadataType_1 = require("./metadataTypeImpl/customObjectSubtypeMetadataType");
const defaultMetadataType_1 = require("./metadataTypeImpl/defaultMetadataType");
const customObjectTranslationSubtypeMetadataType_1 = require("./metadataTypeImpl/customObjectTranslationSubtypeMetadataType");
const customObjectTranslationMetadataType_1 = require("./metadataTypeImpl/customObjectTranslationMetadataType");
const customObjectMetadataType_1 = require("./metadataTypeImpl/customObjectMetadataType");
const customPageWeblinkMetadataType_1 = require("./metadataTypeImpl/customPageWeblinkMetadataType");
const documentMetadataType_1 = require("./metadataTypeImpl/documentMetadataType");
const inFolderMetadataType_1 = require("./metadataTypeImpl/inFolderMetadataType");
const folderMetadataType_1 = require("./metadataTypeImpl/folderMetadataType");
const lightningComponentBundleMetadataType_1 = require("./metadataTypeImpl/lightningComponentBundleMetadataType");
const waveTemplateBundleMetadataType_1 = require("./metadataTypeImpl/waveTemplateBundleMetadataType");
const territory2AndTerritory2RuleMetadataType_1 = require("./metadataTypeImpl/territory2AndTerritory2RuleMetadataType");
const territory2ModelMetadataType_1 = require("./metadataTypeImpl/territory2ModelMetadataType");
const samlSsoConfigMetadataType_1 = require("./metadataTypeImpl/samlSsoConfigMetadataType");
const duplicateRuleMetadataType_1 = require("./metadataTypeImpl/duplicateRuleMetadataType");
const staticResourceMetadataType_1 = require("./metadataTypeImpl/staticResourceMetadataType");
const nondecomposedTypesWithChildrenMetadataType_1 = require("./metadataTypeImpl/nondecomposedTypesWithChildrenMetadataType");
const apexClassMetadataType_1 = require("./metadataTypeImpl/apexClassMetadataType");
const customLabelsMetadataType_1 = require("./metadataTypeImpl/customLabelsMetadataType");
const flowDefinitionMetadataType_1 = require("./metadataTypeImpl/flowDefinitionMetadataType");
const flowMetadataType_1 = require("./metadataTypeImpl/flowMetadataType");
const experienceBundleMetadataType_1 = require("./metadataTypeImpl/experienceBundleMetadataType");
const botMetadataType_1 = require("./metadataTypeImpl/botMetadataType");
const botSubtypeMetadataType_1 = require("./metadataTypeImpl/botSubtypeMetadataType");
const workflowMetadataType_1 = require("./metadataTypeImpl/workflowMetadataType");
const dataMappingObjectDefinitionMetadataType_1 = require("./metadataTypeImpl/dataMappingObjectDefinitionMetadataType");
const dataMappingObjectDefinitionSubtypeMetadataType_1 = require("./metadataTypeImpl/dataMappingObjectDefinitionSubtypeMetadataType");
const messages = Messages();
class MetadataTypeFactory {
    static getMetadataTypeFromSourcePath(sourcePath, metadataRegistry) {
        if (MetadataTypeCache.sourcePaths.has(sourcePath)) {
            return MetadataTypeCache.sourcePaths.get(sourcePath);
        }
        const typeDefObj = metadataRegistry.getTypeDefinitionByFileName(sourcePath, true);
        if (typeDefObj) {
            const mdType = MetadataTypeFactory.getMetadataTypeFromMetadataName(typeDefObj.metadataName, metadataRegistry);
            MetadataTypeCache.sourcePaths.set(sourcePath, mdType);
            return mdType;
        }
        return null;
    }
    static getMetadataTypeFromFileProperty(fileProperty, metadataRegistry) {
        const typeDefObj = MetadataTypeFactory.getTypeDefObjFromFileProperty(fileProperty, metadataRegistry);
        if (!typeDefObj) {
            const errorMessage = messages.getMessage('metadataTypeNotSupported', [fileProperty.type, fileProperty.type]);
            throw core_1.SfError.wrap(errorMessage);
        }
        return MetadataTypeFactory.getMetadataTypeFromMetadataName(typeDefObj.metadataName, metadataRegistry);
    }
    /**
     * @param fileProperty - the mdapi file property
     * @param metadataRegistry
     * @returns {TypeDefObj}
     */
    static getTypeDefObjFromFileProperty(fileProperty, metadataRegistry) {
        const fullFileName = fileProperty.fileName;
        const typeDefObj = metadataRegistry.getTypeDefinitionByMetadataName(fileProperty.type);
        if (typeDefObj && typeDefObj.inFolder) {
            const metadataType = typeDefObj.metadataName.toLowerCase();
            const normalizedFullName = path.normalize(fileProperty.fullName);
            if (!fullFileName.endsWith(metadataType) && (metadataType === 'report' || metadataType === 'dashboard')) {
                return typeDefObj.folderTypeDef;
            }
            else if (normalizedFullName.split(path.sep).length === 1) {
                return typeDefObj.folderTypeDef;
            }
        }
        return typeDefObj;
    }
    static getAggregateMetadataType(metadataName, metadataRegistry) {
        const metadataType = MetadataTypeFactory.getMetadataTypeFromMetadataName(metadataName, metadataRegistry);
        const hasParentType = metadataType.getMetadataName() !== metadataType.getAggregateMetadataName();
        if (hasParentType) {
            return MetadataTypeFactory.getMetadataTypeFromMetadataName(metadataType.getAggregateMetadataName(), metadataRegistry);
        }
        return metadataType;
    }
    static getTypeDefName(metadataName) {
        let typeDefName;
        switch (metadataName) {
            case 'LightningComponentResource':
                typeDefName = 'LightningComponentBundle';
                break;
            case 'AuraDefinition':
                typeDefName = 'AuraDefinitionBundle';
                break;
            case 'ExperienceResource':
                typeDefName = 'ExperienceBundle';
                break;
            case 'CustomLabel':
            case 'AssignmentRule':
            case 'AutoResponseRule':
            case 'EscalationRule':
            case 'MatchingRule':
                typeDefName = `${metadataName}s`;
                break;
            case 'WorkflowFieldUpdate':
            case 'WorkflowKnowledgePublish':
            case 'WorkflowTask':
            case 'WorkflowAlert':
            case 'WorkflowSend':
            case 'WorkflowOutboundMessage':
            case 'WorkflowRule':
                typeDefName = 'Workflow';
                break;
            case 'SharingOwnerRule':
            case 'SharingCriteriaRule':
            case 'SharingGuestRule':
            case 'SharingTerritoryRule':
                typeDefName = 'SharingRules';
                break;
            default:
                typeDefName = metadataName;
        }
        return typeDefName;
    }
    static getMetadataTypeFromMetadataName(metadataName, metadataRegistry) {
        if (MetadataTypeCache.metadataNames.has(metadataName)) {
            return MetadataTypeCache.metadataNames.get(metadataName);
        }
        let metadataType;
        const typeDefObjs = metadataRegistry.getMetadataTypeDefs();
        const typeDefName = MetadataTypeFactory.getTypeDefName(metadataName);
        if (metadataRegistry.isSupported(typeDefName)) {
            const typeDefObj = metadataRegistry.getTypeDefinitionByMetadataName(typeDefName);
            if (typeDefObj) {
                if (typeDefObj.parent) {
                    switch (typeDefObj.parent.metadataName) {
                        case typeDefObjs.CustomObject.metadataName:
                            metadataType = new customObjectSubtypeMetadataType_1.CustomObjectSubtypeMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.CustomObjectTranslation.metadataName:
                            metadataType = new customObjectTranslationSubtypeMetadataType_1.CustomObjectTranslationSubtypeMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.Bot.metadataName:
                            metadataType = new botSubtypeMetadataType_1.BotSubtypeMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.DataMappingObjectDefinition.metadataName:
                            metadataType = new dataMappingObjectDefinitionSubtypeMetadataType_1.DataMappingObjectDefinitionSubtypeMetadataType(typeDefObj);
                            break;
                        default:
                            break;
                    }
                }
                if (typeDefName.endsWith('Folder')) {
                    metadataType = new folderMetadataType_1.FolderMetadataType(typeDefObj);
                }
                if (typeDefObj.inFolder && typeDefName !== typeDefObjs.Document.metadataName) {
                    metadataType = new inFolderMetadataType_1.InFolderMetadataType(typeDefObj);
                }
                if (!metadataType) {
                    switch (typeDefName) {
                        case typeDefObjs.ApexClass.metadataName:
                            metadataType = new apexClassMetadataType_1.ApexClassMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.CustomObject.metadataName:
                            metadataType = new customObjectMetadataType_1.CustomObjectMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.CustomObjectTranslation.metadataName:
                            metadataType = new customObjectTranslationMetadataType_1.CustomObjectTranslationMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.AuraDefinitionBundle.metadataName:
                            metadataType = new auraDefinitionBundleMetadataType_1.AuraDefinitionBundleMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.CustomPageWebLink.metadataName:
                            metadataType = new customPageWeblinkMetadataType_1.CustomPageWeblinkMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.Document.metadataName:
                            metadataType = new documentMetadataType_1.DocumentMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.LightningComponentBundle.metadataName:
                            metadataType = new lightningComponentBundleMetadataType_1.LightningComponentBundleMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.WaveTemplateBundle.metadataName:
                            metadataType = new waveTemplateBundleMetadataType_1.WaveTemplateBundleMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.Territory2.metadataName:
                        case typeDefObjs.Territory2Rule.metadataName:
                            metadataType = new territory2AndTerritory2RuleMetadataType_1.Territory2AndTerritory2RuleMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.Territory2Model.metadataName:
                            metadataType = new territory2ModelMetadataType_1.Territory2ModelMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.SamlSsoConfig.metadataName:
                            metadataType = new samlSsoConfigMetadataType_1.SamlSsoConfigMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.DuplicateRule.metadataName:
                            metadataType = new duplicateRuleMetadataType_1.DuplicateRuleMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.CustomLabels.metadataName:
                            metadataType = new customLabelsMetadataType_1.CustomLabelsMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.AssignmentRules.metadataName:
                        case typeDefObjs.AutoResponseRules.metadataName:
                        case typeDefObjs.EscalationRules.metadataName:
                        case typeDefObjs.MatchingRules.metadataName:
                            metadataType = new nondecomposedTypesWithChildrenMetadataType_1.NondecomposedTypesWithChildrenMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.Workflow.metadataName:
                            metadataType = new workflowMetadataType_1.WorkflowMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.SharingRules.metadataName:
                            metadataType = new sharingRulesMetadataType_1.SharingRulesMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.StaticResource.metadataName:
                            metadataType = new staticResourceMetadataType_1.StaticResourceMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.FlowDefinition.metadataName:
                            metadataType = new flowDefinitionMetadataType_1.FlowDefinitionMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.Flow.metadataName:
                            metadataType = new flowMetadataType_1.FlowMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.ExperienceBundle.metadataName:
                            metadataType = new experienceBundleMetadataType_1.ExperienceBundleMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.Bot.metadataName:
                            metadataType = new botMetadataType_1.BotMetadataType(typeDefObj);
                            break;
                        case typeDefObjs.DataMappingObjectDefinition.metadataName:
                            metadataType = new dataMappingObjectDefinitionMetadataType_1.DataMappingObjectDefinitionMetadataType(typeDefObj);
                            break;
                        default:
                            metadataType = new defaultMetadataType_1.DefaultMetadataType(typeDefObj);
                    }
                }
            }
        }
        MetadataTypeCache.metadataNames.set(metadataName, metadataType);
        return metadataType;
    }
    static getMetadataTypeFromMdapiPackagePath(packagePath, metadataRegistry) {
        if (MetadataTypeCache.mdapiPackagePaths.has(packagePath)) {
            return MetadataTypeCache.mdapiPackagePaths.get(packagePath);
        }
        const pathElements = packagePath.split(path.sep); // ["type-dir", ["container-dir",]] "file"
        let isFolderType;
        if (pathElements.length > 1) {
            // file level (or intermediate directory for a few types)
            const type = pathElements[0];
            const file = pathElements[pathElements.length - 1];
            const possibleTypeDefs = metadataRegistry.getTypeDefinitionsByDirectoryName(type);
            let typeDef;
            if (possibleTypeDefs.length === 1) {
                typeDef = possibleTypeDefs[0];
            }
            else {
                const inFolderType = possibleTypeDefs.find((_typeDef) => _typeDef.inFolder);
                if (inFolderType) {
                    isFolderType = inFolderType && pathElements.length === 2;
                    if (isFolderType) {
                        typeDef = inFolderType.folderTypeDef;
                    }
                    // reports nand dashboards could be nested in sub folders
                    else if (type === 'reports' && !file.endsWith('report')) {
                        typeDef = inFolderType.folderTypeDef;
                    }
                    else if (type === 'dashboards' && !file.endsWith('dashboard')) {
                        typeDef = inFolderType.folderTypeDef;
                    }
                    else {
                        typeDef = inFolderType;
                    }
                }
                else {
                    const extension = path.extname(packagePath).replace('.', '');
                    // eslint-disable-next-line @typescript-eslint/no-shadow
                    const matchingTypeDef = possibleTypeDefs.find((typeDef) => typeDef.ext === extension);
                    typeDef = matchingTypeDef || metadataRegistry.getTypeDefinitionByFileName(file);
                }
            }
            // Territory2 and Territory2Rule exist in the Territory2Model directory, but they are separate entities
            // so we need to reload the typeDef accordingly
            const isTerritory2Model = typeDef && typeDef.metadataName === metadataRegistry.getMetadataTypeDefs().Territory2Model.metadataName;
            if (isTerritory2Model && pathElements.length === 4) {
                // length of 4 signals a subtype of territory2Model
                const terrType = pathElements[2];
                if (terrType === metadataRegistry.getMetadataTypeDefs().Territory2.defaultDirectory) {
                    typeDef = metadataRegistry.getMetadataTypeDefs().Territory2;
                }
                else {
                    typeDef = metadataRegistry.getMetadataTypeDefs().Territory2Rule;
                }
            }
            const mdType = MetadataTypeFactory.getMetadataTypeFromMetadataName(typeDef.metadataName, metadataRegistry);
            MetadataTypeCache.mdapiPackagePaths.set(packagePath, mdType);
            return mdType;
        }
        return null;
    }
}
exports.MetadataTypeFactory = MetadataTypeFactory;
class MetadataTypeCache {
    static get sourcePaths() {
        return this._sourcePaths;
    }
    static set sourcePaths(newIndex) {
        this._sourcePaths = newIndex;
    }
    static get metadataNames() {
        return this._metadataNames;
    }
    static set metadataNames(newIndex) {
        this._metadataNames = newIndex;
    }
    static get mdapiPackagePaths() {
        return this._mdapiPackagePaths;
    }
    static set mdapiPackagePaths(newIndex) {
        this._mdapiPackagePaths = newIndex;
    }
    static clear() {
        MetadataTypeCache.sourcePaths = new Map();
        MetadataTypeCache.metadataNames = new Map();
        MetadataTypeCache.mdapiPackagePaths = new Map();
    }
}
exports.MetadataTypeCache = MetadataTypeCache;
MetadataTypeCache._sourcePaths = new Map();
MetadataTypeCache._metadataNames = new Map();
MetadataTypeCache._mdapiPackagePaths = new Map();

//# sourceMappingURL=metadataTypeFactory.js.map
