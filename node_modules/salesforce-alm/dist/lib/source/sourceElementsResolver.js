"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceElementsResolver = void 0;
const path = require("path");
const core_1 = require("@salesforce/core");
const sourceUtil_1 = require("./sourceUtil");
const manifestUtils_1 = require("./manifestUtils");
const parseManifestEntriesArray_1 = require("./parseManifestEntriesArray");
const metadataTypeFactory_1 = require("./metadataTypeFactory");
const aggregateSourceElements_1 = require("./aggregateSourceElements");
const MetadataRegistry = require("./metadataRegistry");
const aggregateSourceElement_1 = require("./aggregateSourceElement");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('salesforce-alm', 'source');
class SourceElementsResolver {
    constructor(org, sourceWorkSpaceAdapter) {
        this.sourceWorkSpaceAdapter = sourceWorkSpaceAdapter;
        this.org = org;
        this.logger = core_1.Logger.childFromRoot(this.constructor.name);
    }
    /**
     * Returns all AggregateSourceElements in the project that match entries
     * from a manifest.
     *
     * @param manifestPath - path to package.xml
     * @return {Map} aggregateSourceElements
     */
    async getSourceElementsFromManifest(manifestPath) {
        const typeNamePairs = await parseManifestEntriesArray_1.parseToManifestEntriesArray(manifestPath);
        const sourceElements = await this.sourceWorkSpaceAdapter.getAggregateSourceElements(false);
        return this.parseTypeNamePairs(typeNamePairs, sourceElements);
    }
    /**
     * Filters all AggregateSourceElements in the project based on manifest file entries.
     *
     * @param typeNamePairs - type name pairs from a manifest file
     * @param sourceElements - all AggregateSourceElements in the project
     * @return {Map} aggregateSoureElements
     */
    parseTypeNamePairs(typeNamePairs, sourceElements) {
        const aggregateSourceElements = new aggregateSourceElements_1.AggregateSourceElements();
        typeNamePairs.forEach((entry) => {
            let keyMetadataType = entry.type;
            const metadataType = metadataTypeFactory_1.MetadataTypeFactory.getMetadataTypeFromMetadataName(keyMetadataType, this.sourceWorkSpaceAdapter.metadataRegistry);
            if (!metadataType) {
                throw messages.createError('UnsupportedType', [keyMetadataType]);
            }
            const aggregateName = metadataType.getAggregateMetadataName();
            const hasParentType = metadataType.getMetadataName() !== aggregateName;
            if (metadataType['typeDefObj'].inFolder) {
                keyMetadataType = metadataType.getBaseTypeName();
            }
            if (entry.name.includes('*')) {
                if (hasParentType) {
                    // In this case we are dealing with a decomposed item, so reload using the parent name
                    keyMetadataType = aggregateName;
                }
                const filterKey = keyMetadataType.split('__')[0]; // Use only the metadata key since we want all metadata names.
                this.logger.debug(`Matching source with wildcard metadata: ${filterKey}`);
                const filteredASEs = sourceElements.filterSourceElementsByKey(filterKey, { fuzzy: true } // this allows (e.g.) Document type to match DocumentFolder, which we want.
                );
                aggregateSourceElements.merge(filteredASEs);
            }
            else {
                //
                // We can't call loadSourceElement() here because we have to match the key across
                // package directories.  E.g., a custom object can be defined in multiple package directories
                // and we need to return all matches from all package dirs based on a typeNamePair (i.e., key).
                //
                let filteredASEs;
                if (hasParentType) {
                    const parentFullName = metadataType.getAggregateFullNameFromWorkspaceFullName(entry.name);
                    const parentKey = aggregateSourceElement_1.AggregateSourceElement.getKeyFromMetadataNameAndFullName(aggregateName, parentFullName);
                    this.logger.debug(`Matching source with metadata: ${parentKey}__${keyMetadataType}.${entry.name}`);
                    const ase = sourceElements.findParentElement(parentKey, keyMetadataType, entry.name);
                    filteredASEs = new aggregateSourceElements_1.AggregateSourceElements();
                    if (ase) {
                        filteredASEs.setIn(ase.packageName, ase.getKey(), ase);
                    }
                }
                else {
                    this.logger.debug(`Matching source with metadata: ${keyMetadataType}.${entry.name}`);
                    filteredASEs = sourceElements.filterSourceElementsByKey(MetadataRegistry.getMetadataKey(keyMetadataType, entry.name), { fuzzy: true } // this allows (e.g.) Document type to match DocumentFolder, which we want.
                    );
                }
                aggregateSourceElements.merge(filteredASEs);
            }
        });
        return aggregateSourceElements;
    }
    /**
     *
     * @param options - any{}
     * @param aggregateSourceElements - any empty array of type aggregateSoureElements
     * @param tmpOutputDir
     */
    async getSourceElementsFromMetadata(options, aggregateSourceElements, tmpOutputDir) {
        tmpOutputDir = tmpOutputDir || (await sourceUtil_1.createOutputDir('decomposition'));
        const manifestPath = await manifestUtils_1.toManifest(this.org, options, tmpOutputDir);
        const isPathABundleError = path.extname(options.metadata).length > 0 && sourceUtil_1.containsMdBundle(options);
        if (isPathABundleError) {
            throw messages.createError('SourcePathInvalid', [options.metadata]);
        }
        if (manifestPath) {
            aggregateSourceElements = await this.getSourceElementsFromManifest(manifestPath);
        }
        else {
            throw messages.createError('failedToCreateManifest');
        }
        return aggregateSourceElements;
    }
}
exports.SourceElementsResolver = SourceElementsResolver;

//# sourceMappingURL=sourceElementsResolver.js.map
