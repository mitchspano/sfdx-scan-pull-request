import { Logger } from '@salesforce/core';
import { ForceIgnore } from '@salesforce/source-deploy-retrieve';
import { JsonMap, Nullable } from '@salesforce/ts-types';
import { AsyncCreatable } from '@salesforce/kit';
import { WorkspaceFileState, ReadableFileState } from './workspaceFileState';
import MetadataRegistry = require('./metadataRegistry');
import { Workspace } from './workspace';
declare type Filter = {
    changesOnly?: boolean;
    packageDirectory?: string;
    sourcePath?: string;
};
declare type PartiallyRequired<T, U extends keyof T> = Required<Pick<T, U>> & Partial<Omit<T, U>>;
export declare namespace SourcePathInfo {
    type BaseEntry = PartiallyRequired<Entry, 'sourcePath'>;
    interface Entry {
        changeTime: number;
        contentHash: string;
        deferContentHash: boolean;
        isArtifactRoot: boolean;
        isDirectory: boolean;
        isMetadataFile: boolean;
        isWorkspace: boolean;
        metadataType: string;
        modifiedTime: number;
        package: string;
        size: number;
        sourcePath: string;
        state: WorkspaceFileState;
    }
    type Json = Entry & JsonMap;
}
export declare class SourcePathInfo extends AsyncCreatable<SourcePathInfo.BaseEntry> implements SourcePathInfo.Entry {
    changeTime: number;
    contentHash: string;
    deferContentHash: boolean;
    isArtifactRoot: boolean;
    isDirectory: boolean;
    isMetadataFile: boolean;
    isWorkspace: boolean;
    metadataType: string;
    modifiedTime: number;
    package: string;
    size: number;
    sourcePath: string;
    state: WorkspaceFileState;
    constructor(options: SourcePathInfo.BaseEntry);
    protected init(): Promise<void>;
    /**
     * Return a clone of this SourcePathInfo, overriding specified properties.
     *
     * @param overrides SourcePathInfo properties that should override the cloned properties
     */
    clone(overrides?: Partial<SourcePathInfo.Entry>): Promise<SourcePathInfo>;
    /**
     * Initialize path info based on a path in the workspace
     */
    initFromPath(sourcePath: string, deferContentHash?: boolean): Promise<void>;
    computeContentHash(): Promise<void>;
    /**
     * If the source has been modified, return the path info for the change
     */
    getPendingPathInfo(): Promise<Nullable<SourcePathInfo>>;
    isDeleted(): boolean;
    isNew(): boolean;
    isChanged(): boolean;
    getState(): ReadableFileState;
    toJson(): SourcePathInfo.Json;
}
declare namespace SourcePathStatusManager {
    type Options = {
        org: any;
        isStateless?: boolean;
    };
}
/**
 * Manages a data model for tracking changes to local workspace paths
 */
export declare class SourcePathStatusManager extends AsyncCreatable<SourcePathStatusManager.Options> {
    logger: Logger;
    fileMoveLogger: Logger;
    org: any;
    isStateless: boolean;
    workspacePath: string;
    forceIgnore: ForceIgnore;
    workspace: Workspace;
    static metadataRegistry: MetadataRegistry;
    constructor(options: SourcePathStatusManager.Options);
    protected init(): Promise<void>;
    /**
     * Get path infos for the source workspace, applying any filters specified.
     */
    getSourcePathInfos(filter?: Filter): Promise<SourcePathInfo[]>;
    /**
     * Determine if the provided sourcePathInfo should be processed during a source action (deploy, retrieve, push, pull, convert)
     * A sourcePathInfo is INCLUDED if any of the following crietria are met:
     * 1. If the sourcePathInfo.sourcePath is nested under the package directory
     * 2. If the sourcePathInfo.sourcePath is the same or is nested under filter.sourcePath
     * 3. If the sourcePathInfo.sourcePath is NOT ignored in the .forceignore file
     */
    shouldIncludeSourcePathInfo(sourcePathInfo: SourcePathInfo, filter?: Filter): boolean;
    private processFileMoves;
    /**
     * Update the data model with changes
     */
    commitChangedPathInfos(sourcePathInfos: SourcePathInfo[]): Promise<void>;
    /**
     * Update data model for the given paths
     */
    updateInfosForPaths(updatedPaths: string[], deletedPaths: string[]): Promise<void>;
    backup(): Promise<void>;
    revert(): Promise<void>;
    /**
     * Get the path infos for source that has been updated in the given directory
     */
    private processChangedDirectory;
    /**
     * Get the path infos for newly added source
     */
    private getNewPathInfos;
}
export {};
