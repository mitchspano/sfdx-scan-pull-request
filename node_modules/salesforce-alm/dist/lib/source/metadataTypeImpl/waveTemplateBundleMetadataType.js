"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
/* eslint-disable @typescript-eslint/no-unused-vars */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WaveTemplateBundleMetadataType = void 0;
const path = require("path");
const bundlePathHelper_1 = require("../bundlePathHelper");
const PathUtil = require("../sourcePathUtil");
const Messages = require("../../messages");
const bundleMetadataType_1 = require("./bundleMetadataType");
const messages = Messages();
// Required file to represent WaveTemplateBundles definitions
const waveTemplateBundleDefinitionFile = 'template-info.json';
class WaveTemplateBundleMetadataType extends bundleMetadataType_1.BundleMetadataType {
    constructor(typeDefObj) {
        super(typeDefObj);
    }
    // Override
    getAggregateMetadataFilePathFromWorkspacePath(filePath) {
        // wave templates have no metadata file, so return the path to the bundle directory
        const bundleName = this.getAggregateFullNameFromFilePath(filePath);
        const pathToWaveTemplates = PathUtil.getPathToDir(filePath, this.typeDefObj.defaultDirectory);
        return path.join(pathToWaveTemplates, bundleName);
    }
    // Override
    getDefaultAggregateMetadataPath(fullName, defaultSourceDir, bundleFileProperties) {
        // If there is a bundle properties, and there is always only 0 or 1 values here, then check for additional
        // path details to include between the bundleName and fileName.
        const bundle = bundleFileProperties[0];
        if (bundle) {
            const name = bundle.fileName;
            const baseFileName = path.basename(name);
            const additionalPath = bundlePathHelper_1.BundlePathHelper.getExtendedBundlePath(name, fullName);
            if (additionalPath) {
                return path.join(defaultSourceDir, this.typeDefObj.defaultDirectory, fullName, additionalPath, baseFileName);
            }
            else {
                return path.join(defaultSourceDir, this.typeDefObj.defaultDirectory, fullName, baseFileName);
            }
        }
        else {
            return path.join(defaultSourceDir, this.typeDefObj.defaultDirectory, fullName);
        }
    }
    // Override
    getRetrievedMetadataPath(fileProperty, retrieveRoot, bundleFileProperties) {
        // This sets aggregateSourceElement.retrievedMetadataPath in sourceWorkspaceAdapter
        // used for the convert command.  Return null as this is supposed to represent the meta-xml file.
        return null;
    }
    isDefinitionFile(filePath, metadataRegistry) {
        // other bundle types have a file (.meta.xml file typically) that are used as a definition file.
        // For WaveTemplateBundle use the template-info.json file so this metadata is marked as a bundle
        const waveDefType = metadataRegistry.getWaveDefByFileName(filePath);
        if (waveDefType) {
            const fileName = path.basename(filePath);
            return fileName === waveTemplateBundleDefinitionFile;
        }
        return false;
    }
    // Override
    getOriginContentPathsForSourceConvert(metadataFilePath, workspaceVersion, unsupportedMimeTypes, forceIgnore) {
        // WaveTemplateBundles have no metadata files, so the metadataFilePath is the path to the bundle
        return Promise.resolve(bundlePathHelper_1.BundlePathHelper.getAllNestedBundleContentPaths(metadataFilePath, forceIgnore));
    }
    shouldGetMetadataTranslation() {
        return false;
    }
    getWorkspaceContentFilePath(metadataFilePath, retrievedContentFilePath) {
        const fileName = path.basename(retrievedContentFilePath);
        const bundleName = bundlePathHelper_1.BundlePathHelper.scanFilePathForAggregateFullName(metadataFilePath, this.typeDefObj.defaultDirectory);
        const metadataDir = path.dirname(metadataFilePath);
        // If there is an additional path in the retrieved content then check if it's already included in the metadata path, and if
        // not add it.
        const additionalPath = bundlePathHelper_1.BundlePathHelper.getExtendedBundlePath(retrievedContentFilePath, bundleName);
        if (additionalPath) {
            if (path.basename(metadataDir) !== path.basename(additionalPath)) {
                return path.join(metadataDir, additionalPath, fileName);
            }
        }
        return path.join(metadataDir, fileName);
    }
    sourceMemberFullNameConflictsWithWorkspaceFullName(sourceMemberFullName, workspaceFullName) {
        const aggregateSourceMemberName = this.getAggregateFullNameFromSourceMemberName(sourceMemberFullName);
        const aggregateFullName = this.getAggregateFullNameFromWorkspaceFullName(workspaceFullName);
        return aggregateSourceMemberName === aggregateFullName;
    }
    trackRemoteChangeForSourceMemberName(sourceMemberName) {
        // Wave Templates only report changes in sourcemember at the bundle level
        return true;
    }
    onlyDisplayOneConflictPerAggregate() {
        // Wave Templates behave similar to aura bundles, following same logic
        return true;
    }
    getDisplayPathForLocalConflict(workspaceFilePath) {
        return path.dirname(workspaceFilePath);
    }
    getAggregateFullNameFromMdapiPackagePath(mdapiPackagePath) {
        const pathElements = mdapiPackagePath.split(path.sep);
        return pathElements[1];
    }
    validateDeletedContentPath(deletedContentPath, contentPaths, metadataRegistry) {
        const wtTypeDef = metadataRegistry.getWaveDefByFileName(deletedContentPath);
        if (wtTypeDef && wtTypeDef.hasMetadata) {
            const otherWaveTemplateFilesExist = contentPaths.some((contentPath) => !contentPath.endsWith(wtTypeDef.fileSuffix));
            if (otherWaveTemplateFilesExist) {
                const err = new Error();
                err['message'] = messages.getMessage('MissingContentFile', deletedContentPath);
                err['name'] = 'Missing Content File';
                throw err;
            }
        }
    }
    parseSourceMemberForMetadataRetrieve(sourceMemberName, sourceMemberType, isNameObsolete) {
        const fullName = this.getAggregateFullNameFromSourceMemberName(sourceMemberName);
        return { fullName, type: sourceMemberType, isNameObsolete };
    }
    getMdapiFormattedContentFileName(originContentPath, aggregateFullName) {
        // WaveTemplateBundles bundles can have nested sub-directories.
        // In order to maintain the bundle structure in the mdapi formatted directory,
        // return the path from the bundle directory to the file
        const pathToBundle = PathUtil.getPathToDir(originContentPath, aggregateFullName);
        return path.relative(pathToBundle, originContentPath);
    }
}
exports.WaveTemplateBundleMetadataType = WaveTemplateBundleMetadataType;

//# sourceMappingURL=waveTemplateBundleMetadataType.js.map
