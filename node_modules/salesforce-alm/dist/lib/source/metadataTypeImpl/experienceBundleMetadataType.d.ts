import { TypeDefObj } from '../typeDefObj';
import { DefaultMetadataType } from './defaultMetadataType';
export declare class ExperienceBundleMetadataType extends DefaultMetadataType {
    CONTENT_FILE_FORMAT: string;
    static META_FILE_SUFFIX: string;
    constructor(typeDefObj: TypeDefObj);
    /**
     * During sfdx:source:push, given the meta file for the changed site, get all the files that needs to be pushed
     * if given metadataFilePath is of "baseDir/force-app/main/default/experiences/byo21-meta.xml"
     * we need to return the files in the bundle of the site corresponding to byo21-meta.xml meta file
     * ie., all the files in "baseDir/force-app/main/default/experiences/byo21" dir (while ignoring the ones in forceIgnore file)
     */
    getOriginContentPathsForSourceConvert(metadataFilePath: string, workspaceVersion: string, unsupportedMimeTypes: string[], forceIgnore: any): Promise<string[]>;
    /**
     * Get where the file will be placed in the temp mdDir dir
     *
     * @param originContentPath - origin path as in sfdx working dir
     * @param aggregateFullName
     * @param mdDir - temp folder path
     */
    getMdapiContentPathForSourceConvert(originContentPath: string, aggregateFullName: string, mdDir: string): string;
    getRelativeContentPath(contentPath: string): string;
    /**
     * Given a path to the file in local working env, we should return the name of the site
     * If its a meta file, we just strip the -meta.xml to get the siteName
     * if its a json file, we return the grandparent directory (site name)
     * Otherwise, we return fileName (site name)
     *
     * @param filePath
     */
    getAggregateFullNameFromFilePath(filePath: string): string;
    /**
     * Given a file, we need to return the corresponding site's meta file
     *
     * @param filePath
     */
    getAggregateMetadataFilePathFromWorkspacePath(filePath: any): string;
    getDefaultAggregateMetadataPath(fullName: string, defaultSourceDir: string, bundleFileProperties: any): string;
    getAggregateFullNameFromFileProperty(fileProperty: any, namespace: string): string;
    /**
     * The path of every file. Given the file location in base working dir of the meta file and
     * the temp location of a file of the corresponding site, we need to give where the file (in temp location) will sit in the
     * base working dir
     *
     * @param metadataFilePath
     * @param retrievedContentFilePath
     */
    getWorkspaceContentFilePath(metadataFilePath: any, retrievedContentFilePath: any): string;
    getRetrievedMetadataPath(fileProperty: any, retrieveRoot: string, bundleFileProperties: any): string;
    /**
     * A bundlPath is of format /unpackaged/experiences/{siteName}/{type}
     * We just need /unpackaged/experiences, which is where the -meta.xml lives
     *
     * @param bundlePath
     */
    stripBundlePath(bundlePath: any): string;
    static getContentFilePaths(metadataFilePath: string, forceIgnore: any): string[];
    /**
     * fullName is of the format {siteName}/{type}/{componentName-WithoutSuffix}
     * To get -meta.xml, we just need {siteName} as it is of the format {siteName}-meta.xml
     *
     * @param fullName
     */
    getMetaFileName(fullName: string): string;
    protected sourceMemberFullNameConflictsWithWorkspaceFullName(sourceMemberFullName: string, workspaceFullName: string): boolean;
    getAggregateFullNameFromSourceMemberName(sourceMemberName: string): string;
    trackRemoteChangeForSourceMemberName(sourceMemberName: string): boolean;
    sourceMemberFullNameCorrespondsWithWorkspaceFullName(sourceMemberFullName: string, workspaceFullName: string): boolean;
    getFullNameFromFilePath(filePath: string): string;
    static getMetadataFileExtWithSuffix(): string;
    mainContentFileExists(metadataFilePath: string): boolean;
}
