"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NondecomposedTypesWithChildrenMetadataType = void 0;
const defaultMetadataType_1 = require("./defaultMetadataType");
/**
 * Class to represent types that have childXmlNames, but are not decomposed
 * Since the child types are not decomposed into individual files in the workspace,
 * we do not have MetadataType representations for the child types themselves,
 * and any metadataType specific logic for those child types is handled in this class
 */
class NondecomposedTypesWithChildrenMetadataType extends defaultMetadataType_1.DefaultMetadataType {
    requiresIndividuallyAddressableMembersInPackage() {
        return true;
    }
    getAggregateFullNameFromSourceMemberName(sourceMemberName) {
        return sourceMemberName.split('.').length == 1 ? this.getMetadataName() : sourceMemberName.split('.')[0]; // if only passed the name, return the type
    }
    /**
     * @param {string} sourceMemberType - could be the name of the Nondecomposed type itself (i.e. EscalationRules) or
     * the name of a child type (i.e. Escalation Rule (singular))
     * @returns {string}
     */
    getDisplayNameForRemoteChange(sourceMemberType) {
        if (sourceMemberType !== this.typeDefObj.metadataName) {
            return sourceMemberType;
        }
        return this.typeDefObj.metadataName;
    }
    parseSourceMemberForMetadataRetrieve(sourceMemberName, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sourceMemberType, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    isNameObsolete) {
        const fullName = this.getAggregateFullNameFromSourceMemberName(sourceMemberName);
        // these types are not decomposed, so deletions of child types are part of changes to the larger parent container
        return { fullName, type: this.getMetadataName() };
    }
}
exports.NondecomposedTypesWithChildrenMetadataType = NondecomposedTypesWithChildrenMetadataType;

//# sourceMappingURL=nondecomposedTypesWithChildrenMetadataType.js.map
