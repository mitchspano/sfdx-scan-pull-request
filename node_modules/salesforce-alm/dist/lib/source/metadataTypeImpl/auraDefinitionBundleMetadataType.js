"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuraDefinitionBundleMetadataType = void 0;
const path = require("path");
const glob = require("glob");
const srcDevUtil = require("../../core/srcDevUtil");
const MetadataRegistry = require("../metadataRegistry");
const PathUtil = require("../sourcePathUtil");
const bundlePathHelper_1 = require("../bundlePathHelper");
const Messages = require("../../messages");
const bundleMetadataType_1 = require("./bundleMetadataType");
const messages = Messages();
class AuraDefinitionBundleMetadataType extends bundleMetadataType_1.BundleMetadataType {
    constructor(typeDefObj) {
        super(typeDefObj);
    }
    // Override
    getFullNameFromFilePath(filePath) {
        const bundleName = PathUtil.getParentDirectoryName(filePath);
        const fileName = PathUtil.removeMetadataFileExtFrom(path.basename(filePath));
        return path.join(bundleName, fileName);
    }
    // Override
    getAggregateFullNameFromFilePath(filePath) {
        return PathUtil.getParentDirectoryName(filePath);
    }
    getRetrievedMetadataPath(fileProperty, retrieveRoot, bundleFileProperties) {
        const bundlePath = path.dirname(fileProperty.fileName);
        const fileName = bundlePathHelper_1.BundlePathHelper.getMetadataFileNameFromBundleFileProperties(fileProperty.fullName, bundleFileProperties);
        const retrievedMetadataPath = path.join(retrieveRoot, bundlePath, fileName);
        if (srcDevUtil.pathExistsSync(retrievedMetadataPath)) {
            return retrievedMetadataPath;
        }
        return null;
        // W-3903546 older AuraDefinitionBundles do not require a -meta.xml file
    }
    // Override
    getOriginContentPathsForSourceConvert(metadataFilePath, workspaceVersion, unsupportedMimeTypes, forceIgnore) {
        const bundleDirPath = path.dirname(metadataFilePath);
        const bundlePaths = glob.sync(path.join(bundleDirPath, '*'));
        return Promise.resolve(bundlePaths.filter((bundlePath) => forceIgnore.accepts(bundlePath) && !bundlePath.endsWith(MetadataRegistry.getMetadataFileExt())));
    }
    sourceMemberFullNameConflictsWithWorkspaceFullName(sourceMemberFullName, workspaceFullName) {
        const aggregateSourceMemberName = this.getAggregateFullNameFromSourceMemberName(sourceMemberFullName);
        const aggregateFullName = this.getAggregateFullNameFromWorkspaceFullName(workspaceFullName);
        return aggregateSourceMemberName === aggregateFullName;
    }
    trackRemoteChangeForSourceMemberName(sourceMemberName) {
        // Whenever a component of an AuraBundle is modified in the scratch org, a SourceMember is created
        // at the bundle level and another is created for the changed component. Ignore the SourceMember created
        // for the bundle and track specific bundle component changes only.
        return sourceMemberName.split(path.sep).length > 1;
    }
    onlyDisplayOneConflictPerAggregate() {
        // Waiting on W-4389673 to support fine-grained push and pull of AuraDefinitionBundle components
        // Until they are supported, we only want to report one conflict entry per bundle
        return true;
    }
    getDisplayPathForLocalConflict(workspaceFilePath) {
        return path.dirname(workspaceFilePath);
    }
    getAggregateFullNameFromMdapiPackagePath(mdapiPackagePath) {
        const pathElements = mdapiPackagePath.split(path.sep);
        return pathElements[1];
    }
    validateDeletedContentPath(deletedContentPath, contentPaths, metadataRegistry) {
        // For Aura Bundles, if we are deleting the metadata file, but there are still other aura definitions present, we should throw an error
        const auraTypeDef = metadataRegistry.getLightningDefByFileName(deletedContentPath);
        if (auraTypeDef && auraTypeDef.hasMetadata) {
            const otherAuraFilesExist = contentPaths.some((contentPath) => !contentPath.endsWith(auraTypeDef.fileSuffix));
            if (otherAuraFilesExist) {
                const err = new Error();
                err['message'] = messages.getMessage('MissingContentFile', deletedContentPath);
                err['name'] = 'Missing Content File';
                throw err;
            }
        }
    }
    parseSourceMemberForMetadataRetrieve(sourceMemberName, sourceMemberType, isNameObsolete) {
        sourceMemberName = PathUtil.replaceForwardSlashes(sourceMemberName);
        return {
            fullName: sourceMemberName,
            type: sourceMemberType,
            isNameObsolete,
        };
    }
    /**
     * Returns the fileProperty object for the Aura definition metadata file corresponding to the given filePropertyFileName
     *
     * @param retrieveRoot
     * @param filePropertyFileName
     * @returns {any}
     */
    static getCorrespondingAuraDefinitionFileProperty(retrieveRoot, filePropertyFileName, auraMetadataName, metadataRegistry) {
        const bundleDirPath = path.join(retrieveRoot, path.dirname(filePropertyFileName));
        const bundlePaths = glob.sync(path.join(bundleDirPath, '*'));
        const bundleDefinitionPath = bundlePaths.find((bundlePath) => AuraDefinitionBundleMetadataType.prototype.isDefinitionFile(bundlePath, metadataRegistry));
        const auraDefinitionFileProperty = {
            type: auraMetadataName,
            fileName: path.relative(retrieveRoot, bundleDefinitionPath),
            fullName: path.basename(bundleDefinitionPath, path.extname(bundleDefinitionPath)),
        };
        return auraDefinitionFileProperty;
    }
    isDefinitionFile(filePath, metadataRegistry) {
        const lightningDefType = metadataRegistry.getLightningDefByFileName(filePath);
        if (lightningDefType) {
            const isDefinitionFile = lightningDefType.hasMetadata;
            return isDefinitionFile;
        }
        return false;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    shouldDeleteWorkspaceAggregate(metadataType) {
        // Handle deletes of AuraDefinitionBundles at the subcomponent level because
        // SourceMembers are created for each subcomponent
        return false;
    }
}
exports.AuraDefinitionBundleMetadataType = AuraDefinitionBundleMetadataType;

//# sourceMappingURL=auraDefinitionBundleMetadataType.js.map
