"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
/* eslint-disable @typescript-eslint/no-unused-vars */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExperienceBundleMetadataType = void 0;
const PathUtil = require("../sourcePathUtil");
const almError = require("../../core/almError");
const defaultMetadataType_1 = require("./defaultMetadataType");
const path = require('path');
const glob = require('glob');
const srcDevUtil = require('../../core/srcDevUtil');
const MetadataRegistry = require('../metadataRegistry');
class ExperienceBundleMetadataType extends defaultMetadataType_1.DefaultMetadataType {
    constructor(typeDefObj) {
        super(typeDefObj);
        this.CONTENT_FILE_FORMAT = '.json';
    }
    /**
     * During sfdx:source:push, given the meta file for the changed site, get all the files that needs to be pushed
     * if given metadataFilePath is of "baseDir/force-app/main/default/experiences/byo21-meta.xml"
     * we need to return the files in the bundle of the site corresponding to byo21-meta.xml meta file
     * ie., all the files in "baseDir/force-app/main/default/experiences/byo21" dir (while ignoring the ones in forceIgnore file)
     */
    getOriginContentPathsForSourceConvert(metadataFilePath, workspaceVersion, unsupportedMimeTypes, forceIgnore) {
        return Promise.resolve(ExperienceBundleMetadataType.getContentFilePaths(metadataFilePath, forceIgnore));
    }
    /**
     * Get where the file will be placed in the temp mdDir dir
     *
     * @param originContentPath - origin path as in sfdx working dir
     * @param aggregateFullName
     * @param mdDir - temp folder path
     */
    getMdapiContentPathForSourceConvert(originContentPath, aggregateFullName, mdDir) {
        const mdapiSourceDir = this.getPathToMdapiSourceDir(aggregateFullName, mdDir);
        const relativePathDir = this.getRelativeContentPath(originContentPath);
        return this.getMdapiFormattedContentPath(mdapiSourceDir, relativePathDir);
    }
    getRelativeContentPath(contentPath) {
        return MetadataRegistry.splitOnDirName(this.typeDefObj.defaultDirectory, contentPath)[1];
    }
    /**
     * Given a path to the file in local working env, we should return the name of the site
     * If its a meta file, we just strip the -meta.xml to get the siteName
     * if its a json file, we return the grandparent directory (site name)
     * Otherwise, we return fileName (site name)
     *
     * @param filePath
     */
    getAggregateFullNameFromFilePath(filePath) {
        if (filePath.endsWith(ExperienceBundleMetadataType.getMetadataFileExtWithSuffix())) {
            // meta file
            const fileDir = filePath.split(path.sep);
            return fileDir[fileDir.length - 1].split(ExperienceBundleMetadataType.getMetadataFileExtWithSuffix())[0];
        }
        else if (path.extname(filePath) === this.CONTENT_FILE_FORMAT) {
            // content file (json)
            return PathUtil.getGrandparentDirectoryName(filePath);
        }
        // a path to the site dir
        return PathUtil.getFileName(filePath);
    }
    /**
     * Given a file, we need to return the corresponding site's meta file
     *
     * @param filePath
     */
    getAggregateMetadataFilePathFromWorkspacePath(filePath) {
        if (filePath.endsWith(ExperienceBundleMetadataType.getMetadataFileExtWithSuffix())) {
            return filePath;
        }
        const fileBrokenPaths = MetadataRegistry.splitOnDirName(this.typeDefObj.defaultDirectory, filePath);
        const metaXmlFileName = this.getMetaFileName(fileBrokenPaths[1]);
        return path.join(fileBrokenPaths[0], this.typeDefObj.defaultDirectory, metaXmlFileName);
    }
    getDefaultAggregateMetadataPath(fullName, defaultSourceDir, bundleFileProperties) {
        return path.join(defaultSourceDir, this.typeDefObj.defaultDirectory, this.getMetaFileName(fullName));
    }
    getAggregateFullNameFromFileProperty(fileProperty, namespace) {
        return PathUtil.getGrandparentDirectoryName(fileProperty.fileName);
    }
    /**
     * The path of every file. Given the file location in base working dir of the meta file and
     * the temp location of a file of the corresponding site, we need to give where the file (in temp location) will sit in the
     * base working dir
     *
     * @param metadataFilePath
     * @param retrievedContentFilePath
     */
    getWorkspaceContentFilePath(metadataFilePath, retrievedContentFilePath) {
        const workspaceDir = path.dirname(metadataFilePath);
        const fileName = MetadataRegistry.splitOnDirName(this.typeDefObj.defaultDirectory, retrievedContentFilePath)[1];
        return path.join(workspaceDir, fileName);
    }
    getRetrievedMetadataPath(fileProperty, retrieveRoot, bundleFileProperties) {
        const bundlePath = this.stripBundlePath(path.dirname(fileProperty.fileName));
        // Get the site name from the given JSON file path by returning the grandparent directory (site name)
        const siteName = PathUtil.getGrandparentDirectoryName(fileProperty.fileName);
        const retrievedMetadataPath = path.join(retrieveRoot, bundlePath, this.getMetaFileName(siteName));
        if (srcDevUtil.pathExistsSync(retrievedMetadataPath)) {
            return retrievedMetadataPath;
        }
        else {
            throw almError('MissingMetadataFile', retrievedMetadataPath);
        }
    }
    /**
     * A bundlPath is of format /unpackaged/experiences/{siteName}/{type}
     * We just need /unpackaged/experiences, which is where the -meta.xml lives
     *
     * @param bundlePath
     */
    stripBundlePath(bundlePath) {
        const folderPath = bundlePath.split(path.sep);
        return path.join(folderPath[0], folderPath[1]);
    }
    static getContentFilePaths(metadataFilePath, forceIgnore) {
        const fileName = path.basename(metadataFilePath);
        const dirName = fileName.split(ExperienceBundleMetadataType.getMetadataFileExtWithSuffix())[0];
        const bundlePaths = glob.sync(path.join(path.dirname(metadataFilePath), dirName, '**'), { nodir: true });
        // Return normalized paths depending on the os
        return bundlePaths
            .map((filePath) => path.normalize(filePath))
            .filter((bundlePath) => forceIgnore.accepts(bundlePath));
    }
    /**
     * fullName is of the format {siteName}/{type}/{componentName-WithoutSuffix}
     * To get -meta.xml, we just need {siteName} as it is of the format {siteName}-meta.xml
     *
     * @param fullName
     */
    getMetaFileName(fullName) {
        if (fullName.startsWith(path.sep)) {
            fullName = fullName.slice(1);
        }
        const bundleName = fullName.split(path.sep)[0];
        return `${path.basename(bundleName)}${ExperienceBundleMetadataType.getMetadataFileExtWithSuffix()}`;
    }
    sourceMemberFullNameConflictsWithWorkspaceFullName(sourceMemberFullName, workspaceFullName) {
        return (PathUtil.getGrandparentDirectoryName(sourceMemberFullName) ===
            PathUtil.getGrandparentDirectoryName(workspaceFullName));
    }
    getAggregateFullNameFromSourceMemberName(sourceMemberName) {
        return sourceMemberName.split(path.sep)[0];
    }
    trackRemoteChangeForSourceMemberName(sourceMemberName) {
        return sourceMemberName.split(path.sep).length > 1;
    }
    sourceMemberFullNameCorrespondsWithWorkspaceFullName(sourceMemberFullName, workspaceFullName) {
        return sourceMemberFullName === workspaceFullName;
    }
    getFullNameFromFilePath(filePath) {
        const grandParentBundleName = PathUtil.getGrandparentDirectoryName(filePath);
        const bundleName = PathUtil.getParentDirectoryName(filePath);
        const fileName = PathUtil.removeMetadataFileExtFrom(path.basename(filePath));
        return path.join(grandParentBundleName, bundleName, fileName);
    }
    static getMetadataFileExtWithSuffix() {
        return `${ExperienceBundleMetadataType.META_FILE_SUFFIX}${MetadataRegistry.getMetadataFileExt()}`;
    }
    mainContentFileExists(metadataFilePath) {
        return srcDevUtil.pathExistsSync(metadataFilePath);
    }
}
exports.ExperienceBundleMetadataType = ExperienceBundleMetadataType;
ExperienceBundleMetadataType.META_FILE_SUFFIX = '.site';

//# sourceMappingURL=experienceBundleMetadataType.js.map
