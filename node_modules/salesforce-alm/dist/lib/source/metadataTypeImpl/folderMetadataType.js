"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FolderMetadataType = void 0;
const path = require("path");
const MetadataRegistry = require("../metadataRegistry");
const srcDevUtil = require("../../core/srcDevUtil");
const workspaceFileState_1 = require("../workspaceFileState");
const PathUtil = require("../sourcePathUtil");
const defaultMetadataType_1 = require("./defaultMetadataType");
class FolderMetadataType extends defaultMetadataType_1.DefaultMetadataType {
    /** Return the path of the metadata file excluding the metadatatype folder. It also appends the metadata file extension : -meta.xml
     *
     * @param metadataFilePath - The full path of the metadata file including the workspace  and the metadatatype extension. eg : projectPath/force-app/main/default/reports/Parent/child.reportFolder-meta.xml
     * Returns : Parent/child-meta.xml
     */
    getMdapiFormattedMetadataFileName(metadataFilePath) {
        const filepathArr = metadataFilePath.split(path.sep);
        const startIndex = filepathArr.lastIndexOf(this.typeDefObj.defaultDirectory) + 1;
        const parentFolder = filepathArr.slice(startIndex, filepathArr.length - 1).join(path.sep);
        const fileName = `${path.basename(metadataFilePath).split('.')[0]}${MetadataRegistry.getMetadataFileExt()}`;
        return path.join(parentFolder, fileName);
    }
    /** Returns the relative path of the metadata file excluding the metatadata type folder
     *
     * @param filePath - the path to report folder including the workspace path.eg: projectPath/force-app/main/default/reports/Parent/Child.reportFolder-meta.xml
     * returns : Parent/Child
     */
    getAggregateFullNameFromFilePath(filePath) {
        const filepathArr = filePath.split(path.sep);
        const startIndex = filepathArr.lastIndexOf(this.typeDefObj.defaultDirectory) + 1;
        const parentFolder = filepathArr.slice(startIndex, filepathArr.length - 1).join(path.sep);
        const fileName = PathUtil.getFileName(filePath);
        return path.join(parentFolder, fileName);
    }
    /** Returns the path of the folder provided for metadata conversion, eg : Users/test/projectName/path provided for MDAPI conversion.
     *
     * @param retrieveRoot
     * @param fileProperty
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getRetrievedMetadataPath(fileProperty, retrieveRoot, bundleFileProperties) {
        let fileName;
        if (fileProperty.fileName.endsWith(MetadataRegistry.getMetadataFileExt())) {
            fileName = fileProperty.fileName;
        }
        else {
            fileName = `${fileProperty.fileName}${MetadataRegistry.getMetadataFileExt()}`;
        }
        const retrievedMetadataPath = path.join(retrieveRoot, fileName);
        return this.validateRetrievedMetadataPathExists(retrievedMetadataPath);
    }
    /** Returns the path of the folder excluding the metadatatype
     *
     * @param mdapiPackagePath - includes the path from the metadatype to the folder.eg : reports/ParentFolder/childFolder, returns : ParentFolder/childFolder
     */
    getAggregateFullNameFromMdapiPackagePath(mdapiPackagePath) {
        const pathElements = mdapiPackagePath.split(path.sep);
        const fullName = pathElements.slice(1, pathElements.length - 1).join(path.sep);
        const fileName = PathUtil.getFileName(mdapiPackagePath);
        return path.join(fullName, fileName);
    }
    static createEmptyFolder(workspaceElements, metadataFilePath, ext) {
        if (FolderMetadataType.isCreatingNewFolder(workspaceElements, metadataFilePath)) {
            const folderExtensionIndex = metadataFilePath.indexOf(`.${ext}${MetadataRegistry.getMetadataFileExt()}`);
            const folderPath = metadataFilePath.substring(0, folderExtensionIndex);
            if (!srcDevUtil.pathExistsSync(folderPath)) {
                srcDevUtil.ensureDirectoryExistsSync(folderPath);
                return folderPath;
            }
        }
        return null;
    }
    /**
     * Returns true if a new folder type is being created; false if a folder type is being deleted or changed
     *
     * @param workspaceElements
     * @param {string} metadataFilePath
     * @returns {boolean}
     */
    static isCreatingNewFolder(workspaceElements, metadataFilePath) {
        const metadataFileElement = workspaceElements.find((workspaceElement) => workspaceElement.getSourcePath() === metadataFilePath);
        if (metadataFileElement) {
            return metadataFileElement.getState() === workspaceFileState_1.WorkspaceFileState.NEW;
        }
        return false;
    }
    isFolderType() {
        return true;
    }
}
exports.FolderMetadataType = FolderMetadataType;

//# sourceMappingURL=folderMetadataType.js.map
