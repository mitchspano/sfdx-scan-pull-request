import { TypeDefObj } from '../typeDefObj';
import { BundleMetadataType } from './bundleMetadataType';
export declare class AuraDefinitionBundleMetadataType extends BundleMetadataType {
    constructor(typeDefObj: TypeDefObj);
    getFullNameFromFilePath(filePath: string): string;
    getAggregateFullNameFromFilePath(filePath: string): string;
    getRetrievedMetadataPath(fileProperty: any, retrieveRoot: string, bundleFileProperties: any): string;
    getOriginContentPathsForSourceConvert(metadataFilePath: string, workspaceVersion: string, unsupportedMimeTypes: string[], forceIgnore: any): Promise<string[]>;
    protected sourceMemberFullNameConflictsWithWorkspaceFullName(sourceMemberFullName: string, workspaceFullName: string): boolean;
    trackRemoteChangeForSourceMemberName(sourceMemberName: string): boolean;
    onlyDisplayOneConflictPerAggregate(): boolean;
    getDisplayPathForLocalConflict(workspaceFilePath: string): string;
    getAggregateFullNameFromMdapiPackagePath(mdapiPackagePath: string): string;
    validateDeletedContentPath(deletedContentPath: string, contentPaths: string[], metadataRegistry: any): void;
    parseSourceMemberForMetadataRetrieve(sourceMemberName: string, sourceMemberType: string, isNameObsolete: boolean): any;
    /**
     * Returns the fileProperty object for the Aura definition metadata file corresponding to the given filePropertyFileName
     *
     * @param retrieveRoot
     * @param filePropertyFileName
     * @returns {any}
     */
    static getCorrespondingAuraDefinitionFileProperty(retrieveRoot: string, filePropertyFileName: string, auraMetadataName: string, metadataRegistry: any): any;
    isDefinitionFile(filePath: any, metadataRegistry: any): boolean;
    shouldDeleteWorkspaceAggregate(metadataType: string): boolean;
}
