"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonDecomposedContentStrategy = void 0;
const path = require("path");
const fs = require("fs-extra");
const MetadataRegistry = require("../metadataRegistry");
const srcDevUtil = require("../../core/srcDevUtil");
const metadataTypeFactory_1 = require("../metadataTypeFactory");
const sourceUtil_1 = require("../sourceUtil");
/**
 *  Content strategy for content files that do not require decomposition e.g. ApexClass
 */
class NonDecomposedContentStrategy {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    constructor(metadataType, metadataRegistry, workspaceVersion) {
        this.metadataType = metadataType;
        this.metadataRegistry = metadataRegistry;
    }
    getContentPaths(metadataFilePath) {
        const metadataType = metadataTypeFactory_1.MetadataTypeFactory.getMetadataTypeFromSourcePath(metadataFilePath, this.metadataRegistry);
        const aggregateFullName = metadataType.getAggregateFullNameFromFilePath(metadataFilePath);
        const workspaceDir = path.dirname(metadataFilePath);
        const directoryItems = srcDevUtil.getDirectoryItems(workspaceDir, true, true);
        return directoryItems.filter((directoryItem) => {
            const itemFullName = metadataType.getAggregateFullNameFromFilePath(directoryItem);
            return (!directoryItem.startsWith('.') &&
                !directoryItem.endsWith(MetadataRegistry.getMetadataFileExt()) &&
                aggregateFullName === itemFullName);
        });
    }
    async saveContent(metadataFilePath, retrievedContentFilePaths, retrievedMetadataFilePath, createDuplicates, unsupportedMimeTypes, forceoverwrite = false) {
        const newPaths = [];
        const updatedPaths = [];
        const deletedPaths = [];
        const dupPaths = [];
        const metadataType = metadataTypeFactory_1.MetadataTypeFactory.getMetadataTypeFromSourcePath(metadataFilePath, this.metadataRegistry);
        for (const retrievedContentFilePath of retrievedContentFilePaths) {
            const workspaceContentFilePath = metadataType.getWorkspaceContentFilePath(metadataFilePath, retrievedContentFilePath);
            if (srcDevUtil.pathExistsSync(workspaceContentFilePath)) {
                const equalFileCheck = await sourceUtil_1.areFilesEqual(retrievedContentFilePath, workspaceContentFilePath);
                if (forceoverwrite || !equalFileCheck) {
                    if (createDuplicates) {
                        const dupPath = workspaceContentFilePath + '.dup';
                        fs.copySync(retrievedContentFilePath, dupPath);
                        dupPaths.push(dupPath);
                    }
                    else {
                        fs.copySync(retrievedContentFilePath, workspaceContentFilePath);
                        updatedPaths.push(workspaceContentFilePath);
                    }
                }
            }
            else {
                fs.copySync(retrievedContentFilePath, workspaceContentFilePath);
                newPaths.push(workspaceContentFilePath);
            }
        }
        return [newPaths, updatedPaths, deletedPaths, dupPaths];
    }
}
exports.NonDecomposedContentStrategy = NonDecomposedContentStrategy;

//# sourceMappingURL=nonDecomposedContentStrategy.js.map
