"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExperienceBundleContentStrategy = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const experienceBundleMetadataType_1 = require("../metadataTypeImpl/experienceBundleMetadataType");
const nonDecomposedContentStrategy_1 = require("./nonDecomposedContentStrategy");
const srcDevUtil = require('../../core/srcDevUtil');
/**
 * Works on top of NonDecomposedContentStrategy with special logic to handle delete
 */
class ExperienceBundleContentStrategy extends nonDecomposedContentStrategy_1.NonDecomposedContentStrategy {
    constructor(metadataType, metadataRegistry, workspaceVersion) {
        super(metadataType, metadataRegistry, workspaceVersion);
        this.forceIgnore = source_deploy_retrieve_1.ForceIgnore.findAndCreate(core_1.SfProject.resolveProjectPathSync());
    }
    /**
     * If there is a file in existing path and if it didn't get returned in the MD-retrieve, then we assume it is deleted
     * Since, we need a list of all files from retrieve to compare we cannot use MetadataType#getWorkspaceElementsToDelete()
     */
    async saveContent(metadataFilePath, retrievedContentFilePaths, retrievedMetadataFilePath, createDuplicates, unsupportedMimeTypes, forceoverwrite = false) {
        const existingFiles = experienceBundleMetadataType_1.ExperienceBundleMetadataType.getContentFilePaths(metadataFilePath, this.forceIgnore);
        const [newPaths, updatedPaths, deletedPaths, dupPaths] = await super.saveContent(metadataFilePath, retrievedContentFilePaths, retrievedMetadataFilePath, createDuplicates, unsupportedMimeTypes, forceoverwrite);
        const relativeRetrievedPaths = retrievedContentFilePaths.map((path) => this.metadataType.getRelativeContentPath(path));
        existingFiles.forEach((path) => {
            const relativePath = this.metadataType.getRelativeContentPath(path);
            if (!relativeRetrievedPaths.includes(relativePath)) {
                srcDevUtil.deleteIfExistsSync(path);
                deletedPaths.push(path);
            }
        });
        return [newPaths, updatedPaths, deletedPaths, dupPaths];
    }
}
exports.ExperienceBundleContentStrategy = ExperienceBundleContentStrategy;

//# sourceMappingURL=experienceBundleContentStrategy.js.map
