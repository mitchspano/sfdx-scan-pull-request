"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StaticResourceContentStrategy = void 0;
const staticResource_1 = require("./staticResource");
class StaticResourceContentStrategy {
    constructor(metadataType, metadataRegistry, workspaceVersion) {
        this.metadataType = metadataType;
        this.metadataRegistry = metadataRegistry;
        this.workspaceVersion = workspaceVersion;
    }
    getContentPaths(metadataFilePath) {
        const staticResource = new staticResource_1.StaticResource(metadataFilePath, this.metadataType, this.workspaceVersion);
        return staticResource.getContentPaths();
    }
    async saveContent(metadataFilePath, retrievedContentFilePaths, retrievedMetadataFilePath, createDuplicates, unsupportedMimeTypes, forceoverwrite = false) {
        const newPaths = [];
        const staticResource = new staticResource_1.StaticResource(metadataFilePath, this.metadataType, this.workspaceVersion, retrievedMetadataFilePath, unsupportedMimeTypes);
        const [updatedPaths, duplicatePaths, deletedPaths] = await staticResource.saveResource(retrievedContentFilePaths[0], createDuplicates, forceoverwrite);
        return [newPaths, updatedPaths, deletedPaths, duplicatePaths];
    }
}
exports.StaticResourceContentStrategy = StaticResourceContentStrategy;

//# sourceMappingURL=staticResourceContentStrategy.js.map
