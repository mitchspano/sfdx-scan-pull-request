"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.VirtualDecompositionCommitStrategy = void 0;
// Node
const fs = require("fs");
const util = require("util");
const fineGrainTrackingCommitStrategy_1 = require("./fineGrainTrackingCommitStrategy");
/**
 * When we don't have fine grain tracking we most likely aren't decomposing into "real" (mdapi addressable) metadata entities.
 * In these virtual decomposition cases deletions become the responsibility of the decomposition.
 */
class VirtualDecompositionCommitStrategy extends fineGrainTrackingCommitStrategy_1.FineGrainTrackingCommitStrategy {
    constructor(decompositionConfig) {
        super(decompositionConfig);
    }
    async commit(documents, existingPaths, createDuplicates, forceoverwrite = false) {
        let newPaths;
        let deletedPaths;
        let updatedPaths;
        let dupPaths = [];
        [newPaths, updatedPaths, deletedPaths, dupPaths] = await super.commit(documents, existingPaths, createDuplicates /** generateDuplicates */, forceoverwrite);
        deletedPaths = this.getDeletedPaths(documents, existingPaths); // No fine grain tracking to help us here.
        deletedPaths.map((deletedPath) => fs.unlinkSync(deletedPath));
        return [newPaths, updatedPaths, deletedPaths, dupPaths];
    }
    getDeletedPaths(documents, existingPaths) {
        return existingPaths.reduce((deletedPaths, existingPath) => {
            if (util.isNullOrUndefined(documents.get(existingPath))) {
                deletedPaths.push(existingPath);
            }
            return deletedPaths;
        }, []);
    }
}
exports.VirtualDecompositionCommitStrategy = VirtualDecompositionCommitStrategy;

//# sourceMappingURL=virtualDecompositionCommitStrategy.js.map
