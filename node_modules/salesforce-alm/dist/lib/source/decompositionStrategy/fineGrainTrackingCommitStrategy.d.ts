import { MetadataDocument } from '../metadataDocument';
import { DecompositionConfig } from './decompositionConfig';
import { DecompositionCommitStrategy } from './decompositionCommitStrategy';
/**
 * This strategy implementation writes updated files (when contents are different),
 * and new files. No attempt is made to delete anything because with fine grain tracking
 * the deletions should be happening independent of the decomposition.
 */
export declare class FineGrainTrackingCommitStrategy implements DecompositionCommitStrategy {
    decompositionConfig: DecompositionConfig;
    constructor(decompositionConfig: DecompositionConfig);
    commit(documents: Map<string, MetadataDocument>, existingPaths: string[], createDuplicates: boolean, forceoverwrite?: boolean): Promise<[string[], string[], string[], string[]]>;
    private categorizePaths;
    /**
     * We parse and serialize both sides of the comparison so that we are comparing apples to apples.
     * This eliminated problems with whitespace, eg, but won't help us with reordering.
     * At worst we'll update the fs unnecessarily if the files are semantically equivalent
     * but perceived to be different. It's not the end of the world.
     *
     * @param filePath path to the existing file
     * @param document the parsed version of the new contents
     * @param documentFactory a factory to acquire a new document of the appropriate type for serialization
     * @returns {boolean} <code>true</code> if updated
     */
    private static isUpdatedFile;
}
