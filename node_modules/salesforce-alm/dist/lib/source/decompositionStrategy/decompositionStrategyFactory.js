"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DecompositionStrategyFactory = void 0;
const staticResourceContentStrategy_1 = require("./staticResourceContentStrategy");
const describeMetadataDecomposition_1 = require("./describeMetadataDecomposition");
const folderPerSubtypeWorkspaceDecomposition_1 = require("./folderPerSubtypeWorkspaceDecomposition");
const fineGrainTrackingCommitStrategy_1 = require("./fineGrainTrackingCommitStrategy");
const virtualDecompositionCommitStrategy_1 = require("./virtualDecompositionCommitStrategy");
const nonDecomposedWorkspaceStrategy_1 = require("./nonDecomposedWorkspaceStrategy");
const nonDecomposedContentStrategy_1 = require("./nonDecomposedContentStrategy");
const nonDecomposedMetadataStrategy_1 = require("./nonDecomposedMetadataStrategy");
const inFolderMetadataWorkspaceDecomposition_1 = require("./inFolderMetadataWorkspaceDecomposition");
const experienceBundleContentStrategy_1 = require("./experienceBundleContentStrategy");
/**
 * Factory to instantiate a decomposition strategy given the strategy name.
 * Hopefully we will get a better DI infrastructure at some point.
 */
class DecompositionStrategyFactory {
    static newDecompositionStrategy(config) {
        if (config.strategy === 'describeMetadata') {
            return new describeMetadataDecomposition_1.DescribeMetadataDecomposition(config);
        }
        else if (config.strategy === 'nonDecomposed') {
            return new nonDecomposedMetadataStrategy_1.NonDecomposedMetadataStrategy(config);
        }
        return new nonDecomposedMetadataStrategy_1.NonDecomposedMetadataStrategy(config); // default
    }
    static newDecompositionWorkspaceStrategy(config) {
        if (config.workspaceStrategy === 'folderPerSubtype') {
            return new folderPerSubtypeWorkspaceDecomposition_1.FolderPerSubtypeWorkspaceDecomposition(config);
        }
        if (config.workspaceStrategy === 'inFolderMetadataType') {
            return new inFolderMetadataWorkspaceDecomposition_1.InFolderMetadataWorkspaceDecomposition();
        }
        if (config.workspaceStrategy === 'nonDecomposed') {
            return new nonDecomposedWorkspaceStrategy_1.NonDecomposedWorkspaceStrategy();
        }
        return new folderPerSubtypeWorkspaceDecomposition_1.FolderPerSubtypeWorkspaceDecomposition(config); // default
    }
    static newDecompositionCommitStrategy(config) {
        if (config.commitStrategy === 'fineGrainTracking') {
            return new fineGrainTrackingCommitStrategy_1.FineGrainTrackingCommitStrategy(config);
        }
        if (config.commitStrategy === 'virtualDecomposition') {
            return new virtualDecompositionCommitStrategy_1.VirtualDecompositionCommitStrategy(config);
        }
        return new fineGrainTrackingCommitStrategy_1.FineGrainTrackingCommitStrategy(config); // default
    }
    static newContentStrategy(metadataType, metadataRegistry, workspaceVersion) {
        if (metadataType.getDecompositionConfig().contentStrategy === 'nonDecomposedContent') {
            return new nonDecomposedContentStrategy_1.NonDecomposedContentStrategy(metadataType, metadataRegistry, workspaceVersion);
        }
        else if (metadataType.getDecompositionConfig().contentStrategy === 'staticResource') {
            return new staticResourceContentStrategy_1.StaticResourceContentStrategy(metadataType, metadataRegistry, workspaceVersion);
        }
        else if (metadataType.getDecompositionConfig().contentStrategy === 'experienceBundleStrategy') {
            return new experienceBundleContentStrategy_1.ExperienceBundleContentStrategy(metadataType, metadataRegistry, workspaceVersion);
        }
        return null;
    }
}
exports.DecompositionStrategyFactory = DecompositionStrategyFactory;

//# sourceMappingURL=decompositionStrategyFactory.js.map
