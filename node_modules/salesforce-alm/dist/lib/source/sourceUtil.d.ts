import { AggregateSourceElement } from './aggregateSourceElement';
import { MetadataType } from './metadataType';
import { SourceWorkspaceAdapter } from './sourceWorkspaceAdapter';
import { AggregateSourceElements } from './aggregateSourceElements';
import MetadataRegistry = require('./metadataRegistry');
import { RemoteSourceTrackingService } from './remoteSourceTrackingService';
declare type PerformFunction = (filePath: string, file?: string, dir?: string) => Promise<void>;
/**
 * Validate the value for the 'wait' parameter and reset it as a number.
 *
 * @param flags The command parameters (aka flags)
 * @param minWaitTime The minimum allowable time to wait
 */
export declare const parseWaitParam: (flags: {
    wait?: string;
}, minWaitTime?: number) => void;
export declare const actOn: (dir: string, perform: PerformFunction, onType?: 'file' | 'dir' | 'all') => Promise<void>;
export declare const areFilesEqual: (file1Path: string, file2Path: string) => Promise<boolean>;
/**
 * Validate that a manifest file path exists and is readable.
 *
 * @param manifestPath The path to the manifest file (package.xml)
 */
export declare const validateManifestPath: (manifestPath: string) => Promise<void>;
export declare function createOutputDir(cmdName: string): Promise<string>;
export declare function cleanupOutputDir(outputDir: string): Promise<void>;
/**
 * Return the aggregate source element for the specified file
 *
 * @param {string} sourcePath the file in the workspace
 * @param sourceWorkspaceAdapter
 * @returns {AggregateSourceElement}
 */
export declare const getSourceElementForFile: (sourcePath: string, sourceWorkspaceAdapter: SourceWorkspaceAdapter, metadataType?: MetadataType) => Promise<AggregateSourceElement>;
/**
 * Get the source elements from the source path, whether for a particular file or a directory
 */
export declare const getSourceElementsFromSourcePath: (optionsSourcePath: string, sourceWorkspaceAdapter: SourceWorkspaceAdapter) => Promise<AggregateSourceElements>;
/**
 * Return the specified aggregate source element or error if it does not exist
 *
 * @param {AggregateSourceElements} sourceElements All the source elements in the workspace
 * @param {string} key The key of the particular source element we are looking for
 * @param {string} packageName
 * @param {MetadataRegistry} metadataRegistry
 * @returns {AggregateSourceElement}
 */
export declare const loadSourceElement: (sourceElements: AggregateSourceElements, key: string, metadataRegistry: MetadataRegistry, packageName?: string) => AggregateSourceElement;
/**
 * Return the aggregate source elements found in the provided source path
 *
 * @param {Array<string>} sourcePath The path to look for source elements in
 * @param sourceWorkspaceAdapter
 * @returns {AggregateSourceElements}
 */
export declare const getSourceElementsInPath: (sourcePath: string, sourceWorkspaceAdapter: any) => Promise<AggregateSourceElements>;
/**
 * Used to determine if an error is the result of parsing bad XML. If so return a new parsing error.
 *
 * @param path The file path.
 * @param error The error to inspect.
 */
export declare const checkForXmlParseError: (path: string, error: Error) => Error;
/**
 * @param options
 */
export declare const containsMdBundle: (options: any) => boolean;
/**
 * Filters the component success responses from a deploy or retrieve to exclude
 * components that do not have SourceMembers created for them in the org, such
 * as standard objects (e.g., Account) and standard fields before syncing with
 * remote source tracking.  Also modifies the fullName (e.g., MyApexClass) of
 * certain metadata types to match their corresponding SourceMember names.
 *
 * Filtering rules applied:
 *   1. Component successes without an `id` entry do not have `SourceMember`
 *      records created for them.
 *      E.g., standard objects, package.xml, CustomLabels, etc.
 *   2. In-Folder types (E.g., Documents) will have the file extension removed
 *      since the SourceMember's MemberName does not include it.
 *      E.g., "MyDocFolder/MyDoc.png" --> "MyDocFolder/MyDoc"
 *   3. Component success fullNames will be URI decoded.
 *      E.g., "Account %28Sales%29" --> "Account (Sales)"
 *
 * NOTE: Currently this is only called after a source:push.
 *
 * @param successes the component successes of a deploy/retrieve response
 * @param remoteSourceTrackingService
 * @param metadataRegistry
 */
export declare const updateSourceTracking: (successes: any[], remoteSourceTrackingService: RemoteSourceTrackingService, metadataRegistry: MetadataRegistry) => Promise<void>;
export {};
