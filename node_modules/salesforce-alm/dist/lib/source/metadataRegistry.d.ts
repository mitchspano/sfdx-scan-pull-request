import { TypeDefObj } from './typeDefObj';
interface TypeDefObjs {
    [key: string]: TypeDefObj;
}
declare class MetadataRegistry {
    private readonly typeDefs;
    private readonly typeDirectories;
    private readonly lightningDefTypes;
    private readonly waveDefTypes;
    private lwcDefTypes;
    private typeDefsByExtension;
    private readonly metadataFileExt;
    private readonly projectPath;
    constructor();
    isSupported(metadataName: any): any;
    static getMetadataFileExt(): string;
    getMetadataTypeDefs(): TypeDefObjs;
    /**
     * Returns a formatted key provided a metadata type and name.  This is used as a unique
     * identifier for metadata.  E.g., `ApexClass__MyClass`
     *
     * @param metadataType The metadata type. E.g., `ApexClass`
     * @param metadataName The metadata name. E.g., `MyClass`
     */
    static getMetadataKey(metadataType: string, metadataName: string): string;
    private getTypeDirectories;
    private getTypeDefsByExtension;
    getLightningDefByFileName(fileName: any): any;
    getWaveDefByFileName(fileName: any): any;
    getLightningDefByType(type: any): any;
    /**
     * Returns the array of typeDefs where the default directory of each typeDef matches the passed in 'name' param
     *
     * @param name
     * @returns {any[]}
     */
    getTypeDefinitionsByDirectoryName(name: any): TypeDefObj[];
    getTypeDefinitionByMetadataName(metadataName: string): TypeDefObj;
    getTypeDefinitionByFileName(filePath: string, useTrueExtType?: boolean): any;
    private getTypeDefinitionByFileNameWithNonStandardExtension;
    private getTypeDefinitionByFileNameWithCoresidentMetadataFile;
    private getTypeDefinitionByFileNameMatchingDefaultDirectory;
    private isDirPathExpended;
    isValidAuraSuffix(suffix: any): boolean;
    private isValidWaveTemplateSuffix;
    isValidLwcSuffix(suffix: any): boolean;
    isValidMetadataExtension(ext: any): boolean;
    private isValidDecompositionExtension;
    private isValidExperienceBundleFile;
    /**
     * @param dirName - metadataObjDirName
     * @param pathToSplit - /baseDir/metadataObjDirName(ie, dirName)/bundleFiles
     *
     * This function is like pathToSplit.split(dirName). except that it splits on the last occurance of dirName
     * If there is a parent dir with the same name as metadata object dir name, then pathToSplit.split(dirName) may
     * not give desired result, so getting the last occurance of the dir name to split on and splitting based on that
     *
     * @param pathToSplit - An array with 2 elements in it. pathToSplit[0] - baseDir and pathToSplit[1] - bundleFiles
     */
    static splitOnDirName(dirName: string, pathToSplit: string): string[];
    isValidSourceFilePath(sourcePath: any): boolean;
    isCustomName(name: any): boolean;
}
export = MetadataRegistry;
