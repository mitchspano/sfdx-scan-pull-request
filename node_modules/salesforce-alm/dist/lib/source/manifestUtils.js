"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseManifestEntries = exports.createManifest = exports.toManifest = void 0;
const PathUtil = require("../source/sourcePathUtil");
const ManifestCreateApi = require("./manifestCreateApi");
// eslint-disable-next-line @typescript-eslint/require-await
exports.toManifest = async function (org, options, tmpOutputDir) {
    if (options && options.metadata) {
        const entries = exports.parseManifestEntries(options.metadata);
        if (entries != null) {
            // Create a manifest and update the options with the manifest file.
            options.manifest = (await exports.createManifest(org, options, entries, tmpOutputDir)).file;
            return options.manifest;
        }
        else {
            return null;
        }
    }
    return null;
};
/**
 * Function to create a manifest for a given org
 *
 * @param org {AnyJson} An org
 * @param options {SourceOptions} Source options
 * @param mdPairs {ManifestEntry[]} Array of metadata items
 * @returns A package.xml manifest
 */
exports.createManifest = function (org, options, mdPairs = [], tmpOutputDir) {
    if (!org || !options) {
        return null;
    }
    const manifestApi = new ManifestCreateApi(org);
    // Create the package.xml in the temp dir
    const manifestOptions = Object.assign({}, options, {
        outputdir: tmpOutputDir,
    });
    return manifestApi.createManifest(manifestOptions, null, mdPairs);
};
/**
 * Parse manifest entry strings into an array of ManifestEntry objects
 *
 * @param arg {string} The entry string; e.g., "ApexClass, CustomObject:MyObjectName"
 */
exports.parseManifestEntries = function (entries) {
    if (entries) {
        const mdParamArray = entries.split(',');
        return mdParamArray.map((md) => {
            const [mdType, ...rest] = md.split(':');
            const mdName = rest.length ? rest.join(':') : '*';
            return { type: mdType.trim(), name: PathUtil.replaceForwardSlashes(mdName.trim()) };
        });
    }
    return null;
};

//# sourceMappingURL=manifestUtils.js.map
