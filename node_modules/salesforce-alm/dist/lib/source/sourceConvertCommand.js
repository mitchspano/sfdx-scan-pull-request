"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
// Node
const path = require("path");
const util = require("util");
const fs = require("fs");
// 3PP
const BBPromise = require("bluebird");
const optional = require("optional-js");
// Local
const srcDevUtil = require("../core/srcDevUtil");
const Messages = require("../messages");
const messages = Messages();
const Org = require("../core/scratchOrgApi");
const logger = require("../core/logApi");
const SourceConvertApi = require("./sourceConvertApi");
const COMMAND_TEMP_ORG = 'sourceConvertTempOrg@org.org';
class SourceConvertCommand {
    constructor() {
        this.logger = logger.child('source:convert');
    }
    validate(context) {
        const fixedContext = srcDevUtil.fixCliContext(context);
        this.scratchOrg = new Org();
        this.scratchOrg.setName(COMMAND_TEMP_ORG);
        const defaultOutputDir = `metadataPackage_${Date.now()}`;
        this.outputDir = optional.ofNullable(fixedContext.outputdir).orElse(defaultOutputDir);
        this.packagename = optional.ofNullable(fixedContext.packagename).orElse(null);
        if (util.isNullOrUndefined(fixedContext.rootdir)) {
            this.rootDir = path.resolve(this.scratchOrg.config.getAppConfig().defaultPackagePath);
        }
        else {
            this.rootDir = path.resolve(fixedContext.rootdir);
            const rootDirParentPath = path.dirname(this.rootDir);
            const filenames = fs.readdirSync(rootDirParentPath);
            if (filenames.indexOf(path.basename(this.rootDir)) === -1) {
                const error = new Error(messages.getMessage('invalidRootDirectory', this.rootDir, 'sourceConvertCommand'));
                return BBPromise.reject(error);
            }
        }
        fixedContext.outputDir = this.outputDir;
        fixedContext.rootDir = this.rootDir;
        fixedContext.packagename = this.packagename;
        return BBPromise.resolve(fixedContext);
    }
    execute(context) {
        const sourceConvertApi = new SourceConvertApi(this.scratchOrg);
        context.unsupportedMimeTypes = []; // for logging unsupported static resource mime types
        return sourceConvertApi
            .doConvert(context)
            .then(() => srcDevUtil.logUnsupportedMimeTypeError(context.unsupportedMimeTypes, this.logger, this.scratchOrg.force))
            .then(() => BBPromise.resolve({ location: path.resolve(this.outputDir) }))
            .finally(() => this.scratchOrg.cleanData());
    }
    getHumanSuccessMessage() {
        return messages.getMessage('success', path.resolve(this.outputDir), 'sourceConvertCommand');
    }
}
module.exports = SourceConvertCommand;

//# sourceMappingURL=sourceConvertCommand.js.map
