"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkInvalidLoginUrlWithAccessToken = exports.checkServer500 = exports.checkVersionMisMatchAsync = exports.checkOauthAnd404 = exports.getProcessors = exports.CheckStatus = void 0;
const _ = require("lodash");
const almError = require("./core/almError");
const defaultConnectedApp = require('./core/defaultConnectedApp');
const Messages = require("./messages");
const messages = Messages();
const BUNDLE_NAME = 'IndexErrorProcessor';
/**
 * Simple enum so the error processors can returns something that indicates the check
 * completed and no problems were found.
 */
var CheckStatus;
(function (CheckStatus) {
    CheckStatus[CheckStatus["OK"] = 0] = "OK";
})(CheckStatus = exports.CheckStatus || (exports.CheckStatus = {}));
/**
 * Returns an array of processors used to determine if an error can be further refined. Instead of
 * adding more error handing logic to index.js add it here, as it's much easier to unit test.
 *
 * @param appConfig - the sfdx configuration
 * @param context - the cli context
 * @param err - a potentially course grained error thrown by the cli.
 */
function getProcessors(appConfig, context, err) {
    return [
        checkVersionMisMatchAsync(context, err),
        checkServer500(err),
        checkOauthAnd404(appConfig, context, err),
        checkInvalidLoginUrlWithAccessToken(context, err),
    ];
}
exports.getProcessors = getProcessors;
/**
 * Check is there is an invalid grant with oauth or a 404 response from the server.
 *
 * @param appConfig - sfdx configuration
 * @param context - cli context
 * @param err - an error from the cli
 */
function checkOauthAnd404(appConfig, context, err) {
    if (context && err && (err.name === 'invalid_grant' || err.name === 'ERROR_HTTP_404')) {
        const notFoundMessage = messages.getMessage('notSpecified');
        let authConfig = {};
        if (context.org) {
            authConfig = context.org.authConfig;
        }
        else {
            _.set(authConfig, 'username', context.flags.username);
            _.set(authConfig, 'clientId', context.flags.clientid);
            _.set(authConfig, 'privateKey', context.flags.jwtkeyfile);
            if (appConfig) {
                _.set(authConfig, 'loginUrl', appConfig.sfdcLoginUrl);
            }
        }
        throw almError('oauthInvalidGrant', [
            // We know the 404 and invalid grant error always contain a name and message.
            // The 404 error message is an html error page response.
            err.name.includes('404') ? err.name : `${err.name} - ${err.message}`,
            _.isNil(authConfig.username) ? notFoundMessage : authConfig.username,
            _.isNil(authConfig.clientId) || authConfig.clientId === defaultConnectedApp.legacyClientId
                ? notFoundMessage
                : authConfig.clientId,
            _.isNil(authConfig.loginUrl) ? notFoundMessage : authConfig.loginUrl,
            _.isNil(authConfig.privateKey) ? notFoundMessage : authConfig.privateKey,
        ], 'oauthInvalidGrantAction');
    }
    return CheckStatus.OK;
}
exports.checkOauthAnd404 = checkOauthAnd404;
/**
 * Check that the servers api version is <= to the local config apiVersion.
 *
 * @param context - the cli context that contains an org
 * @param _err  - an error thrown by the cli
 */
async function checkVersionMisMatchAsync(context, _err) {
    if (_err && _err.name === 'NOT_FOUND') {
        if (context && context.org) {
            const maxApiVersionForOrg = await context.org.retrieveMaxApiVersion();
            const configVersion = context.org.force.config.getApiVersion();
            if (_.toNumber(configVersion) > _.toNumber(maxApiVersionForOrg.version)) {
                throw almError({ bundle: BUNDLE_NAME, keyName: 'apiMisMatch' }, [configVersion, maxApiVersionForOrg.version], {
                    keyName: 'apiMisMatchAction',
                    bundle: BUNDLE_NAME,
                });
            }
        }
    }
    return CheckStatus.OK;
}
exports.checkVersionMisMatchAsync = checkVersionMisMatchAsync;
/**
 * Check to see if the throw error is a server 500. THis error is critical. If a database is being update in production
 * This error is throw after a rest style connection. It's imperative that customer's get a link to http://trust.salesforce.com
 *
 * @param _err - an error to process thrown by the cli.
 */
function checkServer500(_err) {
    if (_err && _err.name === 'ERROR_HTTP_500' && _.isEmpty(_.trim(_err.message))) {
        throw almError({ bundle: BUNDLE_NAME, keyName: 'server500' }, null, {
            bundle: BUNDLE_NAME,
            keyName: 'server500Action',
        });
    }
    return CheckStatus.OK;
}
exports.checkServer500 = checkServer500;
function checkInvalidLoginUrlWithAccessToken(context, err) {
    // provide action if instanceurl is incorrect
    const message = err.message ? err.message : err;
    if ((context.org && context.org.usingAccessToken && message.toString().match(/Session expired or invalid/)) ||
        message.toString().match(/Destination URL not reset/)) {
        let _err = new Error();
        _err['message'] = messages.getMessage('accessTokenLoginUrlNotSet', message);
        if (_.isNil(err.action)) {
            _err['action'] = messages.getMessage('invalidInstanceUrlForAccessTokenAction');
        }
        else {
            _err['action'] = err.action;
        }
        throw _err;
    }
    return CheckStatus.OK;
}
exports.checkInvalidLoginUrlWithAccessToken = checkInvalidLoginUrlWithAccessToken;

//# sourceMappingURL=indexErrorProcessor.js.map
