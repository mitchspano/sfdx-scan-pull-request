import PackageVersionCreateRequestApi = require('./packageVersionCreateRequestApi');
declare const _default: {
    BY_PREFIX: any;
    BY_LABEL: any;
    validateId(idObj: any, value: any): void;
    validateIdNoThrow(idObj: any, value: any): any;
    validateVersionNumber(versionNumberString: any, supportedBuildNumberToken: any, supportedBuildNumberToken2: any): any;
    validatePatchVersion(force: any, org: any, versionNumberString: any, packageId: any): Promise<void>;
    validUrl(url: any): boolean;
    isErrorFromSPVQueryRestriction(err: any): any;
    isErrorPackageNotAvailable(err: any): boolean;
    massageErrorMessage(err: any): any;
    applyErrorAction(err: any): any;
    /**
     * Given a subscriber package version ID (04t) or package version ID (05i), return the package version ID (05i)
     *
     * @param versionId The suscriber package version ID
     * @param force For tooling query
     * @param org For tooling query
     */
    getPackageVersionId(versionId: any, force: any, org: any): any;
    /**
     * Given 0Ho the package type type (Managed, Unlocked, Locked(deprecated?))
     *
     * @param package2Id the 0Ho
     * @param force For tooling query
     * @param org For tooling query
     * @throws Error with message when package2 cannot be found
     */
    getPackage2Type(package2Id: string, force: any, org: any): Promise<string>;
    /**
     * Given 04t the package type type (Managed, Unlocked, Locked(deprecated?))
     *
     * @param package2VersionId the 04t
     * @param force For tooling query
     * @param org For tooling query
     * @param installKey For tooling query, if an install key is applicable to the package version it must be passed in the queries
     * @throws Error with message when package2 cannot be found
     */
    getPackage2TypeBy04t(package2VersionId: string, force: any, org: any, installKey: any): Promise<string>;
    /**
     * Given a package version ID (05i) or subscriber package version ID (04t), return the subscriber package version ID (04t)
     *
     * @param versionId The suscriber package version ID
     * @param force For tooling query
     * @param org For tooling query
     */
    getSubscriberPackageVersionId(versionId: any, force: any, org: any): any;
    /**
     * Get the ContainerOptions for the specified Package2 (0Ho) IDs.
     *
     * @return Map of 0Ho id to container option api value
     * @param poackage2Ids The list of package IDs
     * @param force For tooling query
     * @param org For tooling query
     */
    getContainerOptions(package2Ids: any, force: any, org: any): Promise<any>;
    /**
     * Return the Package2Version.HasMetadataRemoved field value for the given Id (05i)
     *
     * @param packageVersionId package version ID (05i)
     * @param force For tooling query
     * @param org For tooling query
     */
    getHasMetadataRemoved(packageVersionId: any, force: any, org: any): Promise<any>;
    /**
     * Given a list of subscriber package version IDs (04t), return the associated version strings (e.g., Major.Minor.Patch.Build)
     *
     * @return Map of subscriberPackageVersionId to versionString
     * @param versionIds The list of suscriber package version IDs
     * @param force For tooling query
     * @param org For tooling query
     */
    getPackageVersionStrings(subscriberPackageVersionIds: any, force: any, org: any): Promise<any>;
    /**
     * For queries with an IN condition, determine if the WHERE clause will exceed
     * SOQL's 4000 character limit.  Perform multiple queries as needed to stay below the limit.
     *
     * @return concatenated array of records returned from the resulting query(ies)
     * @param query The full query to execute containing the replaceToken param in its IN clause
     * @param items The IN clause items.  A length-appropriate single-quoted comma-separated string chunk will be made from the items.
     * @param replaceToken A placeholder in the query's IN condition that will be replaced with the chunked items
     * @param force For tooling query
     * @param org For tooling query
     */
    queryWithInConditionChunking(query: any, items: any, replaceToken: any, force: any, org: any): Promise<any[]>;
    /**
     *   Returns the number of items that can be included in a quoted comma-separated string (e.g., "'item1','item2'") not exceeding maxLength
     */
    getInClauseItemsCount(items: any, startIndex: any, maxLength: any): number;
    /**
     *   Execute a tooling query
     */
    toolingQuery(query: any, force: any, org: any): Promise<any>;
    /**
     * Return a version string in Major.Minor.Patch.Build format, using 0 for any emtpy part
     */
    concatVersion(major: any, minor: any, patch: any, build: any): string;
    /**
     * Given a package descriptor, return the ancestor ID. This code was duplicated to scratchOrgInfoGenerator.getAncestorIds,
     * changes here may need to be duplicated there until that code, and/or this code is moved to a separate plugin.
     *
     * @param packageDescriptorJson JSON for packageDirectories element in sfdx-project.json
     * @param force For tooling query
     * @param org For tooling query
     */
    getAncestorId(packageDescriptorJson: any, force: any, org: any, versionNumberString: any, skipAncestorCheck: any): Promise<any>;
    validateAncestorId(ancestorId: any, highestReleasedVersion: any, explicitUseNoAncestor: any, isPatch: any, skipAncestorCheck: any, origSpecifiedAncestor: any): any;
    getAncestorIdHighestRelease(force: any, org: any, packageId: any, versionNumber: any, versionNumberString: any, isPatch: any, explicitUseHighestRelease: any, skipAncestorCheck: any): Promise<{
        finalAncestorId: any;
        highestReleasedVersion: any;
    }>;
    getPackage2VersionNumber(package2VersionObj: any): string;
    getConfigPackageDirectories(context: any): any;
    getConfigPackageDirectory(packageDirs: any, lookupProperty: any, lookupValue: any): any;
    /**
     * Given a packageAlias, attempt to return the associated id from the config
     *
     * @param packageAlias string representing a package alias
     * @param force for obtaining the project config
     * @returns the associated id or the arg given.
     */
    getPackageIdFromAlias(packageAlias: any, force: any): any;
    /**
     * @param stringIn pascal or camel case string
     * @returns space delimited and lower-cased (except for 1st char) string (e.g. in "AbcdEfghIj" => "Abcd efgh ij")
     */
    convertCamelCaseStringToSentence(stringIn: any): any;
    /**
     * Given a package id, attempt to return the associated aliases from the config
     *
     * @param packageid string representing a package id
     * @param force for obtaining the project config
     * @returns an array of alias for the given id.
     */
    getPackageAliasesFromId(packageId: any, force: any): string[];
    findOrCreatePackage2(seedPackage: string, force: any, org: any): Promise<any>;
    _getPackageVersionCreateRequestApi(force: any, org: any): PackageVersionCreateRequestApi;
    pollForStatusWithInterval(context: any, id: any, retries: any, packageId: any, logger: any, withProject: any, force: any, org: any, interval: any): any;
    pollForStatus(context: any, id: any, retries: any, packageId: any, logger: any, withProject: any, force: any, org: any): any;
    /**
     * Writes objects specified in the config to the sfdx-project.json file on disk.
     *
     * @param context
     * @private
     */
    _writeProjectConfigToDisk(context: any, config: any, logger: any): any;
    /**
     * Generate package alias json entry for this package version that can be written to sfdx-project.json
     *
     * @param context
     * @param packageVersionId 04t id of the package to create the alias entry for
     * @param packageVersionNumber that will be appended to the package name to form the alias
     * @param packageId the 0Ho id
     * @private
     */
    _generatePackageAliasEntry(context: any, packageVersionId: any, packageVersionNumber: any, branch: any, packageId: any): Promise<{
        packageAliases: any;
    }>;
    /**
     * Return true if the queryResult.records[0].Status is equal to one of the values in statuses.
     *
     * @param results to examine
     * @param statuses array of statuses to look for
     * @returns {boolean} if one of the values in status is found.
     */
    _isStatusEqualTo(results: any, statuses?: any): boolean;
    getSoqlWhereClauseMaxLength(): any;
    LATEST_BUILD_NUMBER_TOKEN: string;
    NEXT_BUILD_NUMBER_TOKEN: string;
    RELEASED_BUILD_NUMBER_TOKEN: string;
    HIGHEST_VERSION_NUMBER_TOKEN: string;
    VERSION_NUMBER_SEP: string;
    INSTALL_URL_BASE: string;
    DEFAULT_PACKAGE_DIR: {
        path: string;
        package: string;
        versionName: string;
        versionNumber: string;
        default: boolean;
    };
    SOQL_WHERE_CLAUSE_MAX_LENGTH: number;
    POLL_INTERVAL_SECONDS: number;
};
export = _default;
