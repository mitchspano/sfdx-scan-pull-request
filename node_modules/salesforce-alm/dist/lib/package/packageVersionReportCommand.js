"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
// Node
const util = require("util");
// Local
const Messages = require("../messages");
const messages = Messages();
const logger = require("../core/logApi");
const pkgUtils = require("./packageUtils");
const QUERY = 'SELECT Package2Id, SubscriberPackageVersionId, Name, Description, Tag, Branch, AncestorId, ValidationSkipped, ' +
    'MajorVersion, MinorVersion, PatchVersion, BuildNumber, IsReleased, CodeCoverage, HasPassedCodeCoverageCheck, ' +
    'Package2.IsOrgDependent, ReleaseVersion, BuildDurationInSeconds, HasMetadataRemoved, CreatedById ' +
    'FROM Package2Version ' +
    "WHERE Id = '%s' AND IsDeprecated != true " +
    'ORDER BY Package2Id, Branch, MajorVersion, MinorVersion, PatchVersion, BuildNumber';
// verbose adds: Id, ConvertedFromVersionId, SubscriberPackageVersion.Dependencies
const QUERY_VERBOSE = 'SELECT Id, Package2Id, SubscriberPackageVersionId, Name, Description, Tag, Branch, AncestorId, ValidationSkipped, ' +
    'MajorVersion, MinorVersion, PatchVersion, BuildNumber, IsReleased, CodeCoverage, HasPassedCodeCoverageCheck, ConvertedFromVersionId, ' +
    'Package2.IsOrgDependent, ReleaseVersion, BuildDurationInSeconds, HasMetadataRemoved, SubscriberPackageVersion.Dependencies, ' +
    'CreatedById, CodeCoveragePercentages ' +
    'FROM Package2Version ' +
    "WHERE Id = '%s' AND IsDeprecated != true " +
    'ORDER BY Package2Id, Branch, MajorVersion, MinorVersion, PatchVersion, BuildNumber';
class PackageVersionReportCommand {
    constructor() {
        this.logger = logger.child('package:version:report');
    }
    execute(context) {
        return this._execute(context).catch((err) => {
            // TODO
            // until package2 is GA, wrap perm-based errors w/ 'contact sfdc' action (REMOVE once package2 is GA'd)
            throw pkgUtils.applyErrorAction(err);
        });
    }
    async _execute(context) {
        this.org = context.org;
        this.force = context.org.force;
        this.verbose = context.flags.verbose;
        this.haveCodeCoverageData = false; // used for displaying extra table for code coverage data
        let packageVersionId = pkgUtils.getPackageIdFromAlias(context.flags.package, this.force);
        const maximumNumClasses = 15; // Number of least code covered classes displayed on the cli output for better UX
        // ID can be an 04t or 05i
        pkgUtils.validateId([pkgUtils.BY_LABEL.SUBSCRIBER_PACKAGE_VERSION_ID, pkgUtils.BY_LABEL.PACKAGE_VERSION_ID], packageVersionId);
        // lookup the 05i ID, if needed
        packageVersionId = await pkgUtils.getPackageVersionId(packageVersionId, this.force, this.org);
        return this.force
            .toolingQuery(this.org, util.format(this.verbose ? QUERY_VERBOSE : QUERY, packageVersionId))
            .then(async (queryResult) => {
            const results = [];
            const records = queryResult.records;
            if (records && records.length > 0) {
                const record = records[0];
                record.Version = [record.MajorVersion, record.MinorVersion, record.PatchVersion, record.BuildNumber].join('.');
                let ancestorVersion = null;
                let dependencies = null;
                let codeCovStr = ''; // String to display when code coverage data is empty or null
                const retCoverageRecord = [];
                const containerOptions = await pkgUtils.getContainerOptions([record.Package2Id], this.force, this.org);
                const packageType = containerOptions.get(record.Package2Id);
                if (record.AncestorId) {
                    // lookup AncestorVersion value
                    const ancestorVersionMap = await pkgUtils.getPackageVersionStrings([record.AncestorId], this.force, this.org);
                    ancestorVersion = ancestorVersionMap.get(record.AncestorId);
                }
                else {
                    // otherwise display 'N/A' if package is Unlocked Packages
                    if (packageType !== 'Managed') {
                        ancestorVersion = 'N/A';
                        record.AncestorId = 'N/A';
                    }
                }
                record.CodeCoverage =
                    record.Package2.IsOrgDependent === true || record.ValidationSkipped === true ? 'N/A' : record.CodeCoverage;
                record.HasPassedCodeCoverageCheck =
                    record.Package2.IsOrgDependent === true || record.ValidationSkipped === true
                        ? 'N/A'
                        : record.HasPassedCodeCoverageCheck;
                record.Package2.IsOrgDependent =
                    packageType === 'Managed' ? 'N/A' : record.Package2.IsOrgDependent === true ? 'Yes' : 'No';
                // set HasMetadataRemoved to N/A for Unlocked, and No when value is false or absent (pre-230)
                record.HasMetadataRemoved =
                    packageType !== 'Managed' ? 'N/A' : record.HasMetadataRemoved === true ? 'Yes' : 'No';
                if (context.flags.json) {
                    // add AncestorVersion to the json record
                    record.AncestorVersion = ancestorVersion;
                }
                else {
                    // collect the Dependency 04ts into a comma-separated list for non-json output
                    if (this.verbose && records[0].SubscriberPackageVersion.Dependencies != null) {
                        dependencies = records[0].SubscriberPackageVersion.Dependencies.ids
                            .map((d) => d.subscriberPackageVersionId)
                            .join(', ');
                    }
                    // collect the code coverage data into an array of key value records for non-json output
                    if (this.verbose) {
                        const coverageData = record.CodeCoveragePercentages != null ? record.CodeCoveragePercentages.codeCovPercentages : null;
                        if (coverageData == null) {
                            codeCovStr = 'N/A'; // Code coverage isn't calculated as part of version create command
                        }
                        else if (coverageData.length == 0) {
                            // Calculated code coverage data is too big to fit into a DB field. Retrieve it from the packageZip
                            codeCovStr =
                                'The code coverage details are too large to display. To request code coverage details for this package version, log a case in the Salesforce Partner Community.';
                        }
                        else {
                            for (let i = 0; i < coverageData.length && i < maximumNumClasses; i++) {
                                retCoverageRecord.push({
                                    key: coverageData[i]['className'],
                                    value: `${coverageData[i]['codeCoveragePercentage']}%`,
                                });
                            }
                            this.haveCodeCoverageData = retCoverageRecord.length > 0;
                        }
                    }
                }
                // return json record as-is
                if (context.flags.json) {
                    return record;
                }
                const retRecord = [
                    {
                        key: messages.getMessage('name', [], 'package_version_list'),
                        value: record.Name,
                    },
                    {
                        key: messages.getMessage('subscriberPackageVersionId', [], 'package_version_list'),
                        value: record.SubscriberPackageVersionId,
                    },
                    { key: 'Id', value: record.Id },
                    {
                        key: messages.getMessage('packageId', [], 'package_version_list'),
                        value: record.Package2Id,
                    },
                    {
                        key: messages.getMessage('version', [], 'package_version_list'),
                        value: record.Version,
                    },
                    {
                        key: messages.getMessage('description', [], 'package_version_list'),
                        value: record.Description,
                    },
                    {
                        key: messages.getMessage('packageBranch', [], 'package_version_list'),
                        value: record.Branch,
                    },
                    {
                        key: messages.getMessage('packageTag', [], 'package_version_list'),
                        value: record.Tag,
                    },
                    { key: 'Released', value: record.IsReleased.toString() },
                    {
                        key: messages.getMessage('validationSkipped', [], 'package_version_list'),
                        value: record.ValidationSkipped,
                    },
                    { key: 'Ancestor', value: record.AncestorId },
                    { key: 'Ancestor Version', value: ancestorVersion },
                    {
                        key: messages.getMessage('codeCoverage', [], 'package_version_list'),
                        value: record.CodeCoverage == null
                            ? ' '
                            : record.CodeCoverage['apexCodeCoveragePercentage'] !== undefined
                                ? `${record.CodeCoverage['apexCodeCoveragePercentage']}%`
                                : record.CodeCoverage,
                    },
                    {
                        key: messages.getMessage('hasPassedCodeCoverageCheck', [], 'package_version_list'),
                        value: record.HasPassedCodeCoverageCheck,
                    },
                    {
                        key: messages.getMessage('convertedFromVersionId', [], 'package_version_list'),
                        value: record.ConvertedFromVersionId == null ? ' ' : record.ConvertedFromVersionId,
                    },
                    {
                        key: messages.getMessage('isOrgDependent', [], 'package_list'),
                        value: record.Package2.IsOrgDependent,
                    },
                    {
                        key: messages.getMessage('releaseVersion', [], 'package_version_list'),
                        value: record.ReleaseVersion == null ? '' : Number.parseFloat(record.ReleaseVersion).toFixed(1),
                    },
                    {
                        key: messages.getMessage('buildDurationInSeconds', [], 'package_version_list'),
                        value: record.BuildDurationInSeconds == null ? '' : record.BuildDurationInSeconds,
                    },
                    {
                        key: messages.getMessage('hasMetadataRemoved', [], 'package_version_list'),
                        value: record.HasMetadataRemoved,
                    },
                    {
                        key: messages.getMessage('dependencies', [], 'package_version_report'),
                        value: this.verbose && dependencies != null ? dependencies : ' ',
                    },
                    {
                        key: messages.getMessage('createdBy', [], 'package_list'),
                        value: record.CreatedById,
                    },
                ];
                // Always push the code coverage column label into the return record at the last
                retRecord.push({
                    key: messages.getMessage('codeCoveragePercentages', [], 'package_version_report'),
                    value: this.haveCodeCoverageData === true ? '...' : codeCovStr,
                });
                if (!this.verbose) {
                    // remove verbose-only fields from the non-json output (they're already absent from the json)
                    if (!context.flags.json) {
                        retRecord.splice(retRecord.map((e) => e.key).indexOf('Id'), 1);
                        retRecord.splice(retRecord
                            .map((e) => e.key)
                            .indexOf(messages.getMessage('convertedFromVersionId', [], 'package_version_list')), 1);
                        retRecord.splice(retRecord.map((e) => e.key).indexOf(messages.getMessage('dependencies', [], 'package_version_report')), 1);
                        retRecord.splice(retRecord
                            .map((e) => e.key)
                            .indexOf(messages.getMessage('codeCoveragePercentages', [], 'package_version_report')), 1);
                        retCoverageRecord.splice(0, retCoverageRecord.length);
                    }
                }
                const returnResults = this.haveCodeCoverageData === true ? { retRecord, retCoverageRecord } : { retRecord };
                return returnResults;
            }
            return results;
        });
    }
    /**
     * indicates that the human readable message should be tabular
     *
     * @returns {[{}...]}
     */
    getColumnData() {
        this.logger.styledHeader(this.logger.color.blue('Package Version'));
        return {
            ...{
                retRecord: { key: { header: 'Name' }, value: { header: 'Value' } },
            },
            ...(this.haveCodeCoverageData === true
                ? { retCoverageRecord: { key: { header: 'Class Name' }, value: { header: 'Code Coverage' } } }
                : {}),
        };
    }
}
PackageVersionReportCommand.QUERY = QUERY;
PackageVersionReportCommand.QUERY_VERBOSE = QUERY_VERBOSE;
module.exports = PackageVersionReportCommand;

//# sourceMappingURL=packageVersionReportCommand.js.map
