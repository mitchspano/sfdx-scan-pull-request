"use strict";
/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
// Node
const path = require("path");
const util = require("util");
const os = require("os");
const crypto = require("crypto");
const BBPromise = require("bluebird");
// Local
const logApi = require("../core/logApi");
const srcDevUtil = require("../core/srcDevUtil");
const PackageVersionCreateRequestApi = require("./packageVersionCreateRequestApi");
const pkgUtils = require("./packageUtils");
// import SettingsGenerator = require('../org/scratchOrgSettingsGenerator');
const PackageVersionCreateCommand = require("./packageVersionCreateCommand");
const fs = BBPromise.promisifyAll(require('fs-extra'));
class PackageConvertCommand {
    constructor() {
        this.DESCRIPTOR_FILE = 'package2-descriptor.json';
        this.maxRetries = 0;
        this.logger = logApi.child('package:convert');
        this.packageVersionCreateCommand = new PackageVersionCreateCommand();
    }
    execute(context) {
        return this.innerExecute(context).catch((err) => {
            err = pkgUtils.massageErrorMessage(err);
            throw pkgUtils.applyErrorAction(err);
        });
    }
    async innerExecute(context) {
        this.org = context.org;
        this.force = this.org.force;
        this.packageVersionCreateRequestApi = new PackageVersionCreateRequestApi(this.force, this.org);
        if (context.flags.wait) {
            this.maxRetries = (60 / pkgUtils.POLL_INTERVAL_SECONDS) * context.flags.wait;
        }
        // This command also requires either the installationkey flag or installationkeybypass flag
        if (!context.flags.installationkey && !context.flags.installationkeybypass) {
            return this.packageVersionCreateCommand.rejectWithInstallKeyError(context);
        }
        const seedPackage = context.flags.package;
        const packageId = await pkgUtils.findOrCreatePackage2(seedPackage, this.force, this.org);
        const request = await this.createPackageVersionCreateRequest(context, packageId);
        const createResult = await this.force.toolingCreate(this.org, 'Package2VersionCreateRequest', request);
        if (!createResult.success) {
            const errStr = createResult.errors && createResult.errors.length ? createResult.errors.join(', ') : createResult.errors;
            throw new Error(`Failed to create request${createResult.id ? ` [${createResult.id}]` : ''}: ${errStr}`);
        }
        let results;
        if (context.flags.wait) {
            results = await pkgUtils.pollForStatus(context, createResult.id, this.maxRetries, packageId, this.logger, false, this.force, this.org);
        }
        else {
            results = await this.packageVersionCreateRequestApi.byId(packageId);
        }
        return util.isArray(results) ? results[0] : results;
    }
    /**
     * Convert the list of command line options to a JSON object that can be used to create an Package2VersionCreateRequest entity.
     *
     * @param context: command context
     * @param packageId: package2 id to create a package version for
     * @returns {{Package2Id: string, Package2VersionMetadata: *, Tag: *, Branch: number}}
     * @private
     */
    async createPackageVersionCreateRequest(context, packageId) {
        const uniqueHash = crypto.createHash('sha1').update(`${Date.now()}${Math.random()}`).digest('hex');
        const packageVersTmpRoot = path.join(os.tmpdir(), `${packageId}-${uniqueHash}`);
        const packageVersBlobDirectory = path.join(packageVersTmpRoot, 'package-version-info');
        const packageVersBlobZipFile = path.join(packageVersTmpRoot, 'package-version-info.zip');
        const packageDescriptorJson = {
            id: packageId,
        };
        srcDevUtil.ensureDirectoryExistsSync(packageVersTmpRoot);
        srcDevUtil.ensureDirectoryExistsSync(packageVersBlobDirectory);
        fs.writeJSONAsync(path.join(packageVersBlobDirectory, this.DESCRIPTOR_FILE), packageDescriptorJson);
        // Zip the Version Info and package.zip files into another zip
        await srcDevUtil.zipDir(packageVersBlobDirectory, packageVersBlobZipFile);
        return this.createRequestObject(packageId, context, packageVersTmpRoot, packageVersBlobZipFile);
    }
    createRequestObject(packageId, context, packageVersTmpRoot, packageVersBlobZipFile) {
        const zipFileBase64 = fs.readFileSync(packageVersBlobZipFile).toString('base64');
        const requestObject = {
            Package2Id: packageId,
            VersionInfo: zipFileBase64,
            InstallKey: context.flags.installationkey,
            Instance: context.flags.buildinstance,
            IsConversionRequest: true,
        };
        return fs.removeAsync(packageVersTmpRoot).then(() => requestObject);
    }
    /**
     *
     * @param result - the data representing the Package Version, must include a 'Status' property
     * @returns {string} a human readable message for CLI output
     */
    getHumanSuccessMessage(result) {
        return this.packageVersionCreateCommand.getHumanSuccessMessage(result);
    }
}
module.exports = PackageConvertCommand;

//# sourceMappingURL=packageConvertCommand.js.map
